{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-snippet/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/tagcanvas.min.js","path":"assets/tagcanvas.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/branding.png","path":"img/branding.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/reward-wepay.jpg","path":"img/reward-wepay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline.gif","path":"img/timeline.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline-clock.gif","path":"img/timeline-clock.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline-dot.gif","path":"img/timeline-dot.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/valine.min.js","path":"assets/valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-snippet/.DS_Store","hash":"9a8cde3925b3c1cace2eddfad6106be6ae3276a7","modified":1560247133000},{"_id":"source/.DS_Store","hash":"c85b7dbde29b4528cc689a36906203fdd69503aa","modified":1563431211000},{"_id":"themes/hexo-theme-snippet/.gitignore","hash":"966980bf3a75dbcdc09b08664e6084139799b498","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.travis.yml","hash":"1bf058f8cd79c0c19393ad5bc7fd837b10b6f1c6","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/LICENSE","hash":"c720db99e36a717d9808bf97b736612462e883dd","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/README.md","hash":"8b43257839272aeac1ddfeb11e75759f92202a41","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/_config.yml","hash":"e1bf84bb20e1b0afb61492bfe27b3df810eee435","modified":1561102718000},{"_id":"themes/hexo-theme-snippet/_travis.sh","hash":"2ad37ebb33683f71b605997edbc408c70de230c3","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/gulpfile.js","hash":"16aae4664f8077b8974e460c7dbcbda131b433e3","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/package.json","hash":"fc7ed09c52ba1a2ebbfefa085e3a65b5af43dfb7","modified":1556178764000},{"_id":"source/_posts/.DS_Store","hash":"5a3030848c6e09441d1a2d5ef808d007c0a50a1e","modified":1563431232000},{"_id":"source/_posts/angular路由使用.md","hash":"567371d01ccff5421dd2f03d3a1f485b340e4a3b","modified":1556259716000},{"_id":"source/_posts/art-template的模板引擎.md","hash":"82222a58775a47a106dbf97c596d6c68396018b2","modified":1556258703000},{"_id":"source/_posts/HTML5总结.md","hash":"29acc0695e9f874fba9cec3adab5348cf507bedd","modified":1556261869000},{"_id":"source/_posts/canvas第一天.md","hash":"50778cdad2a218e813177215dda57026d0909cee","modified":1556263753000},{"_id":"source/_posts/canvas第三天.md","hash":"97a225ab2461e48bf113e8b89e07bb404ffe1965","modified":1556263756000},{"_id":"source/_posts/canvas第二天.md","hash":"d8b0198533123f84faab559a884bbc8709b1a907","modified":1556261209000},{"_id":"source/_posts/css3.md","hash":"d191445c0e1f62d363a7de8aa064e735cbe77af2","modified":1556259498000},{"_id":"source/_posts/git.md","hash":"2b3e9190a6ac4d53decb94e3122ba517ca8c2404","modified":1556259899000},{"_id":"source/_posts/html5标签兼容性.md","hash":"ab7a98cabb11a6632eb9ee467f67ca343e7f365f","modified":1556259690000},{"_id":"source/_posts/html5第一天.md","hash":"cd544b931dfbde601d43d713158e804f256e2d5e","modified":1556261897000},{"_id":"source/_posts/html5第二天.md","hash":"2ff0eec65e3a36d30f849d83e54a12b14a752464","modified":1556261910000},{"_id":"source/_posts/html5表单.md","hash":"8be231d25d03b36c4feff47299c78807b66fc5da","modified":1556259645000},{"_id":"source/_posts/less使用.md","hash":"aca9a38f3b5540a9d06bb4fdfeb0ec85378d0a4e","modified":1556258818000},{"_id":"source/_posts/npm browser gulp使用.md","hash":"8498fb7b18d0419ca31d16d5d0fb717fa0f079e7","modified":1556260012000},{"_id":"source/_posts/seajs  and requirejs.md","hash":"55159fb657f3b4002c697d2fa88dda36710cf6e3","modified":1556258947000},{"_id":"source/_posts/事件冒泡与捕获.md","hash":"312b3c3bfae474803215156f1f0beff04321b2ba","modified":1556261761000},{"_id":"source/_posts/字符串方法.md","hash":"9a8b5df9d886b631711d5d50019a9bfa1ee3c7dc","modified":1556258680000},{"_id":"source/_posts/正则表达式.md","hash":"4c8c9910bf0c83258376d2c3d8bf5289747064b8","modified":1556260069000},{"_id":"themes/hexo-theme-snippet/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/config","hash":"214a85318a9dcbb07db2dbfe66ae4d2771fe1b6c","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/packed-refs","hash":"54fe41758f484b3a9ee845990243a3a916c544a3","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/index","hash":"1d8188dfcffe11fc1d241e7b703c01a9fe1b346a","modified":1556263552000},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE.md","hash":"e90f313849ccea4f9fe86f7d3611dfaa6a7d3e8b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/languages/default.yml","hash":"9aa7b39d384f49a4f16c6a4da272e34d71f4ee7f","modified":1556183001000},{"_id":"themes/hexo-theme-snippet/languages/zh-TW.yml","hash":"a0bd8ba3e9ad19116e072983cfefd1aabe39d2cd","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/languages/zh-CN.yml","hash":"4ebacd2028454a5b9642a22c19d3e8c3078b3a0a","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/languages/ja.yml","hash":"fcafdb03d5e000c225a664d65f38a75c7efdef03","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/archive.ejs","hash":"bbd99d08132f9ca87e5b17cf642384dc1673f579","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/index.ejs","hash":"4b17eb2082d177b0cb85f04afadcc604f4073d30","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/post.ejs","hash":"d0aa6f0fda520815307d2adc2aacaf5314919d8f","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/scripts/process.js","hash":"c2f0571899a6dd38bd944aaf47e21fc650f7d52e","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/scripts/helper.js","hash":"836d369cf95ac51de957e09d396e6a8be1e84cf6","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/.DS_Store","hash":"d0b9cd12d533543e468a6ce433db1eb6eda66d72","modified":1560248427000},{"_id":"themes/hexo-theme-snippet/layout/layout.ejs","hash":"c986efe07c070e0870b89181cc47010b118e2d04","modified":1556178764000},{"_id":"source/_posts/DataStructure/JavaScript字典和散列表.md","hash":"2002fa3c9aa5584544d217d8c31985ffef6fd8c6","modified":1560852189000},{"_id":"source/_posts/DataStructure/JavaScript队列(Queue).md","hash":"accb95ba9bada67ce810b7ddddbd076c5b3bcecc","modified":1560497898000},{"_id":"source/_posts/Mongodb/Mongodb.md","hash":"266cf0e72ab4acb41ef12620078632ec1ca940f7","modified":1559810013000},{"_id":"themes/hexo-theme-snippet/source/favicon.ico","hash":"e248b367a302e89427ea897da1630e60006cdc33","modified":1560247104000},{"_id":"source/_posts/TypeScript/TypeScript.md","hash":"998ae5d2efdafcf1701741f595cbae702aec9828","modified":1560319751000},{"_id":"source/_posts/Vue/vuex.md","hash":"ce7c9495a088bdc0947c204b610e0c5ff75b211f","modified":1559815207000},{"_id":"source/_posts/DataStructure/JavaScript双端队列(Queue).md","hash":"5d210499bfdfb52ef4e97682bb8c15bf6f37a08e","modified":1560501904000},{"_id":"source/_posts/排序算法和搜索算法/.DS_Store","hash":"16b0e2c3cdbe143807c5f1cd2543494723174657","modified":1561102994000},{"_id":"source/_posts/排序算法和搜索算法/排序算法.md","hash":"48f10da0a65ee8c40438ceeff78761803c5526fa","modified":1561691470000},{"_id":"source/_posts/DataStructure/JavaScript集合(Set).md","hash":"9d5b8062a03b29ced42fd3ce45fd193842809970","modified":1560851291000},{"_id":"source/_posts/面向对象/面向对象第七天.md","hash":"956a6ea086675ca2dbde8bb8c84b4deeeff0c9bd","modified":1556260747000},{"_id":"source/_posts/面向对象/面向对象第三天.md","hash":"112a887351dcb1ab64677f2039efc1f05ca05b86","modified":1556260724000},{"_id":"source/_posts/面向对象/面向对象第二天.md","hash":"2e774a1e60955015613f41cae136ebab2e1e17e7","modified":1556260720000},{"_id":"source/_posts/面向对象/面向对象第五天.md","hash":"504f19628bfc87fb1feb6fd6100046f85d1787a0","modified":1556260733000},{"_id":"source/_posts/面向对象/面向对象第四天.md","hash":"192ec8e3792a0846473c95a6a53da0b31db5a5c3","modified":1556260729000},{"_id":"themes/hexo-theme-snippet/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1556178707000},{"_id":"source/_posts/面向对象/面向对象第六天.md","hash":"3ad0d07ccac3a06ad2fc5b69100ec66be9d50054","modified":1556260738000},{"_id":"themes/hexo-theme-snippet/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1556178707000},{"_id":"themes/hexo-theme-snippet/.git/logs/HEAD","hash":"bdd15721b0ea792a703bd11fd020e880f2384af2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8808d24b20e4969c1b687d17cf832e8fac147cc8","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE/feature_request.md","hash":"ca7ec6dc303459058d3117f33878beec538d3023","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/archive.ejs","hash":"cc21d71c87829f90686a3f6e5ac4d8665c871c25","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/article-meta.ejs","hash":"40f3cc7d88f72f58d320457a0e939e00605fcb1d","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/article.ejs","hash":"ecc6775b64c4b87a62fae4f8a2545105e40e7dfe","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/busuanzi.ejs","hash":"2c26222dc1c8da66135241fdc84d16ba66ae285c","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/copyright.ejs","hash":"ed137a7acee628cb070fe644028bb96a16796de3","modified":1556186129000},{"_id":"themes/hexo-theme-snippet/layout/_partial/footer.ejs","hash":"4a5b6fa1520442ac4edc2ec3d575a676b6717854","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/gallery.ejs","hash":"1b6b7859f395e10a3ecaa900de2d1312dc140def","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/head.ejs","hash":"1aea0e44f11d9f6f3e78f0da7dba0f35b910e6c3","modified":1556178764000},{"_id":"source/_posts/DataStructure/JavaScript栈(Stack).md","hash":"6b70ef254fa7a960ca9e0167b98f947a55395813","modified":1560497665000},{"_id":"source/_posts/面向对象/面向对象第一天.md","hash":"febe2fa282d550f0051eaa7b348d6f1de8d391ca","modified":1556260715000},{"_id":"themes/hexo-theme-snippet/layout/_partial/header.ejs","hash":"b08447c9201c196d132691f1a16c152e82cdcef4","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/nav.ejs","hash":"7fa65a2162a748f049fb910b5b0e46a5bcf57b3b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/pagination.ejs","hash":"2ec88a22fd29e7cc97ca2a508eee7d168e338969","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/reward.ejs","hash":"8ea91bdf01c946c76f4bd671768c8b930c7de446","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/sidebar.ejs","hash":"381b7af719c1ab3a94280309926c1205ce7b93a5","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/script.ejs","hash":"0ecdc42c6c1c2474d9e306de39323f089dddf7af","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/archive.ejs","hash":"ea6596d993ed1b74bd03eee06ab480931b8c2d9e","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/toc.ejs","hash":"7d86def87d0e7b7ab15400a23b0796f0da430e60","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/baidu_sitemap.ejs","hash":"dabeccfd4860dac2f6b883616f616c4c55fb22ba","modified":1556178764000},{"_id":"source/_posts/小程序/小程序云开发.md","hash":"862ff855799f6d135ef9ff21d2403282889c6afc","modified":1560754563000},{"_id":"themes/hexo-theme-snippet/layout/_widget/category.ejs","hash":"1c6881cd5b6b034ddecda6c85a3337d17a03e9ff","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/friends.ejs","hash":"43b0404d608db1a237b3cf17ec8df7b2d24f9533","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/notification.ejs","hash":"78eca9de4eec7c638c7b16863fb90e7182f7d80b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/search.ejs","hash":"dfbf723051f71099502c58a237bc484cebd5157d","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/social.ejs","hash":"f97313cdc1b495f7602e023b2ade5630acc4b667","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_widget/tagcloud.ejs","hash":"21746717296515c5b45a8fd5ef302ef8a9470bb2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/style.css","hash":"e763ff728431468d65920c004acbe637847b221c","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/assets/tagcanvas.min.js","hash":"a14280f4e924428ac0cdbac7635a7279cab1b6bf","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/.DS_Store","hash":"1cc0adea10264ac3f151a60695fc5fc8a77e323b","modified":1560248289000},{"_id":"themes/hexo-theme-snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/reward-wepay.jpg","hash":"2a56391f2b6282b49e724b72bf610b0dabf53742","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/timeline.gif","hash":"b7c7aac44e618df19626d882dc46db48a4aa3673","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/timeline-clock.gif","hash":"2bec1bf5efd948ab2e5942b6da8164faa41b62b2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/timeline-dot.gif","hash":"c85ef87be5b631c009e7c5737d33b61dfe580a4d","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/js/app.js","hash":"eca509fc5b45dcd1a0007c62f740529ca31a122f","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/js/search.js","hash":"7615b89a6604317860396569f0028b8ab9aaf95a","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/bootstrap.min.css","hash":"6527d8bf3e1e9368bab8c7b60f56bc01fa3afd68","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/assets/valine.min.js","hash":"d9d4a8f81f288b77b3d0a3866d004e2b5eb30038","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/img/avatar.jpg","hash":"b07718982d818afab1e08fc7443aaab47492a81a","modified":1560248089000},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/.DS_Store","hash":"a608d0a522102ae25c98f9d22159dfd6e30b7d8d","modified":1561102994000},{"_id":"themes/hexo-theme-snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/objects/pack/pack-152f049e7999287d0ddce7c4049bd0a72eb0511f.idx","hash":"261c6cf07f9115f7b253988a4dcc7f7ea068e353","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/refs/heads/master","hash":"624c13640c105624cda9af581d1554fdb091e75b","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/IE.ejs","hash":"567494a97ba2db7bb452294a9980b4d63b399ef0","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/seo.ejs","hash":"8cf5d4347c69c0999d756e06374039572c9ed975","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/style.ejs","hash":"ece8b1bb0f550ddb0e7ac179de54a8e5f06f49aa","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/title.ejs","hash":"1482f56c44221cbc0d28ba06e377f4b55cdaacc2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/baidu.ejs","hash":"eb4a75fb5ba9237d93430e727165d98ccda75a02","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/cnzz.ejs","hash":"8bfc514b178fafd81cc8181880afc5c9cbee02dc","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/google.ejs","hash":"91844d4521f97517ea9f169ee85b18c9d0d8cf17","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/index.ejs","hash":"6315abe9c31f4c4de719fa3cbfa2b1c6f294b0de","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/tencent.ejs","hash":"10b91084cda9067d037a5f31e48d4edcbaa0c751","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/changyan.ejs","hash":"202c94162ac2eeb0c93c8d2667c82b8705de6390","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/disqus.ejs","hash":"7b5e05154be0408be110893439bfa33e262245de","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/gitment.ejs","hash":"be5c261ae8a769747704a228aa35758120b814e1","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/livere.ejs","hash":"6333308ba24ae6f2a3e73f4cdc1b42e024d19910","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/gitalk.ejs","hash":"c556003dde298f4e8d3a75974996207876e83fa9","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/index.ejs","hash":"99dc8370fabb5302cc9810041e453302ecd98e82","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_highlight.less","hash":"c799cfa32c323c33a09569d326786874026fd1ef","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/valine.ejs","hash":"d339116cf24e76e7bc9f28e8a0a7c844ede2e506","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_mixins.less","hash":"e89dc55772b5ae6bfd4cac3b5c32bf9ce73ac805","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/uyan.ejs","hash":"2c2abe17f4f5c5ba1a9aaa948ef0a88d99f653f8","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_reward.less","hash":"100caed190893351a1ca7ed8e72bad57695d5f19","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_scrollbar.less","hash":"596ee6ada077f94a05d7c0168dddb20be16b85da","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_style.less","hash":"b64793abd9ee0f0670c3eafd15ab8ad633ebf1d2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_timeline.less","hash":"0bb3cef8b58621455d023c30d81fae204200d3bb","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/source/css/less/_variable.less","hash":"1d81728d61de486a7a746beb19275b2b4b65e304","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/1.png","hash":"d8e3c2262f4c1f246fe67c3e1b0e97811eac90df","modified":1561102897000},{"_id":"themes/hexo-theme-snippet/.git/logs/refs/heads/master","hash":"bdd15721b0ea792a703bd11fd020e880f2384af2","modified":1556178764000},{"_id":"themes/hexo-theme-snippet/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/4.gif","hash":"c1fb6b874f066ec2cf7fcd565051ec9d61896a79","modified":1561102905000},{"_id":"themes/hexo-theme-snippet/.git/logs/refs/remotes/origin/HEAD","hash":"bdd15721b0ea792a703bd11fd020e880f2384af2","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/5.gif","hash":"f51b9cc8cf02c104e695753f50229c6d2ba4ab91","modified":1561102909000},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/7.gif","hash":"59872dea97baee80e4333917f80c48627f888ed2","modified":1561102915000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/3.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1561102901000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/2.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1561102892000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/bubbleSort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1561097848000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/selectionSort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1561101708000},{"_id":"themes/hexo-theme-snippet/.git/objects/pack/pack-152f049e7999287d0ddce7c4049bd0a72eb0511f.pack","hash":"d49b32ce0359334ebb61cf012903055052617e5b","modified":1556178764000},{"_id":"source/_posts/排序算法和搜索算法/排序算法/6.gif","hash":"ef85422ba616c31be79468551be2091f0fede721","modified":1561102912000},{"_id":"source/_posts/React/React-router-dom.md","hash":"bd887d38749b9aea5d42e09a26a217fb62535f7e","modified":1561619432000},{"_id":"source/_posts/Chart/Chart.md","hash":"8368f97342595d465a94021fa9d1b83b64853289","modified":1562122337000},{"_id":"public/content.json","hash":"17b12ae5bdd6e9ae9973b95ba98cbd06658b946c","modified":1562226612087},{"_id":"public/2019/06/17/小程序/小程序云开发/index.html","hash":"763c180bde1f70ebe232eac0cafd530bb85ffbb6","modified":1562226612665},{"_id":"public/2019/06/14/DataStructure/JavaScript队列(Queue)/index.html","hash":"931eb0ad948deff1334b5ff4a4d6eecb55b0c390","modified":1562226612666},{"_id":"public/2019/06/14/DataStructure/JavaScript双端队列(Queue)/index.html","hash":"b056798e2aa852727fc840343a0906889d75c054","modified":1562226613305},{"_id":"public/2017/02/25/事件冒泡与捕获/index.html","hash":"8657b17b6576199c9b6399445a08e894d7fafaf9","modified":1562226613306},{"_id":"public/2017/02/23/html5第一天/index.html","hash":"503eadab0221ae4a4ed83bcb0a609ecdfdec352f","modified":1562226613316},{"_id":"public/2017/02/21/html5表单/index.html","hash":"8d043e2190b9938ebda6973989fc153a1aa2c9e7","modified":1562226613316},{"_id":"public/2017/02/21/angular路由使用/index.html","hash":"955350b9b61701397a7c26f6ab2b4f898b780f26","modified":1562226613317},{"_id":"public/2019/06/21/排序算法和搜索算法/排序算法/index.html","hash":"d2682b36a50c537d482fbb1b76200df5a3ce96f5","modified":1562226613317},{"_id":"public/2019/06/18/DataStructure/JavaScript字典和散列表/index.html","hash":"afd0dec466e15a1b7bf609b6e818b21de3fef279","modified":1562226613317},{"_id":"public/2019/06/18/DataStructure/JavaScript集合(Set)/index.html","hash":"d1b2dc3f8e8a03fd7d11fe5a5ab49a3a33483403","modified":1562226613317},{"_id":"public/2019/06/06/Vue/vuex/index.html","hash":"f87fce499eba7e1767c563273f26ed700d594449","modified":1562226613317},{"_id":"public/2019/06/14/DataStructure/JavaScript栈(Stack)/index.html","hash":"cc34f393709c441b991a910445ad7eb10676eacb","modified":1562226613317},{"_id":"public/2019/06/06/Mongodb/Mongodb/index.html","hash":"6f809818fc9ad28e59b4058a388442023040d4a5","modified":1562226613317},{"_id":"public/2019/04/25/面向对象/面向对象第一天/index.html","hash":"4ab40bb6ebcfd83d938322b01744f9326c36905f","modified":1562226613317},{"_id":"public/2019/04/29/TypeScript/TypeScript/index.html","hash":"ec0c0d0c95234f92c2588e23bc165e3011940f58","modified":1562226613317},{"_id":"public/2017/03/04/seajs  and requirejs/index.html","hash":"38df861599f215162d5402a42a0c900f9e7a98f2","modified":1562226613317},{"_id":"public/2017/02/27/css3/index.html","hash":"8c16c5991fff409fb243c7d4e3f54e3f336934cc","modified":1562226613317},{"_id":"public/2019/07/03/Chart/Chart/index.html","hash":"0378f0d55fa83fd1f637ec82b194385fe7b04891","modified":1562226613337},{"_id":"public/2019/06/27/React/React-router-dom/index.html","hash":"4da0fed2cc57305742571a38e4e2cec6fe64ffc3","modified":1562226613338},{"_id":"public/2017/02/18/npm browser gulp使用/index.html","hash":"86d1b9c5a0c5fcb9633303bd3a4e190257bea2af","modified":1562226613379},{"_id":"public/2017/02/12/正则表达式/index.html","hash":"6cc5a8e53c527f9ba94070175a1c4591efc84839","modified":1562226613379},{"_id":"public/2017/02/10/less使用/index.html","hash":"c2535d7d2562eb648f818aac0fbd5797f505109d","modified":1562226613380},{"_id":"public/2017/01/09/canvas第三天/index.html","hash":"6fba2469d78bbc3cc96c570076f296ea612644db","modified":1562226613380},{"_id":"public/2017/01/06/art-template的模板引擎/index.html","hash":"6867a14c813b2c9efdd341521bb89b27b7f07ed9","modified":1562226613380},{"_id":"public/2016/12/23/面向对象/面向对象第五天/index.html","hash":"76152286634c0591446d4f71d2a0bada255c1f89","modified":1562226613380},{"_id":"public/2016/12/21/面向对象/面向对象第三天/index.html","hash":"1bf28f139b1164f27656a1675538aabbd2479e51","modified":1562226613380},{"_id":"public/2016/11/28/HTML5总结/index.html","hash":"f08b733918ea2edbd126997fe8a2c5fbe8d64263","modified":1562226613380},{"_id":"public/2016/12/26/字符串方法/index.html","hash":"18f232eb5dbdbea4446f1cc56523f964cbb37033","modified":1562226613380},{"_id":"public/2017/02/21/html5标签兼容性/index.html","hash":"ec77534380ca5f7c4bdc03aec616ab56802680e8","modified":1562226613380},{"_id":"public/categories/数据库/index.html","hash":"8896fff114d6ad0ca71cc2e6b1203679bb37b6bb","modified":1562226613380},{"_id":"public/categories/算法/index.html","hash":"625f98a5f0080a63d11b3f6e0d3afb277474e69f","modified":1562226613380},{"_id":"public/categories/小程序云开发/index.html","hash":"ed31a7935091c2508929d8c8506796a4354928a3","modified":1562226613381},{"_id":"public/tags/模板引擎/index.html","hash":"86aca9f3f72bcde2b82dcf60ae086b86ce4c2961","modified":1562226613381},{"_id":"public/tags/canvas/index.html","hash":"7bdecee934a6afcbe86649bf123f61db28d5c577","modified":1562226613381},{"_id":"public/tags/工具/index.html","hash":"a9a1653bc9a6b4be9ca231c1ad5078fa2ee0bc54","modified":1562226613381},{"_id":"public/tags/兼容性/index.html","hash":"bc2278ae426cb715f6e8266dd9f9286c996d813f","modified":1562226613381},{"_id":"public/tags/html/index.html","hash":"15d6389c0d73915ecf5c72b9ac35f76f94909291","modified":1562226613381},{"_id":"public/tags/css预处理器/index.html","hash":"1a8c6816a24e8e40fd811a49855285b0b8ee0fcf","modified":1562226613381},{"_id":"public/tags/模块化开发/index.html","hash":"2cb5e49a096270f2138eafc15e72281162924a63","modified":1562226613381},{"_id":"public/tags/javaScript/index.html","hash":"159f5cc08e41e874e750d2f2f5480e81c9969766","modified":1562226613381},{"_id":"public/tags/Mongodb/index.html","hash":"e97a7a8f842e6f580624f503555533a596bdaf6a","modified":1562226613381},{"_id":"public/tags/Vuex/index.html","hash":"d7e8c2f21f200a0a999deb31e1b56bd8922abe7f","modified":1562226613382},{"_id":"public/tags/排序算法/index.html","hash":"d37a3ff71cb15069301d818d0e363f79f54ce9f5","modified":1562226613382},{"_id":"public/tags/css/index.html","hash":"ef311ec4ffd686d252ed93e10c43fe612ff374f1","modified":1562226613382},{"_id":"public/tags/TypeScript/index.html","hash":"a2713de49d59269950713e08ab14f2bee2ff5abf","modified":1562226613382},{"_id":"public/tags/html5/index.html","hash":"7869e7dc8bb7df2eb788359f15902101883a9976","modified":1562226613382},{"_id":"public/2017/01/09/canvas第二天/index.html","hash":"c08cf82efbae938bbcc595a4af5a71547d1abbee","modified":1562226613382},{"_id":"public/2017/01/06/canvas第一天/index.html","hash":"232355357313c930360c354092e82184a4170efc","modified":1562226613382},{"_id":"public/2016/12/26/面向对象/面向对象第七天/index.html","hash":"c07845f05c53a63aeb37b256ebee2470356b8988","modified":1562226613382},{"_id":"public/2017/02/18/git/index.html","hash":"24d1d59cb62f2cf3ec2b86c45d37a83a9dbde197","modified":1562226613382},{"_id":"public/2016/12/24/面向对象/面向对象第六天/index.html","hash":"ebe659c1df4c7a5d59f56f9f1ed096bc848a3966","modified":1562226613382},{"_id":"public/2016/12/22/面向对象/面向对象第二天/index.html","hash":"fb41d96cdd1bed6390efd441df0a6b31d267ae44","modified":1562226613382},{"_id":"public/2016/11/28/html5第二天/index.html","hash":"4a3b11ee0ba9f75dcc4130719038998221b2fc19","modified":1562226613382},{"_id":"public/2016/12/20/面向对象/面向对象第四天/index.html","hash":"bacda626f77e964663160734cbbe82712cf0ebaf","modified":1562226613382},{"_id":"public/archives/index.html","hash":"96e96acf386e82d0730bfcf48c231cdb917614ab","modified":1562226613382},{"_id":"public/archives/page/4/index.html","hash":"96e96acf386e82d0730bfcf48c231cdb917614ab","modified":1562226613382},{"_id":"public/archives/page/2/index.html","hash":"96e96acf386e82d0730bfcf48c231cdb917614ab","modified":1562226613382},{"_id":"public/archives/2016/index.html","hash":"f84cd39d43714d8b6dc393926ffab42c557c2f9a","modified":1562226613382},{"_id":"public/archives/2016/11/index.html","hash":"56d0daa1d575160882683888df116ad1135e8410","modified":1562226613382},{"_id":"public/archives/2016/12/index.html","hash":"88fa306549e00b599674340b5708fbf12f16ca99","modified":1562226613383},{"_id":"public/archives/2017/01/index.html","hash":"46a497fa21fc57ee67d8ed07c7821cbefe8c1c5f","modified":1562226613383},{"_id":"public/archives/2017/index.html","hash":"e600f63d7fd34e7e8280ebb292c12f4afef2f82e","modified":1562226613383},{"_id":"public/archives/2017/02/index.html","hash":"ef755a316e1540b5bd8baf2d0a7d8687971fa1ea","modified":1562226613383},{"_id":"public/archives/2017/03/index.html","hash":"19da09af4894ce5ff5721a91b72b5401262c2a21","modified":1562226613383},{"_id":"public/archives/2019/index.html","hash":"15e7085403af1514dc1be96b64b3f02141f8e3bf","modified":1562226613383},{"_id":"public/archives/2019/page/2/index.html","hash":"15e7085403af1514dc1be96b64b3f02141f8e3bf","modified":1562226613383},{"_id":"public/archives/2019/04/index.html","hash":"a327c91fa4a62ee5a20103da1f1da4542dd45c9f","modified":1562226613383},{"_id":"public/archives/2019/06/index.html","hash":"4af26d6fc9a970d8412bed9d4c503b9c497c94cf","modified":1562226613383},{"_id":"public/categories/前端/index.html","hash":"7aacba50b9a7317c88ef115468e65538a15093ba","modified":1562226613383},{"_id":"public/categories/前端/page/2/index.html","hash":"d58e432a282a69f96393f8ae831ebb3b479f6152","modified":1562226613383},{"_id":"public/categories/前端/page/3/index.html","hash":"bc290a1784610738f387110924acd60536ebd878","modified":1562226613383},{"_id":"public/categories/数据结构/index.html","hash":"2382e1143c90e348258c02292cb2e45cbc6af4cf","modified":1562226613383},{"_id":"public/index.html","hash":"399ff5017a11a08f3af76f5f8f9b58989be9d6e9","modified":1562226613383},{"_id":"public/page/2/index.html","hash":"a1fbd010294a64534dad62fd98f3cbaa2f2821a7","modified":1562226613383},{"_id":"public/page/3/index.html","hash":"02ad60e07c10bad2aa57e201059370a4d7c1c4a9","modified":1562226613383},{"_id":"public/page/4/index.html","hash":"edb73170675d8882e0732cc23cbcc61b9ec9eb8e","modified":1562226613383},{"_id":"public/tags/JavaScript/index.html","hash":"80ca661d0e65edcbf80a7dddc74b1735b5875e4e","modified":1562226613383},{"_id":"public/tags/面向对象/index.html","hash":"4e6386489974bff16ade98e37893842fbe542338","modified":1562226613383},{"_id":"public/archives/page/3/index.html","hash":"96e96acf386e82d0730bfcf48c231cdb917614ab","modified":1562226613383},{"_id":"public/archives/2017/page/2/index.html","hash":"e600f63d7fd34e7e8280ebb292c12f4afef2f82e","modified":1562226613383},{"_id":"public/categories/React/index.html","hash":"12129d074bb9aa3f03119c20dd5fcb5826ca9e61","modified":1562226613385},{"_id":"public/categories/Chart-js/index.html","hash":"6d34788ab16f64fd923e6b1e4047dc559ffce3e3","modified":1562226613385},{"_id":"public/tags/React路由/index.html","hash":"e8f186152af3aede8c3164c5152c72c887162608","modified":1562226613386},{"_id":"public/archives/2019/07/index.html","hash":"01f8798b80ad182e8da4d2b93c2f766391649bc9","modified":1562226613386}],"Category":[{"name":"前端","_id":"cjxe9u0gl00037xuqo950mday"},{"name":"数据结构","_id":"cjxe9u0if001w7xuqecrtjjuz"},{"name":"数据库","_id":"cjxe9u0il00287xuqd11aclmo"},{"name":"算法","_id":"cjxe9u0ip002g7xuqhsp68z5d"},{"name":"小程序云开发","_id":"cjxe9u0jh00397xuq0wxyg4dr"},{"name":"React","_id":"cjxfi9ja40001ugs67xm3t8cm"},{"name":"Chart.js","_id":"cjxmnblku00011ss610oyfrpb"}],"Data":[],"Page":[],"Post":[{"title":"angular路由使用","_content":"## angular路由使用\n\n#### 安装angular-route\n- npm install angular-route --save\n#### 引用模块\n- `<script src=\"node_modules/angular-route/angular-route.js\"></script>`\n#### 创建模块\n- `var app = angular.module('myApp',['ngRoute']);`\n#### 使用规则\n\t//有一个参数：类似于controller的第二个参数 \n\n\t//需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的\n\n\tapp.config(['$routeProvider',function($routeProvider){\n\n\t// 路由参数：\n\n\t// when方法，第一个参数是当前url中锚点值\n\n    // 第二个参数是一个object对象 并且可以通过.实现链式编程  从而实现多个筛选（不过一般使用路由参数动态的实现筛选）\n\n\t// 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML\n\n\t//路由参数'/students/:name?'这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则\n\n\t\t $routeProvider.when('/students/:name?',{\n\n\t\t\t\t//模板 template/templateUrl\n\n                template:'<p>{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}</p>',\n\n                // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型\n\n                controller:'stuController'\n\n\t\t\t\t//otherwise 当上面的when都没有匹配的时候  就走这里面  需要一个参数 是一个对象\n\n            }).otherwise({\n\n\t\t\t\t//当前面所有的when都不满足时  就会跳转到这个指定的锚点值页面\n\n\t\t\t\tredirectTo:'/students/'\n\n\t\t\t\t})\n\n\t\t //创建控制器\n\n\t\t //控制器暴露的数据能够在template中使用\n\n\t\t //$routeParams是一个对象 获取url中想要匹配的值 如 {name:\"zhangsan\"}\n\n\t\t //$route监视url参数的变化 \n\n\t\tapp.controller('stuController',['$scope','$routeParams'，'$route',function($scope,$routeParams,$route){\n\n\t\t\t\t$scope.students = {\n\n            \tzhangsan: {id: 0, name: \"张三\", grade: \"一年级\"},\n\n            \tlisi: {id: 1, name: \"李四\", grade: \"一年级\"},\n\n            \txiaobai: {id: 2, name: \"小白\", grade: \"一年级\"},\n\n            \twangwu: {id: 3, name: \"王五\", grade: \"一年级\"},\n\n            \tzhaosi: {id: 4, name: \"赵四\", grade: \"一年级\"},\n\n        \t\t}\n\n\t\t\t//动态暴露数据 为了让路由中的模板使用\n\n\t\t$scope.nowStu = $scope.students[$routeParams.name];\n\n\t\t\t//当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示\n\n\t\t\tif($scope.nowStu){\n\n\t\t\t\t//$scope.nowStu=$scope.students['lisi'];\n\n\t\t\t\t//$route提供一个方法 默认会跳转到lish的信息\n\n\t\t\t\t//updateParams他只能改'/students/:name?'中name的值\n\n\t\t\t\t$route.updateParams({name:'lisi'});\n\n\t\t\t\t//如果要改urL整个的值 需要使用$location.url('/sunyu/') 但是注意$location.url获取的锚点值不包括#\n\n\t\t\t\t$location.url('/sunyu/')；\n\t\t\t}\n\t\t}]);","source":"_posts/angular路由使用.md","raw":"---\ntitle: angular路由使用\n---\n## angular路由使用\n\n#### 安装angular-route\n- npm install angular-route --save\n#### 引用模块\n- `<script src=\"node_modules/angular-route/angular-route.js\"></script>`\n#### 创建模块\n- `var app = angular.module('myApp',['ngRoute']);`\n#### 使用规则\n\t//有一个参数：类似于controller的第二个参数 \n\n\t//需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的\n\n\tapp.config(['$routeProvider',function($routeProvider){\n\n\t// 路由参数：\n\n\t// when方法，第一个参数是当前url中锚点值\n\n    // 第二个参数是一个object对象 并且可以通过.实现链式编程  从而实现多个筛选（不过一般使用路由参数动态的实现筛选）\n\n\t// 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML\n\n\t//路由参数'/students/:name?'这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则\n\n\t\t $routeProvider.when('/students/:name?',{\n\n\t\t\t\t//模板 template/templateUrl\n\n                template:'<p>{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}</p>',\n\n                // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型\n\n                controller:'stuController'\n\n\t\t\t\t//otherwise 当上面的when都没有匹配的时候  就走这里面  需要一个参数 是一个对象\n\n            }).otherwise({\n\n\t\t\t\t//当前面所有的when都不满足时  就会跳转到这个指定的锚点值页面\n\n\t\t\t\tredirectTo:'/students/'\n\n\t\t\t\t})\n\n\t\t //创建控制器\n\n\t\t //控制器暴露的数据能够在template中使用\n\n\t\t //$routeParams是一个对象 获取url中想要匹配的值 如 {name:\"zhangsan\"}\n\n\t\t //$route监视url参数的变化 \n\n\t\tapp.controller('stuController',['$scope','$routeParams'，'$route',function($scope,$routeParams,$route){\n\n\t\t\t\t$scope.students = {\n\n            \tzhangsan: {id: 0, name: \"张三\", grade: \"一年级\"},\n\n            \tlisi: {id: 1, name: \"李四\", grade: \"一年级\"},\n\n            \txiaobai: {id: 2, name: \"小白\", grade: \"一年级\"},\n\n            \twangwu: {id: 3, name: \"王五\", grade: \"一年级\"},\n\n            \tzhaosi: {id: 4, name: \"赵四\", grade: \"一年级\"},\n\n        \t\t}\n\n\t\t\t//动态暴露数据 为了让路由中的模板使用\n\n\t\t$scope.nowStu = $scope.students[$routeParams.name];\n\n\t\t\t//当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示\n\n\t\t\tif($scope.nowStu){\n\n\t\t\t\t//$scope.nowStu=$scope.students['lisi'];\n\n\t\t\t\t//$route提供一个方法 默认会跳转到lish的信息\n\n\t\t\t\t//updateParams他只能改'/students/:name?'中name的值\n\n\t\t\t\t$route.updateParams({name:'lisi'});\n\n\t\t\t\t//如果要改urL整个的值 需要使用$location.url('/sunyu/') 但是注意$location.url获取的锚点值不包括#\n\n\t\t\t\t$location.url('/sunyu/')；\n\t\t\t}\n\t\t}]);","slug":"angular路由使用","published":1,"date":"2017-02-21T08:00:45.000Z","updated":"2019-04-26T06:21:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gd00007xuqfd5hzgtt","content":"<h2 id=\"angular路由使用\"><a href=\"#angular路由使用\" class=\"headerlink\" title=\"angular路由使用\"></a>angular路由使用</h2><h4 id=\"安装angular-route\"><a href=\"#安装angular-route\" class=\"headerlink\" title=\"安装angular-route\"></a>安装angular-route</h4><ul>\n<li>npm install angular-route –save<h4 id=\"引用模块\"><a href=\"#引用模块\" class=\"headerlink\" title=\"引用模块\"></a>引用模块</h4></li>\n<li><code>&lt;script src=&quot;node_modules/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;</code><h4 id=\"创建模块\"><a href=\"#创建模块\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h4></li>\n<li><p><code>var app = angular.module(&#39;myApp&#39;,[&#39;ngRoute&#39;]);</code></p>\n<h4 id=\"使用规则\"><a href=\"#使用规则\" class=\"headerlink\" title=\"使用规则\"></a>使用规则</h4><p>  //有一个参数：类似于controller的第二个参数 </p>\n<p>  //需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的</p>\n<p>  app.config([‘$routeProvider’,function($routeProvider){</p>\n<p>  // 路由参数：</p>\n<p>  // when方法，第一个参数是当前url中锚点值</p>\n<p>  // 第二个参数是一个object对象 并且可以通过.实现链式编程  从而实现多个筛选（不过一般使用路由参数动态的实现筛选）</p>\n<p>  // 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML</p>\n<p>  //路由参数’/students/:name?’这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则</p>\n<pre><code> $routeProvider.when(&apos;/students/:name?&apos;,{\n\n        //模板 template/templateUrl\n\n        template:&apos;&lt;p&gt;{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}&lt;/p&gt;&apos;,\n\n        // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型\n\n        controller:&apos;stuController&apos;\n\n        //otherwise 当上面的when都没有匹配的时候  就走这里面  需要一个参数 是一个对象\n\n    }).otherwise({\n\n        //当前面所有的when都不满足时  就会跳转到这个指定的锚点值页面\n\n        redirectTo:&apos;/students/&apos;\n\n        })\n\n //创建控制器\n\n //控制器暴露的数据能够在template中使用\n\n //$routeParams是一个对象 获取url中想要匹配的值 如 {name:&quot;zhangsan&quot;}\n\n //$route监视url参数的变化 \n\napp.controller(&apos;stuController&apos;,[&apos;$scope&apos;,&apos;$routeParams&apos;，&apos;$route&apos;,function($scope,$routeParams,$route){\n\n        $scope.students = {\n\n        zhangsan: {id: 0, name: &quot;张三&quot;, grade: &quot;一年级&quot;},\n\n        lisi: {id: 1, name: &quot;李四&quot;, grade: &quot;一年级&quot;},\n\n        xiaobai: {id: 2, name: &quot;小白&quot;, grade: &quot;一年级&quot;},\n\n        wangwu: {id: 3, name: &quot;王五&quot;, grade: &quot;一年级&quot;},\n\n        zhaosi: {id: 4, name: &quot;赵四&quot;, grade: &quot;一年级&quot;},\n\n        }\n\n    //动态暴露数据 为了让路由中的模板使用\n\n$scope.nowStu = $scope.students[$routeParams.name];\n\n    //当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示\n\n    if($scope.nowStu){\n\n        //$scope.nowStu=$scope.students[&apos;lisi&apos;];\n\n        //$route提供一个方法 默认会跳转到lish的信息\n\n        //updateParams他只能改&apos;/students/:name?&apos;中name的值\n\n        $route.updateParams({name:&apos;lisi&apos;});\n\n        //如果要改urL整个的值 需要使用$location.url(&apos;/sunyu/&apos;) 但是注意$location.url获取的锚点值不包括#\n\n        $location.url(&apos;/sunyu/&apos;)；\n    }\n}]);\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"angular路由使用\"><a href=\"#angular路由使用\" class=\"headerlink\" title=\"angular路由使用\"></a>angular路由使用</h2><h4 id=\"安装angular-route\"><a href=\"#安装angular-route\" class=\"headerlink\" title=\"安装angular-route\"></a>安装angular-route</h4><ul>\n<li>npm install angular-route –save<h4 id=\"引用模块\"><a href=\"#引用模块\" class=\"headerlink\" title=\"引用模块\"></a>引用模块</h4></li>\n<li><code>&lt;script src=&quot;node_modules/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;</code><h4 id=\"创建模块\"><a href=\"#创建模块\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h4></li>\n<li><p><code>var app = angular.module(&#39;myApp&#39;,[&#39;ngRoute&#39;]);</code></p>\n<h4 id=\"使用规则\"><a href=\"#使用规则\" class=\"headerlink\" title=\"使用规则\"></a>使用规则</h4><p>  //有一个参数：类似于controller的第二个参数 </p>\n<p>  //需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的</p>\n<p>  app.config([‘$routeProvider’,function($routeProvider){</p>\n<p>  // 路由参数：</p>\n<p>  // when方法，第一个参数是当前url中锚点值</p>\n<p>  // 第二个参数是一个object对象 并且可以通过.实现链式编程  从而实现多个筛选（不过一般使用路由参数动态的实现筛选）</p>\n<p>  // 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML</p>\n<p>  //路由参数’/students/:name?’这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则</p>\n<pre><code> $routeProvider.when(&apos;/students/:name?&apos;,{\n\n        //模板 template/templateUrl\n\n        template:&apos;&lt;p&gt;{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}&lt;/p&gt;&apos;,\n\n        // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型\n\n        controller:&apos;stuController&apos;\n\n        //otherwise 当上面的when都没有匹配的时候  就走这里面  需要一个参数 是一个对象\n\n    }).otherwise({\n\n        //当前面所有的when都不满足时  就会跳转到这个指定的锚点值页面\n\n        redirectTo:&apos;/students/&apos;\n\n        })\n\n //创建控制器\n\n //控制器暴露的数据能够在template中使用\n\n //$routeParams是一个对象 获取url中想要匹配的值 如 {name:&quot;zhangsan&quot;}\n\n //$route监视url参数的变化 \n\napp.controller(&apos;stuController&apos;,[&apos;$scope&apos;,&apos;$routeParams&apos;，&apos;$route&apos;,function($scope,$routeParams,$route){\n\n        $scope.students = {\n\n        zhangsan: {id: 0, name: &quot;张三&quot;, grade: &quot;一年级&quot;},\n\n        lisi: {id: 1, name: &quot;李四&quot;, grade: &quot;一年级&quot;},\n\n        xiaobai: {id: 2, name: &quot;小白&quot;, grade: &quot;一年级&quot;},\n\n        wangwu: {id: 3, name: &quot;王五&quot;, grade: &quot;一年级&quot;},\n\n        zhaosi: {id: 4, name: &quot;赵四&quot;, grade: &quot;一年级&quot;},\n\n        }\n\n    //动态暴露数据 为了让路由中的模板使用\n\n$scope.nowStu = $scope.students[$routeParams.name];\n\n    //当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示\n\n    if($scope.nowStu){\n\n        //$scope.nowStu=$scope.students[&apos;lisi&apos;];\n\n        //$route提供一个方法 默认会跳转到lish的信息\n\n        //updateParams他只能改&apos;/students/:name?&apos;中name的值\n\n        $route.updateParams({name:&apos;lisi&apos;});\n\n        //如果要改urL整个的值 需要使用$location.url(&apos;/sunyu/&apos;) 但是注意$location.url获取的锚点值不包括#\n\n        $location.url(&apos;/sunyu/&apos;)；\n    }\n}]);\n</code></pre></li>\n</ul>\n"},{"title":"art-template模板引擎","_content":"\n#### jQuery遍历对象\n\t$.each(data,function(i,e){e.attr})；\n\tattr就是对象的属性。\n\t例如：$.each(data,function(i,e){\n\t\tvar date = new Date(Number(e.time+'000')).toLocaleString();\n\t\tinfomation += '<ul><li>'+ e.desc +'</li><li>'+ date +'</li></ul>';\n\t})\n#### artTemplate方法一\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>basic-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\n\t<body>\n\t<div id=\"content\"></div>\n\t<script id=\"test\" type=\"text/html\">\n\t{{if isAdmin}}\n\n\t<h1>{{title}}</h1>\n\t<ul>\n    {{each list as value i}}\n        <li>索引 {{i + 1}} ：{{value}}</li>\n    {{/each}}\n\t</ul>\n\n\t{{/if}}\n\t</script>\n\n\t<script>\n\tvar data = {\n\t\ttitle: '基本例子',\n\tisAdmin: true,\n\tlist: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = template('test', data);\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n#### artTemplate方法二\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>compile-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\t\n\t<body>\n\t<h1>在javascript中存放模板</h1>\n\t<div id=\"content\"></div>\n\t<script>\n\tvar source = '<ul>'\n\t+    '{{each list as value i}}'\n\t+        '<li>索引 {{i + 1}} ：{{value}}</li>'\n\t+    '{{/each}}'\n\t+ '</ul>';\n\t\n\tvar render = template.compile(source);\n\tvar data = {\n\t    list: ['摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = render(data);\n\t\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n\n#### artTemplate方法三-嵌入子模板\n\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>include-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\t\n\t<body>\n\t<div id=\"content\"></div>\n\t<script id=\"test\" type=\"text/html\">\n\t<h1>{{title}}</h1>\n\t{{include 'list'}}\n\t</script>\n\t<script id=\"list\" type=\"text/html\">\n\t<ul>\n\t    {{each list as value i}}\n\t        <li>索引 {{i + 1}} ：{{value}}</li>\n\t    {{/each}}\n\t</ul>\n\t</script>\n\t\n\t<script>\n\tvar data = {\n\t\ttitle: '嵌入子模板',\n\t\tlist: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = template('test', data);\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n\n\n#### 注意点\n\t{{each list as value i}}\n\tlist可以为对象或者是数组，value为值，i为索引。\n#### 把获取到的时间转换为现在的时间\n\tvar data = new Date(Number(e.time+\"000\")).toLocaleString();\n\t因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。\n\n\n\n","source":"_posts/art-template的模板引擎.md","raw":"---\ntitle: art-template模板引擎\ncategories: ['前端']\ntags: ['模板引擎']\n---\n\n#### jQuery遍历对象\n\t$.each(data,function(i,e){e.attr})；\n\tattr就是对象的属性。\n\t例如：$.each(data,function(i,e){\n\t\tvar date = new Date(Number(e.time+'000')).toLocaleString();\n\t\tinfomation += '<ul><li>'+ e.desc +'</li><li>'+ date +'</li></ul>';\n\t})\n#### artTemplate方法一\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>basic-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\n\t<body>\n\t<div id=\"content\"></div>\n\t<script id=\"test\" type=\"text/html\">\n\t{{if isAdmin}}\n\n\t<h1>{{title}}</h1>\n\t<ul>\n    {{each list as value i}}\n        <li>索引 {{i + 1}} ：{{value}}</li>\n    {{/each}}\n\t</ul>\n\n\t{{/if}}\n\t</script>\n\n\t<script>\n\tvar data = {\n\t\ttitle: '基本例子',\n\tisAdmin: true,\n\tlist: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = template('test', data);\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n#### artTemplate方法二\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>compile-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\t\n\t<body>\n\t<h1>在javascript中存放模板</h1>\n\t<div id=\"content\"></div>\n\t<script>\n\tvar source = '<ul>'\n\t+    '{{each list as value i}}'\n\t+        '<li>索引 {{i + 1}} ：{{value}}</li>'\n\t+    '{{/each}}'\n\t+ '</ul>';\n\t\n\tvar render = template.compile(source);\n\tvar data = {\n\t    list: ['摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = render(data);\n\t\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n\n#### artTemplate方法三-嵌入子模板\n\n\t<!DOCTYPE HTML>\n\t<html>\n\t<head>\n\t<meta charset=\"UTF-8\">\n\t<title>include-demo</title>\n\t<script src=\"../dist/template.js\"></script>\n\t</head>\n\t\n\t<body>\n\t<div id=\"content\"></div>\n\t<script id=\"test\" type=\"text/html\">\n\t<h1>{{title}}</h1>\n\t{{include 'list'}}\n\t</script>\n\t<script id=\"list\" type=\"text/html\">\n\t<ul>\n\t    {{each list as value i}}\n\t        <li>索引 {{i + 1}} ：{{value}}</li>\n\t    {{/each}}\n\t</ul>\n\t</script>\n\t\n\t<script>\n\tvar data = {\n\t\ttitle: '嵌入子模板',\n\t\tlist: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']\n\t};\n\tvar html = template('test', data);\n\tdocument.getElementById('content').innerHTML = html;\n\t</script>\n\t</body>\n\t</html>\n\n\n#### 注意点\n\t{{each list as value i}}\n\tlist可以为对象或者是数组，value为值，i为索引。\n#### 把获取到的时间转换为现在的时间\n\tvar data = new Date(Number(e.time+\"000\")).toLocaleString();\n\t因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。\n\n\n\n","slug":"art-template的模板引擎","published":1,"date":"2017-01-06T00:46:07.000Z","updated":"2019-04-26T06:05:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gi00017xuq9yl0jern","content":"<h4 id=\"jQuery遍历对象\"><a href=\"#jQuery遍历对象\" class=\"headerlink\" title=\"jQuery遍历对象\"></a>jQuery遍历对象</h4><pre><code>$.each(data,function(i,e){e.attr})；\nattr就是对象的属性。\n例如：$.each(data,function(i,e){\n    var date = new Date(Number(e.time+&apos;000&apos;)).toLocaleString();\n    infomation += &apos;&lt;ul&gt;&lt;li&gt;&apos;+ e.desc +&apos;&lt;/li&gt;&lt;li&gt;&apos;+ date +&apos;&lt;/li&gt;&lt;/ul&gt;&apos;;\n})\n</code></pre><h4 id=\"artTemplate方法一\"><a href=\"#artTemplate方法一\" class=\"headerlink\" title=\"artTemplate方法一\"></a>artTemplate方法一</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;basic-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;\n{{if isAdmin}}\n\n&lt;h1&gt;{{title}}&lt;/h1&gt;\n&lt;ul&gt;\n{{each list as value i}}\n    &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;\n{{/each}}\n&lt;/ul&gt;\n\n{{/if}}\n&lt;/script&gt;\n\n&lt;script&gt;\nvar data = {\n    title: &apos;基本例子&apos;,\nisAdmin: true,\nlist: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = template(&apos;test&apos;, data);\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"artTemplate方法二\"><a href=\"#artTemplate方法二\" class=\"headerlink\" title=\"artTemplate方法二\"></a>artTemplate方法二</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;compile-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;h1&gt;在javascript中存放模板&lt;/h1&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\nvar source = &apos;&lt;ul&gt;&apos;\n+    &apos;{{each list as value i}}&apos;\n+        &apos;&lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;&apos;\n+    &apos;{{/each}}&apos;\n+ &apos;&lt;/ul&gt;&apos;;\n\nvar render = template.compile(source);\nvar data = {\n    list: [&apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = render(data);\n\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"artTemplate方法三-嵌入子模板\"><a href=\"#artTemplate方法三-嵌入子模板\" class=\"headerlink\" title=\"artTemplate方法三-嵌入子模板\"></a>artTemplate方法三-嵌入子模板</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;include-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;\n&lt;h1&gt;{{title}}&lt;/h1&gt;\n{{include 'list'}}\n&lt;/script&gt;\n&lt;script id=&quot;list&quot; type=&quot;text/html&quot;&gt;\n&lt;ul&gt;\n    {{each list as value i}}\n        &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;\n    {{/each}}\n&lt;/ul&gt;\n&lt;/script&gt;\n\n&lt;script&gt;\nvar data = {\n    title: &apos;嵌入子模板&apos;,\n    list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = template(&apos;test&apos;, data);\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><pre><code>{{each list as value i}}\nlist可以为对象或者是数组，value为值，i为索引。\n</code></pre><h4 id=\"把获取到的时间转换为现在的时间\"><a href=\"#把获取到的时间转换为现在的时间\" class=\"headerlink\" title=\"把获取到的时间转换为现在的时间\"></a>把获取到的时间转换为现在的时间</h4><pre><code>var data = new Date(Number(e.time+&quot;000&quot;)).toLocaleString();\n因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"jQuery遍历对象\"><a href=\"#jQuery遍历对象\" class=\"headerlink\" title=\"jQuery遍历对象\"></a>jQuery遍历对象</h4><pre><code>$.each(data,function(i,e){e.attr})；\nattr就是对象的属性。\n例如：$.each(data,function(i,e){\n    var date = new Date(Number(e.time+&apos;000&apos;)).toLocaleString();\n    infomation += &apos;&lt;ul&gt;&lt;li&gt;&apos;+ e.desc +&apos;&lt;/li&gt;&lt;li&gt;&apos;+ date +&apos;&lt;/li&gt;&lt;/ul&gt;&apos;;\n})\n</code></pre><h4 id=\"artTemplate方法一\"><a href=\"#artTemplate方法一\" class=\"headerlink\" title=\"artTemplate方法一\"></a>artTemplate方法一</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;basic-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;\n{{if isAdmin}}\n\n&lt;h1&gt;{{title}}&lt;/h1&gt;\n&lt;ul&gt;\n{{each list as value i}}\n    &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;\n{{/each}}\n&lt;/ul&gt;\n\n{{/if}}\n&lt;/script&gt;\n\n&lt;script&gt;\nvar data = {\n    title: &apos;基本例子&apos;,\nisAdmin: true,\nlist: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = template(&apos;test&apos;, data);\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"artTemplate方法二\"><a href=\"#artTemplate方法二\" class=\"headerlink\" title=\"artTemplate方法二\"></a>artTemplate方法二</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;compile-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;h1&gt;在javascript中存放模板&lt;/h1&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\nvar source = &apos;&lt;ul&gt;&apos;\n+    &apos;{{each list as value i}}&apos;\n+        &apos;&lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;&apos;\n+    &apos;{{/each}}&apos;\n+ &apos;&lt;/ul&gt;&apos;;\n\nvar render = template.compile(source);\nvar data = {\n    list: [&apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = render(data);\n\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"artTemplate方法三-嵌入子模板\"><a href=\"#artTemplate方法三-嵌入子模板\" class=\"headerlink\" title=\"artTemplate方法三-嵌入子模板\"></a>artTemplate方法三-嵌入子模板</h4><pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;include-demo&lt;/title&gt;\n&lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;\n&lt;h1&gt;{{title}}&lt;/h1&gt;\n{{include 'list'}}\n&lt;/script&gt;\n&lt;script id=&quot;list&quot; type=&quot;text/html&quot;&gt;\n&lt;ul&gt;\n    {{each list as value i}}\n        &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;\n    {{/each}}\n&lt;/ul&gt;\n&lt;/script&gt;\n\n&lt;script&gt;\nvar data = {\n    title: &apos;嵌入子模板&apos;,\n    list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]\n};\nvar html = template(&apos;test&apos;, data);\ndocument.getElementById(&apos;content&apos;).innerHTML = html;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><pre><code>{{each list as value i}}\nlist可以为对象或者是数组，value为值，i为索引。\n</code></pre><h4 id=\"把获取到的时间转换为现在的时间\"><a href=\"#把获取到的时间转换为现在的时间\" class=\"headerlink\" title=\"把获取到的时间转换为现在的时间\"></a>把获取到的时间转换为现在的时间</h4><pre><code>var data = new Date(Number(e.time+&quot;000&quot;)).toLocaleString();\n因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。\n</code></pre>"},{"title":"html5基础","_content":"1. HTML5的语法规范\n   html:4s/4t/xs/xt/5     !\n2. 语义化\n   --标签  header  footer  nav  section   article  aside  progress  video  audio\n   --输入类型  email  url  tel  num  search  range  color  time  date  dateTime  week  month\n   --表单元素  output  meter  keygen dataList\n   --表单属性  placeholder  autofocus  multiple  autocomplete  novalidate  required  form  pattern\n3. 多媒体\n   --audio loop autoplay  controls\n   --video loop autoplay  controls  width  height\n4. DOM扩展\n   --获取元素  document.getElementsByClassName()  querySelector()  querySelectorAll()\n   --类名操作  classList.add()  classList.remove()  classList.toggle()  classList.contains()\n   --自定义属性  dataset[key]='value'  dataset[key]   前缀名“data-*”\n5. H5API\n   --online()/offline()  和“onLine”属性  在线状态/离线状态   检测是否在线\n   --fullScreen  webkitIsFullScreen检测是否全屏  requestFullScreen（）开启全屏  cancelFulScreen()关闭全屏  注意加前缀（webkit-谷歌，moz-火狐） 关闭全部用document调用  document全屏时写成document.documentElement.requestFullScreen\n   --fileReader  获取的图片信息  ele.files[0]  new FileReader()  reader.readAsDataURL(图片信息)  src赋值\n   --drag  拖拽元素draggable=\"true\" 默认不可以被拖拽的元素加上这个属性以后就可以被拖拽\n       -- dragstart  拖拽开始\n       -- dragend  拖拽结束\n       -- dragleave  光标离开拖拽元素\n       -- drag  拖拽过程中\n           目标元素  页面上任意一个元素都可以是拖拽元素，不用特殊设定\n       -- dragenter  拖拽元素进入目标元素时\n       -- dragover  拖拽元素在目标元素内\n       -- dragleave  拖拽元素离开目标元素\n       -- drop  拖拽元素在目标元素内松开鼠标\n6. 地理定位\n   -- geolocation.getCurrentPosition(successCallback, errorCallback, options)\n   -- geolocation.watchPosition(successCallback, errorCallback, options)\n   -- 成功回调是我们能得到一个position\n        position.coords.latitude纬度\n        position.coords.longitude经度\n        position.coords.accuracy精度\n        position.coords.altitude海拔高度\n   -- 失败回调我们能得到一个error  里面写的是错误信息\n   -- 使用百度的API接口\n7. history\n   -- history.pushState(null,'','地址')\n   -- history.replaceState(null,'','地址')\n   -- onpopstate()事件  在历史区发生改变后并且操作历史区的时候\n8. web存储\n   -- sessionStorage  同窗口多页面保存数据  关闭窗口后删除\n   -- localStorage  多窗口保存页面  不会自动删除，只能手动删除\n       setItem(\"key\",\"value\")  增加或更改\n       getItem(\"key\")  获取\n       removeItem(\"key\")  删除\n       clear()  清空\n       key(0)  按照下标回去，返回的是“key”\n9. 应用缓存，配置静态资源文件\n   CACHE MANIFEST\n\n   # 版本号\n\n   CACHE:\n\n   需要缓存的资源\n\n   NETWORK:\n\n   当网络重新连接时需要重新获取的资源\n\n   FALLBACK:\n\n   （源文件）\\s（备用文件）\n   当我们找不到源文件的时候启用备用文件\n\n10,jquery视频编写\n1,oncanplay()检测视频可以播放时触发\n2,video.duration获取视频的总时长\n3,video.paused判断视频播放还是暂停\n4,toggleClass切换按钮状态\n5,video.currentTime获取当前的播放进度\n\n11,分隔字符串返回数组方法为  str.split(\"分隔符\")  分隔符为: , 等.","source":"_posts/HTML5总结.md","raw":"---\ntitle: html5基础\ncategories: ['前端']\ntags: ['html5']\n---\n1. HTML5的语法规范\n   html:4s/4t/xs/xt/5     !\n2. 语义化\n   --标签  header  footer  nav  section   article  aside  progress  video  audio\n   --输入类型  email  url  tel  num  search  range  color  time  date  dateTime  week  month\n   --表单元素  output  meter  keygen dataList\n   --表单属性  placeholder  autofocus  multiple  autocomplete  novalidate  required  form  pattern\n3. 多媒体\n   --audio loop autoplay  controls\n   --video loop autoplay  controls  width  height\n4. DOM扩展\n   --获取元素  document.getElementsByClassName()  querySelector()  querySelectorAll()\n   --类名操作  classList.add()  classList.remove()  classList.toggle()  classList.contains()\n   --自定义属性  dataset[key]='value'  dataset[key]   前缀名“data-*”\n5. H5API\n   --online()/offline()  和“onLine”属性  在线状态/离线状态   检测是否在线\n   --fullScreen  webkitIsFullScreen检测是否全屏  requestFullScreen（）开启全屏  cancelFulScreen()关闭全屏  注意加前缀（webkit-谷歌，moz-火狐） 关闭全部用document调用  document全屏时写成document.documentElement.requestFullScreen\n   --fileReader  获取的图片信息  ele.files[0]  new FileReader()  reader.readAsDataURL(图片信息)  src赋值\n   --drag  拖拽元素draggable=\"true\" 默认不可以被拖拽的元素加上这个属性以后就可以被拖拽\n       -- dragstart  拖拽开始\n       -- dragend  拖拽结束\n       -- dragleave  光标离开拖拽元素\n       -- drag  拖拽过程中\n           目标元素  页面上任意一个元素都可以是拖拽元素，不用特殊设定\n       -- dragenter  拖拽元素进入目标元素时\n       -- dragover  拖拽元素在目标元素内\n       -- dragleave  拖拽元素离开目标元素\n       -- drop  拖拽元素在目标元素内松开鼠标\n6. 地理定位\n   -- geolocation.getCurrentPosition(successCallback, errorCallback, options)\n   -- geolocation.watchPosition(successCallback, errorCallback, options)\n   -- 成功回调是我们能得到一个position\n        position.coords.latitude纬度\n        position.coords.longitude经度\n        position.coords.accuracy精度\n        position.coords.altitude海拔高度\n   -- 失败回调我们能得到一个error  里面写的是错误信息\n   -- 使用百度的API接口\n7. history\n   -- history.pushState(null,'','地址')\n   -- history.replaceState(null,'','地址')\n   -- onpopstate()事件  在历史区发生改变后并且操作历史区的时候\n8. web存储\n   -- sessionStorage  同窗口多页面保存数据  关闭窗口后删除\n   -- localStorage  多窗口保存页面  不会自动删除，只能手动删除\n       setItem(\"key\",\"value\")  增加或更改\n       getItem(\"key\")  获取\n       removeItem(\"key\")  删除\n       clear()  清空\n       key(0)  按照下标回去，返回的是“key”\n9. 应用缓存，配置静态资源文件\n   CACHE MANIFEST\n\n   # 版本号\n\n   CACHE:\n\n   需要缓存的资源\n\n   NETWORK:\n\n   当网络重新连接时需要重新获取的资源\n\n   FALLBACK:\n\n   （源文件）\\s（备用文件）\n   当我们找不到源文件的时候启用备用文件\n\n10,jquery视频编写\n1,oncanplay()检测视频可以播放时触发\n2,video.duration获取视频的总时长\n3,video.paused判断视频播放还是暂停\n4,toggleClass切换按钮状态\n5,video.currentTime获取当前的播放进度\n\n11,分隔字符串返回数组方法为  str.split(\"分隔符\")  分隔符为: , 等.","slug":"HTML5总结","published":1,"date":"2016-11-28T08:15:21.000Z","updated":"2019-04-26T06:57:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gk00027xuqraa9utmj","content":"<ol>\n<li>HTML5的语法规范<br>html:4s/4t/xs/xt/5     !</li>\n<li>语义化<br>–标签  header  footer  nav  section   article  aside  progress  video  audio<br>–输入类型  email  url  tel  num  search  range  color  time  date  dateTime  week  month<br>–表单元素  output  meter  keygen dataList<br>–表单属性  placeholder  autofocus  multiple  autocomplete  novalidate  required  form  pattern</li>\n<li>多媒体<br>–audio loop autoplay  controls<br>–video loop autoplay  controls  width  height</li>\n<li>DOM扩展<br>–获取元素  document.getElementsByClassName()  querySelector()  querySelectorAll()<br>–类名操作  classList.add()  classList.remove()  classList.toggle()  classList.contains()<br>–自定义属性  dataset[key]=’value’  dataset[key]   前缀名“data-*”</li>\n<li>H5API<br>–online()/offline()  和“onLine”属性  在线状态/离线状态   检测是否在线<br>–fullScreen  webkitIsFullScreen检测是否全屏  requestFullScreen（）开启全屏  cancelFulScreen()关闭全屏  注意加前缀（webkit-谷歌，moz-火狐） 关闭全部用document调用  document全屏时写成document.documentElement.requestFullScreen<br>–fileReader  获取的图片信息  ele.files[0]  new FileReader()  reader.readAsDataURL(图片信息)  src赋值<br>–drag  拖拽元素draggable=”true” 默认不可以被拖拽的元素加上这个属性以后就可以被拖拽<pre><code>-- dragstart  拖拽开始\n-- dragend  拖拽结束\n-- dragleave  光标离开拖拽元素\n-- drag  拖拽过程中\n    目标元素  页面上任意一个元素都可以是拖拽元素，不用特殊设定\n-- dragenter  拖拽元素进入目标元素时\n-- dragover  拖拽元素在目标元素内\n-- dragleave  拖拽元素离开目标元素\n-- drop  拖拽元素在目标元素内松开鼠标\n</code></pre></li>\n<li>地理定位<br>– geolocation.getCurrentPosition(successCallback, errorCallback, options)<br>– geolocation.watchPosition(successCallback, errorCallback, options)<br>– 成功回调是我们能得到一个position<pre><code>position.coords.latitude纬度\nposition.coords.longitude经度\nposition.coords.accuracy精度\nposition.coords.altitude海拔高度\n</code></pre>– 失败回调我们能得到一个error  里面写的是错误信息<br>– 使用百度的API接口</li>\n<li>history<br>– history.pushState(null,’’,’地址’)<br>– history.replaceState(null,’’,’地址’)<br>– onpopstate()事件  在历史区发生改变后并且操作历史区的时候</li>\n<li>web存储<br>– sessionStorage  同窗口多页面保存数据  关闭窗口后删除<br>– localStorage  多窗口保存页面  不会自动删除，只能手动删除<pre><code>setItem(&quot;key&quot;,&quot;value&quot;)  增加或更改\ngetItem(&quot;key&quot;)  获取\nremoveItem(&quot;key&quot;)  删除\nclear()  清空\nkey(0)  按照下标回去，返回的是“key”\n</code></pre></li>\n<li><p>应用缓存，配置静态资源文件<br>CACHE MANIFEST</p>\n<h1 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h1><p>CACHE:</p>\n<p>需要缓存的资源</p>\n<p>NETWORK:</p>\n<p>当网络重新连接时需要重新获取的资源</p>\n<p>FALLBACK:</p>\n<p>（源文件）\\s（备用文件）<br>当我们找不到源文件的时候启用备用文件</p>\n</li>\n</ol>\n<p>10,jquery视频编写<br>1,oncanplay()检测视频可以播放时触发<br>2,video.duration获取视频的总时长<br>3,video.paused判断视频播放还是暂停<br>4,toggleClass切换按钮状态<br>5,video.currentTime获取当前的播放进度</p>\n<p>11,分隔字符串返回数组方法为  str.split(“分隔符”)  分隔符为: , 等.</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>HTML5的语法规范<br>html:4s/4t/xs/xt/5     !</li>\n<li>语义化<br>–标签  header  footer  nav  section   article  aside  progress  video  audio<br>–输入类型  email  url  tel  num  search  range  color  time  date  dateTime  week  month<br>–表单元素  output  meter  keygen dataList<br>–表单属性  placeholder  autofocus  multiple  autocomplete  novalidate  required  form  pattern</li>\n<li>多媒体<br>–audio loop autoplay  controls<br>–video loop autoplay  controls  width  height</li>\n<li>DOM扩展<br>–获取元素  document.getElementsByClassName()  querySelector()  querySelectorAll()<br>–类名操作  classList.add()  classList.remove()  classList.toggle()  classList.contains()<br>–自定义属性  dataset[key]=’value’  dataset[key]   前缀名“data-*”</li>\n<li>H5API<br>–online()/offline()  和“onLine”属性  在线状态/离线状态   检测是否在线<br>–fullScreen  webkitIsFullScreen检测是否全屏  requestFullScreen（）开启全屏  cancelFulScreen()关闭全屏  注意加前缀（webkit-谷歌，moz-火狐） 关闭全部用document调用  document全屏时写成document.documentElement.requestFullScreen<br>–fileReader  获取的图片信息  ele.files[0]  new FileReader()  reader.readAsDataURL(图片信息)  src赋值<br>–drag  拖拽元素draggable=”true” 默认不可以被拖拽的元素加上这个属性以后就可以被拖拽<pre><code>-- dragstart  拖拽开始\n-- dragend  拖拽结束\n-- dragleave  光标离开拖拽元素\n-- drag  拖拽过程中\n    目标元素  页面上任意一个元素都可以是拖拽元素，不用特殊设定\n-- dragenter  拖拽元素进入目标元素时\n-- dragover  拖拽元素在目标元素内\n-- dragleave  拖拽元素离开目标元素\n-- drop  拖拽元素在目标元素内松开鼠标\n</code></pre></li>\n<li>地理定位<br>– geolocation.getCurrentPosition(successCallback, errorCallback, options)<br>– geolocation.watchPosition(successCallback, errorCallback, options)<br>– 成功回调是我们能得到一个position<pre><code>position.coords.latitude纬度\nposition.coords.longitude经度\nposition.coords.accuracy精度\nposition.coords.altitude海拔高度\n</code></pre>– 失败回调我们能得到一个error  里面写的是错误信息<br>– 使用百度的API接口</li>\n<li>history<br>– history.pushState(null,’’,’地址’)<br>– history.replaceState(null,’’,’地址’)<br>– onpopstate()事件  在历史区发生改变后并且操作历史区的时候</li>\n<li>web存储<br>– sessionStorage  同窗口多页面保存数据  关闭窗口后删除<br>– localStorage  多窗口保存页面  不会自动删除，只能手动删除<pre><code>setItem(&quot;key&quot;,&quot;value&quot;)  增加或更改\ngetItem(&quot;key&quot;)  获取\nremoveItem(&quot;key&quot;)  删除\nclear()  清空\nkey(0)  按照下标回去，返回的是“key”\n</code></pre></li>\n<li><p>应用缓存，配置静态资源文件<br>CACHE MANIFEST</p>\n<h1 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h1><p>CACHE:</p>\n<p>需要缓存的资源</p>\n<p>NETWORK:</p>\n<p>当网络重新连接时需要重新获取的资源</p>\n<p>FALLBACK:</p>\n<p>（源文件）\\s（备用文件）<br>当我们找不到源文件的时候启用备用文件</p>\n</li>\n</ol>\n<p>10,jquery视频编写<br>1,oncanplay()检测视频可以播放时触发<br>2,video.duration获取视频的总时长<br>3,video.paused判断视频播放还是暂停<br>4,toggleClass切换按钮状态<br>5,video.currentTime获取当前的播放进度</p>\n<p>11,分隔字符串返回数组方法为  str.split(“分隔符”)  分隔符为: , 等.</p>\n"},{"title":"canvas 基础一","_content":"#### 1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\n\n#### 2.canvas默认的大小是宽300px，高150px，\n\t宽度和高度可以通过canvas标签的height和width属性进行设置\n\t<canvas width='600px' height=\"300px\" >\n\t注意：请不要使用css来设置canvas的宽度和高度 \n\n#### 3.如何使用canvas进行绘图，步骤如下：\n\tA.获得canvas标签对象：  var cas = document.getElementsByTagName(\"canvas\")[0];\n\tB.获取canvas标签对应的绘图工具： var ctx = cas.getContext(\"2d\");\n\t\t\t\t\t var ctx2 = cas.getContext(\"webgl\");\n\t\t\t\t         var ctx3 = cas.getContext('experimental-webgl');\n\tC.开始使用绘图工具进行绘制： ctx.moveTo(100,100);//将绘图工具定点在坐标x100，y100的地方\n\t\t\t\t     ctx.lineTo(200,100);//将绘图工具从100,100的坐标绘制一条到200,100坐标的线（注意，这里的moveTo和lineTo都是打草稿，必须通过stroke或者fill进行真正的绘制）\t\n\tD.真正的绘制图形：    ctx.stroke();//画线\n\t\t\t      ctx.fill();//填充\n\n#### 4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点\n\t原点向右为x的正方向，原点向左为x的负方向\n\t原点向下为y的正方向，原点向上为y的负方向\n\n#### 5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\n\n#### 6.非零环绕原则：判断绘制的图形是否要进行填充的准则。\n\t从是否要填充的区域拉出一条辅助线来到图形的外面\n\t如果绘制图形的线穿过辅助线的时候是正方向就记做+1\n\t如果绘制图形的线穿过辅助线的时候是负方向就记做-1\n\t最后把所有记录的值加总，如果值为0这块区域就不填充，如果值为非零，这块区域就要填充。\n\t注意：从左到右为正，从右到左为负。，、\n\n\t练习：将回字型的图形绘制出来。\n\n#### 7.closePath方法：可以将绘制的图形进行完美的闭合\n\n#### 8.api集合：\n\t属性：\tctx.lineWidth = \"10\";//设置绘图工具画的线的宽度为10px\n\t      \tctx.lineCap = 'butt';//可以设置的值：\"square\",\"round\";\n\t      \tctx.lineJoin = 'miter';//可以设置的值：\"round\", \"bevel\";\n\t\tctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n\t\tctx.strokeStyle = 'red';//设置描边线条的颜色\n\t\tctx.fillStyle = 'blue';//设置填充的颜色\n\n\t方法：\tctx.moveTo(x,y);//将绘图工具进行定点\n  \t      \tctx.lineTo(x,y);//将绘图工具移动到x，y的坐标\n\t      \tctx.stroke();//将图形进行描边\n\t      \tctx.fill();//将图形进行填充\n \t      \tctx.closePath();//将图形进行闭合\n\t      \tctx.beginPath();//开启新路径，开启一个新的绘图状态。\n\t\tctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n\t\tctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n\n#### 9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\n\t取消锯齿的美化操作会在什么时候发生：设置的线宽为奇数的时候，当你画的线不是一个直线的线（倾斜的线。）\n\n\t注意：当线宽设置的比较宽了以后，要注意一个事情。线的起始点是从线的线中心开始计算起始点的。\n\n\t总结：如果要闭合一个图形，请使用closePath方法，不要再用lineTo连线。\n\n#### 10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\n\n#### 11.绘制虚线：\n\tA.ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n\tB.ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n\tC.ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n\n\n#### 12.坐标轴的原点转换：\n\tx0,y0 : 指的是绘制的坐标系的原点\n\tx,y: 计算出来的坐标点的x,y坐标\n\t\n\tvar x = (cas.width - paddingLeft - paddingRight - arrowHeight)/2,\n\t    y = (cas.height - paddingTop - paddingBottom - arrowHeight)/2;\n\n\t//转换坐标原点的公式： x = x0+x; y = y0 - y;\n\tx = x + x0;\n\ty = y0 - y; ","source":"_posts/canvas第一天.md","raw":"---\ntitle: canvas 基础一\ncategories: ['前端']\ntags: ['canvas'] \n---\n#### 1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\n\n#### 2.canvas默认的大小是宽300px，高150px，\n\t宽度和高度可以通过canvas标签的height和width属性进行设置\n\t<canvas width='600px' height=\"300px\" >\n\t注意：请不要使用css来设置canvas的宽度和高度 \n\n#### 3.如何使用canvas进行绘图，步骤如下：\n\tA.获得canvas标签对象：  var cas = document.getElementsByTagName(\"canvas\")[0];\n\tB.获取canvas标签对应的绘图工具： var ctx = cas.getContext(\"2d\");\n\t\t\t\t\t var ctx2 = cas.getContext(\"webgl\");\n\t\t\t\t         var ctx3 = cas.getContext('experimental-webgl');\n\tC.开始使用绘图工具进行绘制： ctx.moveTo(100,100);//将绘图工具定点在坐标x100，y100的地方\n\t\t\t\t     ctx.lineTo(200,100);//将绘图工具从100,100的坐标绘制一条到200,100坐标的线（注意，这里的moveTo和lineTo都是打草稿，必须通过stroke或者fill进行真正的绘制）\t\n\tD.真正的绘制图形：    ctx.stroke();//画线\n\t\t\t      ctx.fill();//填充\n\n#### 4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点\n\t原点向右为x的正方向，原点向左为x的负方向\n\t原点向下为y的正方向，原点向上为y的负方向\n\n#### 5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\n\n#### 6.非零环绕原则：判断绘制的图形是否要进行填充的准则。\n\t从是否要填充的区域拉出一条辅助线来到图形的外面\n\t如果绘制图形的线穿过辅助线的时候是正方向就记做+1\n\t如果绘制图形的线穿过辅助线的时候是负方向就记做-1\n\t最后把所有记录的值加总，如果值为0这块区域就不填充，如果值为非零，这块区域就要填充。\n\t注意：从左到右为正，从右到左为负。，、\n\n\t练习：将回字型的图形绘制出来。\n\n#### 7.closePath方法：可以将绘制的图形进行完美的闭合\n\n#### 8.api集合：\n\t属性：\tctx.lineWidth = \"10\";//设置绘图工具画的线的宽度为10px\n\t      \tctx.lineCap = 'butt';//可以设置的值：\"square\",\"round\";\n\t      \tctx.lineJoin = 'miter';//可以设置的值：\"round\", \"bevel\";\n\t\tctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n\t\tctx.strokeStyle = 'red';//设置描边线条的颜色\n\t\tctx.fillStyle = 'blue';//设置填充的颜色\n\n\t方法：\tctx.moveTo(x,y);//将绘图工具进行定点\n  \t      \tctx.lineTo(x,y);//将绘图工具移动到x，y的坐标\n\t      \tctx.stroke();//将图形进行描边\n\t      \tctx.fill();//将图形进行填充\n \t      \tctx.closePath();//将图形进行闭合\n\t      \tctx.beginPath();//开启新路径，开启一个新的绘图状态。\n\t\tctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n\t\tctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n\n#### 9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\n\t取消锯齿的美化操作会在什么时候发生：设置的线宽为奇数的时候，当你画的线不是一个直线的线（倾斜的线。）\n\n\t注意：当线宽设置的比较宽了以后，要注意一个事情。线的起始点是从线的线中心开始计算起始点的。\n\n\t总结：如果要闭合一个图形，请使用closePath方法，不要再用lineTo连线。\n\n#### 10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\n\n#### 11.绘制虚线：\n\tA.ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n\tB.ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n\tC.ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n\n\n#### 12.坐标轴的原点转换：\n\tx0,y0 : 指的是绘制的坐标系的原点\n\tx,y: 计算出来的坐标点的x,y坐标\n\t\n\tvar x = (cas.width - paddingLeft - paddingRight - arrowHeight)/2,\n\t    y = (cas.height - paddingTop - paddingBottom - arrowHeight)/2;\n\n\t//转换坐标原点的公式： x = x0+x; y = y0 - y;\n\tx = x + x0;\n\ty = y0 - y; ","slug":"canvas第一天","published":1,"date":"2017-01-06T13:39:39.000Z","updated":"2019-04-26T07:29:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gn00057xuqwro5ary2","content":"<h4 id=\"1-canvas-canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\"><a href=\"#1-canvas-canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\" class=\"headerlink\" title=\"1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\"></a>1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。</h4><h4 id=\"2-canvas默认的大小是宽300px，高150px，\"><a href=\"#2-canvas默认的大小是宽300px，高150px，\" class=\"headerlink\" title=\"2.canvas默认的大小是宽300px，高150px，\"></a>2.canvas默认的大小是宽300px，高150px，</h4><pre><code>宽度和高度可以通过canvas标签的height和width属性进行设置\n&lt;canvas width=&apos;600px&apos; height=&quot;300px&quot; &gt;\n注意：请不要使用css来设置canvas的宽度和高度 \n</code></pre><h4 id=\"3-如何使用canvas进行绘图，步骤如下：\"><a href=\"#3-如何使用canvas进行绘图，步骤如下：\" class=\"headerlink\" title=\"3.如何使用canvas进行绘图，步骤如下：\"></a>3.如何使用canvas进行绘图，步骤如下：</h4><pre><code>A.获得canvas标签对象：  var cas = document.getElementsByTagName(&quot;canvas&quot;)[0];\nB.获取canvas标签对应的绘图工具： var ctx = cas.getContext(&quot;2d&quot;);\n                 var ctx2 = cas.getContext(&quot;webgl&quot;);\n                     var ctx3 = cas.getContext(&apos;experimental-webgl&apos;);\nC.开始使用绘图工具进行绘制： ctx.moveTo(100,100);//将绘图工具定点在坐标x100，y100的地方\n                 ctx.lineTo(200,100);//将绘图工具从100,100的坐标绘制一条到200,100坐标的线（注意，这里的moveTo和lineTo都是打草稿，必须通过stroke或者fill进行真正的绘制）    \nD.真正的绘制图形：    ctx.stroke();//画线\n              ctx.fill();//填充\n</code></pre><h4 id=\"4-canvas的坐标系：以canvas画布的左上角作为坐标系的原点\"><a href=\"#4-canvas的坐标系：以canvas画布的左上角作为坐标系的原点\" class=\"headerlink\" title=\"4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点\"></a>4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点</h4><pre><code>原点向右为x的正方向，原点向左为x的负方向\n原点向下为y的正方向，原点向上为y的负方向\n</code></pre><h4 id=\"5-fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\"><a href=\"#5-fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\" class=\"headerlink\" title=\"5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\"></a>5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。</h4><h4 id=\"6-非零环绕原则：判断绘制的图形是否要进行填充的准则。\"><a href=\"#6-非零环绕原则：判断绘制的图形是否要进行填充的准则。\" class=\"headerlink\" title=\"6.非零环绕原则：判断绘制的图形是否要进行填充的准则。\"></a>6.非零环绕原则：判断绘制的图形是否要进行填充的准则。</h4><pre><code>从是否要填充的区域拉出一条辅助线来到图形的外面\n如果绘制图形的线穿过辅助线的时候是正方向就记做+1\n如果绘制图形的线穿过辅助线的时候是负方向就记做-1\n最后把所有记录的值加总，如果值为0这块区域就不填充，如果值为非零，这块区域就要填充。\n注意：从左到右为正，从右到左为负。，、\n\n练习：将回字型的图形绘制出来。\n</code></pre><h4 id=\"7-closePath方法：可以将绘制的图形进行完美的闭合\"><a href=\"#7-closePath方法：可以将绘制的图形进行完美的闭合\" class=\"headerlink\" title=\"7.closePath方法：可以将绘制的图形进行完美的闭合\"></a>7.closePath方法：可以将绘制的图形进行完美的闭合</h4><h4 id=\"8-api集合：\"><a href=\"#8-api集合：\" class=\"headerlink\" title=\"8.api集合：\"></a>8.api集合：</h4><pre><code>属性：    ctx.lineWidth = &quot;10&quot;;//设置绘图工具画的线的宽度为10px\n          ctx.lineCap = &apos;butt&apos;;//可以设置的值：&quot;square&quot;,&quot;round&quot;;\n          ctx.lineJoin = &apos;miter&apos;;//可以设置的值：&quot;round&quot;, &quot;bevel&quot;;\n    ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n    ctx.strokeStyle = &apos;red&apos;;//设置描边线条的颜色\n    ctx.fillStyle = &apos;blue&apos;;//设置填充的颜色\n\n方法：    ctx.moveTo(x,y);//将绘图工具进行定点\n            ctx.lineTo(x,y);//将绘图工具移动到x，y的坐标\n          ctx.stroke();//将图形进行描边\n          ctx.fill();//将图形进行填充\n           ctx.closePath();//将图形进行闭合\n          ctx.beginPath();//开启新路径，开启一个新的绘图状态。\n    ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n    ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n</code></pre><h4 id=\"9-取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\"><a href=\"#9-取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\" class=\"headerlink\" title=\"9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\"></a>9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。</h4><pre><code>取消锯齿的美化操作会在什么时候发生：设置的线宽为奇数的时候，当你画的线不是一个直线的线（倾斜的线。）\n\n注意：当线宽设置的比较宽了以后，要注意一个事情。线的起始点是从线的线中心开始计算起始点的。\n\n总结：如果要闭合一个图形，请使用closePath方法，不要再用lineTo连线。\n</code></pre><h4 id=\"10-开启新路径：beginPath-：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\"><a href=\"#10-开启新路径：beginPath-：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\" class=\"headerlink\" title=\"10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\"></a>10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰</h4><h4 id=\"11-绘制虚线：\"><a href=\"#11-绘制虚线：\" class=\"headerlink\" title=\"11.绘制虚线：\"></a>11.绘制虚线：</h4><pre><code>A.ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\nB.ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\nC.ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n</code></pre><h4 id=\"12-坐标轴的原点转换：\"><a href=\"#12-坐标轴的原点转换：\" class=\"headerlink\" title=\"12.坐标轴的原点转换：\"></a>12.坐标轴的原点转换：</h4><pre><code>x0,y0 : 指的是绘制的坐标系的原点\nx,y: 计算出来的坐标点的x,y坐标\n\nvar x = (cas.width - paddingLeft - paddingRight - arrowHeight)/2,\n    y = (cas.height - paddingTop - paddingBottom - arrowHeight)/2;\n\n//转换坐标原点的公式： x = x0+x; y = y0 - y;\nx = x + x0;\ny = y0 - y; \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-canvas-canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\"><a href=\"#1-canvas-canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\" class=\"headerlink\" title=\"1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。\"></a>1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。</h4><h4 id=\"2-canvas默认的大小是宽300px，高150px，\"><a href=\"#2-canvas默认的大小是宽300px，高150px，\" class=\"headerlink\" title=\"2.canvas默认的大小是宽300px，高150px，\"></a>2.canvas默认的大小是宽300px，高150px，</h4><pre><code>宽度和高度可以通过canvas标签的height和width属性进行设置\n&lt;canvas width=&apos;600px&apos; height=&quot;300px&quot; &gt;\n注意：请不要使用css来设置canvas的宽度和高度 \n</code></pre><h4 id=\"3-如何使用canvas进行绘图，步骤如下：\"><a href=\"#3-如何使用canvas进行绘图，步骤如下：\" class=\"headerlink\" title=\"3.如何使用canvas进行绘图，步骤如下：\"></a>3.如何使用canvas进行绘图，步骤如下：</h4><pre><code>A.获得canvas标签对象：  var cas = document.getElementsByTagName(&quot;canvas&quot;)[0];\nB.获取canvas标签对应的绘图工具： var ctx = cas.getContext(&quot;2d&quot;);\n                 var ctx2 = cas.getContext(&quot;webgl&quot;);\n                     var ctx3 = cas.getContext(&apos;experimental-webgl&apos;);\nC.开始使用绘图工具进行绘制： ctx.moveTo(100,100);//将绘图工具定点在坐标x100，y100的地方\n                 ctx.lineTo(200,100);//将绘图工具从100,100的坐标绘制一条到200,100坐标的线（注意，这里的moveTo和lineTo都是打草稿，必须通过stroke或者fill进行真正的绘制）    \nD.真正的绘制图形：    ctx.stroke();//画线\n              ctx.fill();//填充\n</code></pre><h4 id=\"4-canvas的坐标系：以canvas画布的左上角作为坐标系的原点\"><a href=\"#4-canvas的坐标系：以canvas画布的左上角作为坐标系的原点\" class=\"headerlink\" title=\"4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点\"></a>4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点</h4><pre><code>原点向右为x的正方向，原点向左为x的负方向\n原点向下为y的正方向，原点向上为y的负方向\n</code></pre><h4 id=\"5-fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\"><a href=\"#5-fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\" class=\"headerlink\" title=\"5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。\"></a>5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。</h4><h4 id=\"6-非零环绕原则：判断绘制的图形是否要进行填充的准则。\"><a href=\"#6-非零环绕原则：判断绘制的图形是否要进行填充的准则。\" class=\"headerlink\" title=\"6.非零环绕原则：判断绘制的图形是否要进行填充的准则。\"></a>6.非零环绕原则：判断绘制的图形是否要进行填充的准则。</h4><pre><code>从是否要填充的区域拉出一条辅助线来到图形的外面\n如果绘制图形的线穿过辅助线的时候是正方向就记做+1\n如果绘制图形的线穿过辅助线的时候是负方向就记做-1\n最后把所有记录的值加总，如果值为0这块区域就不填充，如果值为非零，这块区域就要填充。\n注意：从左到右为正，从右到左为负。，、\n\n练习：将回字型的图形绘制出来。\n</code></pre><h4 id=\"7-closePath方法：可以将绘制的图形进行完美的闭合\"><a href=\"#7-closePath方法：可以将绘制的图形进行完美的闭合\" class=\"headerlink\" title=\"7.closePath方法：可以将绘制的图形进行完美的闭合\"></a>7.closePath方法：可以将绘制的图形进行完美的闭合</h4><h4 id=\"8-api集合：\"><a href=\"#8-api集合：\" class=\"headerlink\" title=\"8.api集合：\"></a>8.api集合：</h4><pre><code>属性：    ctx.lineWidth = &quot;10&quot;;//设置绘图工具画的线的宽度为10px\n          ctx.lineCap = &apos;butt&apos;;//可以设置的值：&quot;square&quot;,&quot;round&quot;;\n          ctx.lineJoin = &apos;miter&apos;;//可以设置的值：&quot;round&quot;, &quot;bevel&quot;;\n    ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n    ctx.strokeStyle = &apos;red&apos;;//设置描边线条的颜色\n    ctx.fillStyle = &apos;blue&apos;;//设置填充的颜色\n\n方法：    ctx.moveTo(x,y);//将绘图工具进行定点\n            ctx.lineTo(x,y);//将绘图工具移动到x，y的坐标\n          ctx.stroke();//将图形进行描边\n          ctx.fill();//将图形进行填充\n           ctx.closePath();//将图形进行闭合\n          ctx.beginPath();//开启新路径，开启一个新的绘图状态。\n    ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\n    ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\n</code></pre><h4 id=\"9-取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\"><a href=\"#9-取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\" class=\"headerlink\" title=\"9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。\"></a>9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。</h4><pre><code>取消锯齿的美化操作会在什么时候发生：设置的线宽为奇数的时候，当你画的线不是一个直线的线（倾斜的线。）\n\n注意：当线宽设置的比较宽了以后，要注意一个事情。线的起始点是从线的线中心开始计算起始点的。\n\n总结：如果要闭合一个图形，请使用closePath方法，不要再用lineTo连线。\n</code></pre><h4 id=\"10-开启新路径：beginPath-：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\"><a href=\"#10-开启新路径：beginPath-：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\" class=\"headerlink\" title=\"10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰\"></a>10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰</h4><h4 id=\"11-绘制虚线：\"><a href=\"#11-绘制虚线：\" class=\"headerlink\" title=\"11.绘制虚线：\"></a>11.绘制虚线：</h4><pre><code>A.ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制\nB.ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组\nC.ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进\n</code></pre><h4 id=\"12-坐标轴的原点转换：\"><a href=\"#12-坐标轴的原点转换：\" class=\"headerlink\" title=\"12.坐标轴的原点转换：\"></a>12.坐标轴的原点转换：</h4><pre><code>x0,y0 : 指的是绘制的坐标系的原点\nx,y: 计算出来的坐标点的x,y坐标\n\nvar x = (cas.width - paddingLeft - paddingRight - arrowHeight)/2,\n    y = (cas.height - paddingTop - paddingBottom - arrowHeight)/2;\n\n//转换坐标原点的公式： x = x0+x; y = y0 - y;\nx = x + x0;\ny = y0 - y; \n</code></pre>"},{"title":"canvas基础三","_content":"#### \n1. 图片绘制\n\t创建图片元素\n\tdocument.createElement( 'img' )\n\tvar img = new Image();\n\timg.src = '';资源图片的路径。\n\tctx.drawImage()\n\t有三种调用形式\n\t1> ctx.drawImage( img, x, y ) 将 image 绘制到 x, y 表示的位置\n\t2> ctx.drawImage( img, x, y, width, height ) 将 img 绘制到一个矩形区域内\n\t说明，前面的x，y为绘制起始的位置，后面的width和height是图片显示的大小。\n\t这里可以使x,y加一个数字实现叠图的效果。\n\t3> ctx.drawImage( img, sx, sy, sw, sh, x, y, w, h )\n\t\t将图片 img 的 sx, sy, sw, sh 部分的内容绘制到画布的x, y, w, h 的矩形区域内.\n\t说明sx,sy是资源图片的起始位置，sw,sh资源图片的宽高，x,y目标显示起始坐标，目标显示宽高。\n\t\n\t\n2. 计时器模型\n\tvar id = setInterval(function () {\n\n\t\tif ( 条件 ) {\n\n\t\t\tclearInterval( id );\n\t\t}\n\n\n\t\t// 继续执行我的内容\n\n\t}, 20);\n\t知识点：ctx.clearRect( 0, 0, cas.width, cas.height );擦除整个画布。\n\t动画：核心代码参考\n\t<script>\n\t\tfunction toAngle( radian ) {\n\t\t\treturn radian * 180 / Math.PI;\n\t\t}\n\t\tfunction toRadian( angle ) {\n\t\t\treturn angle * Math.PI / 180;\n\t\t}\n\t\tvar cas = document.getElementById( 'cas' );\n\t\tvar ctx = cas.getContext( '2d' );\n\t\tvar img = new Image();\n\t\timg.src = 'NPCrabbitbaby-2.png';\n\t\timg.onload = function() {\n\t\t\tvar width = img.width / 4;\n\t\t\tvar height = img.height / 4;\n\t\t\tvar i = 0;\n\t\t\tsetInterval(function() {\n\t\t\tctx.clearRect( 0, 0, cas.width, cas.height );\n\t\t\tctx.drawImage( img, i*width,0,width,height,100,100,width,height);\n\t\t\tif ( i == 3) {\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t},200);\n}\n\n3. 变换的概念\n\t计算机绘图是利用坐标进行绘图. 绘制任何图形都和坐标系的结构息息相关.\n\n\t所谓的变换就是一套数学公式, 可以记录坐标轴的变化方式.\n\t利用坐标轴的变换可以绘制出, 根据不同坐标轴特点而形成的图形.\n\n\t基本的 api\n\tctx.translate(x,y)\t\t平移变换\n\tctx.rotate(reg)\t\t旋转变换\n\tctx.scale(x,y)\t\t\t伸缩变换\n\n\n4. 封装绘图对象\n\tLine\n\tRect\n\tCircle\tx, y, radius, strokeStyle, fillStyle, lineWidth\n\tArc\n\n\tfunction Line( config ) {\n\n\t}\n\tLine.prototype = {\n\t\tstroke: function () {\n\n\t\t}\n\t}\n\n\n5. canvas 的状态\n\t在 Canvas 中凡是设置了属性效果, 都会延续到后面一次修改\n\tCanvas 在创建出来的时候, 是有一个默认的状态的\n\t我希望每次修改状态的时候 都是不影响原来默认状态的\n\t每次画完图时, 我都会新建一个状态, 然后绘制完成后\n\t恢复到原有状态\n\n\tctx.save()\t\t将当前状态保存\n\tctx.restore() \t将保存的状态恢复\n\n\t状态栈\n\n6. 在 canvas 绘制的时候允许使用 canvas 绘制 canvas\n\t\n\tctx.darwImage( img, ... )\n\n\t此时 img 可以是 图片, 还可以是 canvas, 甚至是 video\n\n\n\n7. Konva 是一个完全面向对象的框架\n\t将所有的东西都看做是对象: 图片, 直线, 矩形, ...\n\t将整个canvas看做成舞台(stage)\n\t在舞台上放一个层, 那么将所有的图形放在这个层中\n\n\n\t命名空间\n\n\tvar num = 123;\n\tfunction foo() {}\n\t// 污染全局作用域\n\tvar Itcast = {};\n\n\tItcast.num = 123;\n\tItcast.foo = function () {};\n\n8. 获取当前字体大小的情况下某些文字占用的宽度和高度\n\tctx.font = \"20px\";\n\tvar obj = ctx.measureText(\"你好\");\n\tobj.width  obj.height\n\n9. 在canvas里面绘制图片：\n\tA.创建一个图片对象\n\t  var img = new Image();//创建一个图片对象\n\t  img.src = '1.jpg';\n\n\tB.等图片对象加载完成以后，将图片对象绘制到canvas里面去\n\t  //等待img对象加载完成以后，执行函数\n\t  img.onload = function(){\n\t\t//1.将图片绘制到canvas里面的坐标0，0处\n\t\tctx.drawImage( img , 0 , 0 );\n\n\t\t//2.将图片绘制到canvas里面的坐标0,0处，并且图片大小为width,height\n\t\tctx.drawImage( img , 0, 0, width, height);\n\n\t\t//3.将图片img的sx,sy坐标处的sw,sh大小的图片区域绘制到canvas里面的x,y坐标处的大小为w,h\t\t\t//的区域中\n\t\tctx.drawImage( img , sx,sy,sw,sh,  x,y,w,h);\n\t  }\n\n\n10. 变换的概念：\n\t我们现在的canvas绘图都是通过坐标来进行绘制。\n\t所谓的坐标就是canvas坐标系中的一个点。\n\tcanvas的坐标系可以通过变换来进行改变，当canvas的坐标系发生了改变的时候，坐标点也会跟着发生改变。\n\t最后我们可以通过变换来画出一些比较好看的图形。\n\n\n\t变换的api方法：\n\t\tA.translate(x,y);//平移变换，\n\t\tB.rotate(deg);//旋转坐标系，旋转deg度\n\t\tC.scale(2,0.5);//缩放变换,  x轴放大2倍，y轴缩小一半\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/canvas第三天.md","raw":"---\ntitle: canvas基础三\ncategories: ['前端']\ntags: ['canvas'] \n---\n#### \n1. 图片绘制\n\t创建图片元素\n\tdocument.createElement( 'img' )\n\tvar img = new Image();\n\timg.src = '';资源图片的路径。\n\tctx.drawImage()\n\t有三种调用形式\n\t1> ctx.drawImage( img, x, y ) 将 image 绘制到 x, y 表示的位置\n\t2> ctx.drawImage( img, x, y, width, height ) 将 img 绘制到一个矩形区域内\n\t说明，前面的x，y为绘制起始的位置，后面的width和height是图片显示的大小。\n\t这里可以使x,y加一个数字实现叠图的效果。\n\t3> ctx.drawImage( img, sx, sy, sw, sh, x, y, w, h )\n\t\t将图片 img 的 sx, sy, sw, sh 部分的内容绘制到画布的x, y, w, h 的矩形区域内.\n\t说明sx,sy是资源图片的起始位置，sw,sh资源图片的宽高，x,y目标显示起始坐标，目标显示宽高。\n\t\n\t\n2. 计时器模型\n\tvar id = setInterval(function () {\n\n\t\tif ( 条件 ) {\n\n\t\t\tclearInterval( id );\n\t\t}\n\n\n\t\t// 继续执行我的内容\n\n\t}, 20);\n\t知识点：ctx.clearRect( 0, 0, cas.width, cas.height );擦除整个画布。\n\t动画：核心代码参考\n\t<script>\n\t\tfunction toAngle( radian ) {\n\t\t\treturn radian * 180 / Math.PI;\n\t\t}\n\t\tfunction toRadian( angle ) {\n\t\t\treturn angle * Math.PI / 180;\n\t\t}\n\t\tvar cas = document.getElementById( 'cas' );\n\t\tvar ctx = cas.getContext( '2d' );\n\t\tvar img = new Image();\n\t\timg.src = 'NPCrabbitbaby-2.png';\n\t\timg.onload = function() {\n\t\t\tvar width = img.width / 4;\n\t\t\tvar height = img.height / 4;\n\t\t\tvar i = 0;\n\t\t\tsetInterval(function() {\n\t\t\tctx.clearRect( 0, 0, cas.width, cas.height );\n\t\t\tctx.drawImage( img, i*width,0,width,height,100,100,width,height);\n\t\t\tif ( i == 3) {\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t},200);\n}\n\n3. 变换的概念\n\t计算机绘图是利用坐标进行绘图. 绘制任何图形都和坐标系的结构息息相关.\n\n\t所谓的变换就是一套数学公式, 可以记录坐标轴的变化方式.\n\t利用坐标轴的变换可以绘制出, 根据不同坐标轴特点而形成的图形.\n\n\t基本的 api\n\tctx.translate(x,y)\t\t平移变换\n\tctx.rotate(reg)\t\t旋转变换\n\tctx.scale(x,y)\t\t\t伸缩变换\n\n\n4. 封装绘图对象\n\tLine\n\tRect\n\tCircle\tx, y, radius, strokeStyle, fillStyle, lineWidth\n\tArc\n\n\tfunction Line( config ) {\n\n\t}\n\tLine.prototype = {\n\t\tstroke: function () {\n\n\t\t}\n\t}\n\n\n5. canvas 的状态\n\t在 Canvas 中凡是设置了属性效果, 都会延续到后面一次修改\n\tCanvas 在创建出来的时候, 是有一个默认的状态的\n\t我希望每次修改状态的时候 都是不影响原来默认状态的\n\t每次画完图时, 我都会新建一个状态, 然后绘制完成后\n\t恢复到原有状态\n\n\tctx.save()\t\t将当前状态保存\n\tctx.restore() \t将保存的状态恢复\n\n\t状态栈\n\n6. 在 canvas 绘制的时候允许使用 canvas 绘制 canvas\n\t\n\tctx.darwImage( img, ... )\n\n\t此时 img 可以是 图片, 还可以是 canvas, 甚至是 video\n\n\n\n7. Konva 是一个完全面向对象的框架\n\t将所有的东西都看做是对象: 图片, 直线, 矩形, ...\n\t将整个canvas看做成舞台(stage)\n\t在舞台上放一个层, 那么将所有的图形放在这个层中\n\n\n\t命名空间\n\n\tvar num = 123;\n\tfunction foo() {}\n\t// 污染全局作用域\n\tvar Itcast = {};\n\n\tItcast.num = 123;\n\tItcast.foo = function () {};\n\n8. 获取当前字体大小的情况下某些文字占用的宽度和高度\n\tctx.font = \"20px\";\n\tvar obj = ctx.measureText(\"你好\");\n\tobj.width  obj.height\n\n9. 在canvas里面绘制图片：\n\tA.创建一个图片对象\n\t  var img = new Image();//创建一个图片对象\n\t  img.src = '1.jpg';\n\n\tB.等图片对象加载完成以后，将图片对象绘制到canvas里面去\n\t  //等待img对象加载完成以后，执行函数\n\t  img.onload = function(){\n\t\t//1.将图片绘制到canvas里面的坐标0，0处\n\t\tctx.drawImage( img , 0 , 0 );\n\n\t\t//2.将图片绘制到canvas里面的坐标0,0处，并且图片大小为width,height\n\t\tctx.drawImage( img , 0, 0, width, height);\n\n\t\t//3.将图片img的sx,sy坐标处的sw,sh大小的图片区域绘制到canvas里面的x,y坐标处的大小为w,h\t\t\t//的区域中\n\t\tctx.drawImage( img , sx,sy,sw,sh,  x,y,w,h);\n\t  }\n\n\n10. 变换的概念：\n\t我们现在的canvas绘图都是通过坐标来进行绘制。\n\t所谓的坐标就是canvas坐标系中的一个点。\n\tcanvas的坐标系可以通过变换来进行改变，当canvas的坐标系发生了改变的时候，坐标点也会跟着发生改变。\n\t最后我们可以通过变换来画出一些比较好看的图形。\n\n\n\t变换的api方法：\n\t\tA.translate(x,y);//平移变换，\n\t\tB.rotate(deg);//旋转坐标系，旋转deg度\n\t\tC.scale(2,0.5);//缩放变换,  x轴放大2倍，y轴缩小一半\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"canvas第三天","published":1,"date":"2017-01-09T14:51:28.000Z","updated":"2019-04-26T07:29:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0go00067xuqwuurefq6","content":"<p>#### </p>\n<ol>\n<li>图片绘制<br> 创建图片元素<br> document.createElement( ‘img’ )<br> var img = new Image();<br> img.src = ‘’;资源图片的路径。<br> ctx.drawImage()<br> 有三种调用形式<br> 1&gt; ctx.drawImage( img, x, y ) 将 image 绘制到 x, y 表示的位置<br> 2&gt; ctx.drawImage( img, x, y, width, height ) 将 img 绘制到一个矩形区域内<br> 说明，前面的x，y为绘制起始的位置，后面的width和height是图片显示的大小。<br> 这里可以使x,y加一个数字实现叠图的效果。<br> 3&gt; ctx.drawImage( img, sx, sy, sw, sh, x, y, w, h )<pre><code>将图片 img 的 sx, sy, sw, sh 部分的内容绘制到画布的x, y, w, h 的矩形区域内.\n</code></pre> 说明sx,sy是资源图片的起始位置，sw,sh资源图片的宽高，x,y目标显示起始坐标，目标显示宽高。</li>\n</ol>\n<ol>\n<li><p>计时器模型<br> var id = setInterval(function () {</p>\n<pre><code>if ( 条件 ) {\n\n    clearInterval( id );\n}\n</code></pre></li>\n</ol>\n<pre><code>    // 继续执行我的内容\n\n}, 20);\n知识点：ctx.clearRect( 0, 0, cas.width, cas.height );擦除整个画布。\n动画：核心代码参考\n&lt;script&gt;\n    function toAngle( radian ) {\n        return radian * 180 / Math.PI;\n    }\n    function toRadian( angle ) {\n        return angle * Math.PI / 180;\n    }\n    var cas = document.getElementById( &apos;cas&apos; );\n    var ctx = cas.getContext( &apos;2d&apos; );\n    var img = new Image();\n    img.src = &apos;NPCrabbitbaby-2.png&apos;;\n    img.onload = function() {\n        var width = img.width / 4;\n        var height = img.height / 4;\n        var i = 0;\n        setInterval(function() {\n        ctx.clearRect( 0, 0, cas.width, cas.height );\n        ctx.drawImage( img, i*width,0,width,height,100,100,width,height);\n        if ( i == 3) {\n            i = 0;\n        } else {\n            i++;\n        }\n    },200);\n</code></pre><p>}</p>\n<ol>\n<li><p>变换的概念<br> 计算机绘图是利用坐标进行绘图. 绘制任何图形都和坐标系的结构息息相关.</p>\n<p> 所谓的变换就是一套数学公式, 可以记录坐标轴的变化方式.<br> 利用坐标轴的变换可以绘制出, 根据不同坐标轴特点而形成的图形.</p>\n<p> 基本的 api<br> ctx.translate(x,y)        平移变换<br> ctx.rotate(reg)        旋转变换<br> ctx.scale(x,y)            伸缩变换</p>\n</li>\n</ol>\n<ol>\n<li><p>封装绘图对象<br> Line<br> Rect<br> Circle    x, y, radius, strokeStyle, fillStyle, lineWidth<br> Arc</p>\n<p> function Line( config ) {</p>\n<p> }<br> Line.prototype = {</p>\n<pre><code>stroke: function () {\n\n}\n</code></pre><p> }</p>\n</li>\n</ol>\n<ol>\n<li><p>canvas 的状态<br> 在 Canvas 中凡是设置了属性效果, 都会延续到后面一次修改<br> Canvas 在创建出来的时候, 是有一个默认的状态的<br> 我希望每次修改状态的时候 都是不影响原来默认状态的<br> 每次画完图时, 我都会新建一个状态, 然后绘制完成后<br> 恢复到原有状态</p>\n<p> ctx.save()        将当前状态保存<br> ctx.restore()     将保存的状态恢复</p>\n<p> 状态栈</p>\n</li>\n<li><p>在 canvas 绘制的时候允许使用 canvas 绘制 canvas</p>\n<p> ctx.darwImage( img, … )</p>\n<p> 此时 img 可以是 图片, 还可以是 canvas, 甚至是 video</p>\n</li>\n</ol>\n<ol>\n<li>Konva 是一个完全面向对象的框架<br> 将所有的东西都看做是对象: 图片, 直线, 矩形, …<br> 将整个canvas看做成舞台(stage)<br> 在舞台上放一个层, 那么将所有的图形放在这个层中</li>\n</ol>\n<pre><code>命名空间\n\nvar num = 123;\nfunction foo() {}\n// 污染全局作用域\nvar Itcast = {};\n\nItcast.num = 123;\nItcast.foo = function () {};\n</code></pre><ol>\n<li><p>获取当前字体大小的情况下某些文字占用的宽度和高度<br> ctx.font = “20px”;<br> var obj = ctx.measureText(“你好”);<br> obj.width  obj.height</p>\n</li>\n<li><p>在canvas里面绘制图片：<br> A.创建一个图片对象<br>   var img = new Image();//创建一个图片对象<br>   img.src = ‘1.jpg’;</p>\n<p> B.等图片对象加载完成以后，将图片对象绘制到canvas里面去<br>   //等待img对象加载完成以后，执行函数<br>   img.onload = function(){</p>\n<pre><code>//1.将图片绘制到canvas里面的坐标0，0处\nctx.drawImage( img , 0 , 0 );\n\n//2.将图片绘制到canvas里面的坐标0,0处，并且图片大小为width,height\nctx.drawImage( img , 0, 0, width, height);\n\n//3.将图片img的sx,sy坐标处的sw,sh大小的图片区域绘制到canvas里面的x,y坐标处的大小为w,h            //的区域中\nctx.drawImage( img , sx,sy,sw,sh,  x,y,w,h);\n</code></pre><p>   }</p>\n</li>\n</ol>\n<ol>\n<li>变换的概念：<br>我们现在的canvas绘图都是通过坐标来进行绘制。<br>所谓的坐标就是canvas坐标系中的一个点。<br>canvas的坐标系可以通过变换来进行改变，当canvas的坐标系发生了改变的时候，坐标点也会跟着发生改变。<br>最后我们可以通过变换来画出一些比较好看的图形。</li>\n</ol>\n<pre><code>变换的api方法：\n    A.translate(x,y);//平移变换，\n    B.rotate(deg);//旋转坐标系，旋转deg度\n    C.scale(2,0.5);//缩放变换,  x轴放大2倍，y轴缩小一半\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>#### </p>\n<ol>\n<li>图片绘制<br> 创建图片元素<br> document.createElement( ‘img’ )<br> var img = new Image();<br> img.src = ‘’;资源图片的路径。<br> ctx.drawImage()<br> 有三种调用形式<br> 1&gt; ctx.drawImage( img, x, y ) 将 image 绘制到 x, y 表示的位置<br> 2&gt; ctx.drawImage( img, x, y, width, height ) 将 img 绘制到一个矩形区域内<br> 说明，前面的x，y为绘制起始的位置，后面的width和height是图片显示的大小。<br> 这里可以使x,y加一个数字实现叠图的效果。<br> 3&gt; ctx.drawImage( img, sx, sy, sw, sh, x, y, w, h )<pre><code>将图片 img 的 sx, sy, sw, sh 部分的内容绘制到画布的x, y, w, h 的矩形区域内.\n</code></pre> 说明sx,sy是资源图片的起始位置，sw,sh资源图片的宽高，x,y目标显示起始坐标，目标显示宽高。</li>\n</ol>\n<ol>\n<li><p>计时器模型<br> var id = setInterval(function () {</p>\n<pre><code>if ( 条件 ) {\n\n    clearInterval( id );\n}\n</code></pre></li>\n</ol>\n<pre><code>    // 继续执行我的内容\n\n}, 20);\n知识点：ctx.clearRect( 0, 0, cas.width, cas.height );擦除整个画布。\n动画：核心代码参考\n&lt;script&gt;\n    function toAngle( radian ) {\n        return radian * 180 / Math.PI;\n    }\n    function toRadian( angle ) {\n        return angle * Math.PI / 180;\n    }\n    var cas = document.getElementById( &apos;cas&apos; );\n    var ctx = cas.getContext( &apos;2d&apos; );\n    var img = new Image();\n    img.src = &apos;NPCrabbitbaby-2.png&apos;;\n    img.onload = function() {\n        var width = img.width / 4;\n        var height = img.height / 4;\n        var i = 0;\n        setInterval(function() {\n        ctx.clearRect( 0, 0, cas.width, cas.height );\n        ctx.drawImage( img, i*width,0,width,height,100,100,width,height);\n        if ( i == 3) {\n            i = 0;\n        } else {\n            i++;\n        }\n    },200);\n</code></pre><p>}</p>\n<ol>\n<li><p>变换的概念<br> 计算机绘图是利用坐标进行绘图. 绘制任何图形都和坐标系的结构息息相关.</p>\n<p> 所谓的变换就是一套数学公式, 可以记录坐标轴的变化方式.<br> 利用坐标轴的变换可以绘制出, 根据不同坐标轴特点而形成的图形.</p>\n<p> 基本的 api<br> ctx.translate(x,y)        平移变换<br> ctx.rotate(reg)        旋转变换<br> ctx.scale(x,y)            伸缩变换</p>\n</li>\n</ol>\n<ol>\n<li><p>封装绘图对象<br> Line<br> Rect<br> Circle    x, y, radius, strokeStyle, fillStyle, lineWidth<br> Arc</p>\n<p> function Line( config ) {</p>\n<p> }<br> Line.prototype = {</p>\n<pre><code>stroke: function () {\n\n}\n</code></pre><p> }</p>\n</li>\n</ol>\n<ol>\n<li><p>canvas 的状态<br> 在 Canvas 中凡是设置了属性效果, 都会延续到后面一次修改<br> Canvas 在创建出来的时候, 是有一个默认的状态的<br> 我希望每次修改状态的时候 都是不影响原来默认状态的<br> 每次画完图时, 我都会新建一个状态, 然后绘制完成后<br> 恢复到原有状态</p>\n<p> ctx.save()        将当前状态保存<br> ctx.restore()     将保存的状态恢复</p>\n<p> 状态栈</p>\n</li>\n<li><p>在 canvas 绘制的时候允许使用 canvas 绘制 canvas</p>\n<p> ctx.darwImage( img, … )</p>\n<p> 此时 img 可以是 图片, 还可以是 canvas, 甚至是 video</p>\n</li>\n</ol>\n<ol>\n<li>Konva 是一个完全面向对象的框架<br> 将所有的东西都看做是对象: 图片, 直线, 矩形, …<br> 将整个canvas看做成舞台(stage)<br> 在舞台上放一个层, 那么将所有的图形放在这个层中</li>\n</ol>\n<pre><code>命名空间\n\nvar num = 123;\nfunction foo() {}\n// 污染全局作用域\nvar Itcast = {};\n\nItcast.num = 123;\nItcast.foo = function () {};\n</code></pre><ol>\n<li><p>获取当前字体大小的情况下某些文字占用的宽度和高度<br> ctx.font = “20px”;<br> var obj = ctx.measureText(“你好”);<br> obj.width  obj.height</p>\n</li>\n<li><p>在canvas里面绘制图片：<br> A.创建一个图片对象<br>   var img = new Image();//创建一个图片对象<br>   img.src = ‘1.jpg’;</p>\n<p> B.等图片对象加载完成以后，将图片对象绘制到canvas里面去<br>   //等待img对象加载完成以后，执行函数<br>   img.onload = function(){</p>\n<pre><code>//1.将图片绘制到canvas里面的坐标0，0处\nctx.drawImage( img , 0 , 0 );\n\n//2.将图片绘制到canvas里面的坐标0,0处，并且图片大小为width,height\nctx.drawImage( img , 0, 0, width, height);\n\n//3.将图片img的sx,sy坐标处的sw,sh大小的图片区域绘制到canvas里面的x,y坐标处的大小为w,h            //的区域中\nctx.drawImage( img , sx,sy,sw,sh,  x,y,w,h);\n</code></pre><p>   }</p>\n</li>\n</ol>\n<ol>\n<li>变换的概念：<br>我们现在的canvas绘图都是通过坐标来进行绘制。<br>所谓的坐标就是canvas坐标系中的一个点。<br>canvas的坐标系可以通过变换来进行改变，当canvas的坐标系发生了改变的时候，坐标点也会跟着发生改变。<br>最后我们可以通过变换来画出一些比较好看的图形。</li>\n</ol>\n<pre><code>变换的api方法：\n    A.translate(x,y);//平移变换，\n    B.rotate(deg);//旋转坐标系，旋转deg度\n    C.scale(2,0.5);//缩放变换,  x轴放大2倍，y轴缩小一半\n</code></pre>"},{"title":"canvas基础二","_content":"#### 1. 绘制折线图\n\t假设有点: ( 10, 20 ), ( 15, 13 ), ( 17, 30 ), ( 30, 10 ), ( 20, 15 )\n\t将这些点绘制到坐标轴中.\n\n#### 2. 绘制形状\n\t-> 矩形\n\t\tctx.rect( x, y, width, heigth )\t\t描边, 需要 stroke 或 fill\n\t\tctx.strokeRect( x, y, w, h )\n\t\tctx.fillRect( x, y, w, h )\n\t\tctx.clearRect( x, y, w, h ) \t\t清除该矩形区域的内容\n\n\t-> 清除整个画布\n\t\tctx.clearRect( 0, 0, cas.width, cas.height );\n\n\t\tcas.width = cas.width;\n\n\t-> 圆弧\n\t\tctx.arc( x, y, r, startAngle, endAngle, clockwise )\n\t\tctx.arcTo() 了解\n\t\t参数:x,y圆心 r半径，startAngle起始弧度，endAngle结束弧度，clockwise画圆方向（顺时针或者你时针）\n\t-> 圆\n\t\tctx.arc( x, y, r, 0, 2 * Math.PI )\n\n\n#### 3. 弧度制\n\t为了更好的计算角度, 我们该角度提供一个新的定义, 用 PI 作为单位\n\t将单位圆的一个整圈( 360 度 )记作 2 倍 的 PI.\n\n\t这样的度量表示就是弧度制的表示方法.\n\n\t60 度 PI / 3\n\t45 度 PI / 4\n\t30 度 PI / 6\n\n\t学会进行转换\n\n\t2 PI 刚好是一圈\n\t一圈又是 360 度\n\n\t2 PI 比上 360 度 = 弧度 比上 对应的角度\n\n\tangle 角度\n\tradian 弧度\n\n\tfunction toAngle ( radian ) {\n\t\treturn radian * 180 / Math.PI; \n\t}\n\tfunction toRadian ( angle ) {\n\t\treturn angle * Math.PI / 180;\n\t}\n\n#### 4. 角度的坐标\n\t水平向右的角度是 0 度, 或 0 弧度\n\t顺时针是正方向, 逆时针是负方向\n\n\t练习: 绘制出, 圆心在 canva 正中心, 半径为 100, 角度从 -60度 到 120 度的圆弧\n\n#### 5. 如果没有当前位置, 绘制圆弧是没有任何问题\n\t但是如果有了当前位置, 绘制圆弧的时候会将当前位置连接到圆弧上\n\n#### 6. 计算在圆弧上的点的坐标\n\n#### 7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)\n\n#### 8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆\n\n#### 9. 绘制文字\n\tctx.fillText( 文本内容, x, y )\n\tctx.strokeText( 文本内容, x, y );\n\n\t常用的属性\n\tctx.font = '30px 黑体'\n\n\tctx.textAlign\t\tleft, center, right.\tstart, end\n\tctx.textBaseline\ttop, middle, bottom.\thanging, ideographics, alphabetic\n\n\tctx.measureText( 文本 )\t\t获取当前文字的字体设置下, 文字的宽度对象\n\n\n\n\n1. 绘制矩形的方法：\n\tA.rect(x,y,width,height);//rect方法只是打草稿，必须配合stroke()或fill()方法来绘制图形\n\tB.strokeRect(x,y,width,height);//绘制空心矩形\n\tC.fillRect(x,y,width,height);//绘制填充矩形。\n\n2. 清除矩形区域：\n\t//擦除从x,y坐标开始的矩形区域，这个区域的大小由width，height来决定\n\tctx.clearRect(x,y,width,height);\n\n3. 清除整个画布的内容：\n\tA.  ctx.clearRect(0,0,canvas.width,canvas.height);\n\tB.  canvas.width = canvas.width;\n\n4. 绘制圆弧的方法：\n\tA.\n\tctx.arc( 圆心坐标x,圆心坐标y, 圆弧的半径，圆弧开始的弧度,圆弧结束的弧度,圆绘制的方向 );\n\tctx.arc(100,100,50,0,2*Math.PI,true);\n\n\tctx.stroke();\n\n\tB.\n\tctx.moveTo(x0,y0);\n\tctx.arcTo(x1,y1,x2,y2,半径);\n\t//从x0,y0的点拉一条线到x1,y1  再从x1,y1拉一条线到x2,y2.\n\t//以半径绘制两条线的相切圆。\n\t\n\n5. 弧度制：为了能够更好的表示的角度，\n如果是360度就记做  2*PI\n\n6. 圆弧的0度角在圆心水平向右。\n  0度角顺时针是角度的正方向\n  0独角逆时针是角度的逆方向\n\n7. 当我们绘制圆弧的时候，有一个特性：\n\t会将圆弧的起始点和moveTo的定点连接起来\n\n8. 计算圆弧上坐标点的公式：\n\tx = 圆心坐标x + 半径 * Math.cos(   toRadian(角度));\n\ty = 圆心坐标y + 半径 * Math.sin(   toRadian(角度));\n\n9. 绘制扇形的步骤：\n\tA.moveTo到圆心\n\tB.绘制圆弧\n\tC.ctx.closePath()\n\n\n10. 数据饼形图：\n\n\n11. 绘制文本的方法：\n\tA.ctx.fillText(文本字符串,x,y);\n\tB.ctx.strokeText(文本字符串,x,y);\n\n注意：绘制的文本字符串会绘制在x,y坐标处，文字内容左下角对齐x,y坐标点。\n\n设置绘制文字的尺寸：\n\tctx.font = \"30px 黑体\";\n设置绘制文字的水平对齐：\n\tctx.textAlign = 'left';//left,center,right\n设置绘制文字的垂直对齐：\n\tctx.textBaseline = \"top\";//top,middle,bottom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/canvas第二天.md","raw":"---\ntitle: canvas基础二\ncategories: ['前端']\ntags: ['canvas'] \n---\n#### 1. 绘制折线图\n\t假设有点: ( 10, 20 ), ( 15, 13 ), ( 17, 30 ), ( 30, 10 ), ( 20, 15 )\n\t将这些点绘制到坐标轴中.\n\n#### 2. 绘制形状\n\t-> 矩形\n\t\tctx.rect( x, y, width, heigth )\t\t描边, 需要 stroke 或 fill\n\t\tctx.strokeRect( x, y, w, h )\n\t\tctx.fillRect( x, y, w, h )\n\t\tctx.clearRect( x, y, w, h ) \t\t清除该矩形区域的内容\n\n\t-> 清除整个画布\n\t\tctx.clearRect( 0, 0, cas.width, cas.height );\n\n\t\tcas.width = cas.width;\n\n\t-> 圆弧\n\t\tctx.arc( x, y, r, startAngle, endAngle, clockwise )\n\t\tctx.arcTo() 了解\n\t\t参数:x,y圆心 r半径，startAngle起始弧度，endAngle结束弧度，clockwise画圆方向（顺时针或者你时针）\n\t-> 圆\n\t\tctx.arc( x, y, r, 0, 2 * Math.PI )\n\n\n#### 3. 弧度制\n\t为了更好的计算角度, 我们该角度提供一个新的定义, 用 PI 作为单位\n\t将单位圆的一个整圈( 360 度 )记作 2 倍 的 PI.\n\n\t这样的度量表示就是弧度制的表示方法.\n\n\t60 度 PI / 3\n\t45 度 PI / 4\n\t30 度 PI / 6\n\n\t学会进行转换\n\n\t2 PI 刚好是一圈\n\t一圈又是 360 度\n\n\t2 PI 比上 360 度 = 弧度 比上 对应的角度\n\n\tangle 角度\n\tradian 弧度\n\n\tfunction toAngle ( radian ) {\n\t\treturn radian * 180 / Math.PI; \n\t}\n\tfunction toRadian ( angle ) {\n\t\treturn angle * Math.PI / 180;\n\t}\n\n#### 4. 角度的坐标\n\t水平向右的角度是 0 度, 或 0 弧度\n\t顺时针是正方向, 逆时针是负方向\n\n\t练习: 绘制出, 圆心在 canva 正中心, 半径为 100, 角度从 -60度 到 120 度的圆弧\n\n#### 5. 如果没有当前位置, 绘制圆弧是没有任何问题\n\t但是如果有了当前位置, 绘制圆弧的时候会将当前位置连接到圆弧上\n\n#### 6. 计算在圆弧上的点的坐标\n\n#### 7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)\n\n#### 8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆\n\n#### 9. 绘制文字\n\tctx.fillText( 文本内容, x, y )\n\tctx.strokeText( 文本内容, x, y );\n\n\t常用的属性\n\tctx.font = '30px 黑体'\n\n\tctx.textAlign\t\tleft, center, right.\tstart, end\n\tctx.textBaseline\ttop, middle, bottom.\thanging, ideographics, alphabetic\n\n\tctx.measureText( 文本 )\t\t获取当前文字的字体设置下, 文字的宽度对象\n\n\n\n\n1. 绘制矩形的方法：\n\tA.rect(x,y,width,height);//rect方法只是打草稿，必须配合stroke()或fill()方法来绘制图形\n\tB.strokeRect(x,y,width,height);//绘制空心矩形\n\tC.fillRect(x,y,width,height);//绘制填充矩形。\n\n2. 清除矩形区域：\n\t//擦除从x,y坐标开始的矩形区域，这个区域的大小由width，height来决定\n\tctx.clearRect(x,y,width,height);\n\n3. 清除整个画布的内容：\n\tA.  ctx.clearRect(0,0,canvas.width,canvas.height);\n\tB.  canvas.width = canvas.width;\n\n4. 绘制圆弧的方法：\n\tA.\n\tctx.arc( 圆心坐标x,圆心坐标y, 圆弧的半径，圆弧开始的弧度,圆弧结束的弧度,圆绘制的方向 );\n\tctx.arc(100,100,50,0,2*Math.PI,true);\n\n\tctx.stroke();\n\n\tB.\n\tctx.moveTo(x0,y0);\n\tctx.arcTo(x1,y1,x2,y2,半径);\n\t//从x0,y0的点拉一条线到x1,y1  再从x1,y1拉一条线到x2,y2.\n\t//以半径绘制两条线的相切圆。\n\t\n\n5. 弧度制：为了能够更好的表示的角度，\n如果是360度就记做  2*PI\n\n6. 圆弧的0度角在圆心水平向右。\n  0度角顺时针是角度的正方向\n  0独角逆时针是角度的逆方向\n\n7. 当我们绘制圆弧的时候，有一个特性：\n\t会将圆弧的起始点和moveTo的定点连接起来\n\n8. 计算圆弧上坐标点的公式：\n\tx = 圆心坐标x + 半径 * Math.cos(   toRadian(角度));\n\ty = 圆心坐标y + 半径 * Math.sin(   toRadian(角度));\n\n9. 绘制扇形的步骤：\n\tA.moveTo到圆心\n\tB.绘制圆弧\n\tC.ctx.closePath()\n\n\n10. 数据饼形图：\n\n\n11. 绘制文本的方法：\n\tA.ctx.fillText(文本字符串,x,y);\n\tB.ctx.strokeText(文本字符串,x,y);\n\n注意：绘制的文本字符串会绘制在x,y坐标处，文字内容左下角对齐x,y坐标点。\n\n设置绘制文字的尺寸：\n\tctx.font = \"30px 黑体\";\n设置绘制文字的水平对齐：\n\tctx.textAlign = 'left';//left,center,right\n设置绘制文字的垂直对齐：\n\tctx.textBaseline = \"top\";//top,middle,bottom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"canvas第二天","published":1,"date":"2017-01-09T12:18:33.000Z","updated":"2019-04-26T06:46:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gq00077xuq2crpcbz1","content":"<h4 id=\"1-绘制折线图\"><a href=\"#1-绘制折线图\" class=\"headerlink\" title=\"1. 绘制折线图\"></a>1. 绘制折线图</h4><pre><code>假设有点: ( 10, 20 ), ( 15, 13 ), ( 17, 30 ), ( 30, 10 ), ( 20, 15 )\n将这些点绘制到坐标轴中.\n</code></pre><h4 id=\"2-绘制形状\"><a href=\"#2-绘制形状\" class=\"headerlink\" title=\"2. 绘制形状\"></a>2. 绘制形状</h4><pre><code>-&gt; 矩形\n    ctx.rect( x, y, width, heigth )        描边, 需要 stroke 或 fill\n    ctx.strokeRect( x, y, w, h )\n    ctx.fillRect( x, y, w, h )\n    ctx.clearRect( x, y, w, h )         清除该矩形区域的内容\n\n-&gt; 清除整个画布\n    ctx.clearRect( 0, 0, cas.width, cas.height );\n\n    cas.width = cas.width;\n\n-&gt; 圆弧\n    ctx.arc( x, y, r, startAngle, endAngle, clockwise )\n    ctx.arcTo() 了解\n    参数:x,y圆心 r半径，startAngle起始弧度，endAngle结束弧度，clockwise画圆方向（顺时针或者你时针）\n-&gt; 圆\n    ctx.arc( x, y, r, 0, 2 * Math.PI )\n</code></pre><h4 id=\"3-弧度制\"><a href=\"#3-弧度制\" class=\"headerlink\" title=\"3. 弧度制\"></a>3. 弧度制</h4><pre><code>为了更好的计算角度, 我们该角度提供一个新的定义, 用 PI 作为单位\n将单位圆的一个整圈( 360 度 )记作 2 倍 的 PI.\n\n这样的度量表示就是弧度制的表示方法.\n\n60 度 PI / 3\n45 度 PI / 4\n30 度 PI / 6\n\n学会进行转换\n\n2 PI 刚好是一圈\n一圈又是 360 度\n\n2 PI 比上 360 度 = 弧度 比上 对应的角度\n\nangle 角度\nradian 弧度\n\nfunction toAngle ( radian ) {\n    return radian * 180 / Math.PI; \n}\nfunction toRadian ( angle ) {\n    return angle * Math.PI / 180;\n}\n</code></pre><h4 id=\"4-角度的坐标\"><a href=\"#4-角度的坐标\" class=\"headerlink\" title=\"4. 角度的坐标\"></a>4. 角度的坐标</h4><pre><code>水平向右的角度是 0 度, 或 0 弧度\n顺时针是正方向, 逆时针是负方向\n\n练习: 绘制出, 圆心在 canva 正中心, 半径为 100, 角度从 -60度 到 120 度的圆弧\n</code></pre><h4 id=\"5-如果没有当前位置-绘制圆弧是没有任何问题\"><a href=\"#5-如果没有当前位置-绘制圆弧是没有任何问题\" class=\"headerlink\" title=\"5. 如果没有当前位置, 绘制圆弧是没有任何问题\"></a>5. 如果没有当前位置, 绘制圆弧是没有任何问题</h4><pre><code>但是如果有了当前位置, 绘制圆弧的时候会将当前位置连接到圆弧上\n</code></pre><h4 id=\"6-计算在圆弧上的点的坐标\"><a href=\"#6-计算在圆弧上的点的坐标\" class=\"headerlink\" title=\"6. 计算在圆弧上的点的坐标\"></a>6. 计算在圆弧上的点的坐标</h4><h4 id=\"7-根据固定到起始点到-圆心-结合圆弧和-closePath-方法可以绘制扇形-楔形-Wedge\"><a href=\"#7-根据固定到起始点到-圆心-结合圆弧和-closePath-方法可以绘制扇形-楔形-Wedge\" class=\"headerlink\" title=\"7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)\"></a>7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)</h4><h4 id=\"8-动态的通过动画-一点一点的添加角度-然后绘制一整个圆\"><a href=\"#8-动态的通过动画-一点一点的添加角度-然后绘制一整个圆\" class=\"headerlink\" title=\"8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆\"></a>8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆</h4><h4 id=\"9-绘制文字\"><a href=\"#9-绘制文字\" class=\"headerlink\" title=\"9. 绘制文字\"></a>9. 绘制文字</h4><pre><code>ctx.fillText( 文本内容, x, y )\nctx.strokeText( 文本内容, x, y );\n\n常用的属性\nctx.font = &apos;30px 黑体&apos;\n\nctx.textAlign        left, center, right.    start, end\nctx.textBaseline    top, middle, bottom.    hanging, ideographics, alphabetic\n\nctx.measureText( 文本 )        获取当前文字的字体设置下, 文字的宽度对象\n</code></pre><ol>\n<li><p>绘制矩形的方法：<br> A.rect(x,y,width,height);//rect方法只是打草稿，必须配合stroke()或fill()方法来绘制图形<br> B.strokeRect(x,y,width,height);//绘制空心矩形<br> C.fillRect(x,y,width,height);//绘制填充矩形。</p>\n</li>\n<li><p>清除矩形区域：<br> //擦除从x,y坐标开始的矩形区域，这个区域的大小由width，height来决定<br> ctx.clearRect(x,y,width,height);</p>\n</li>\n<li><p>清除整个画布的内容：<br> A.  ctx.clearRect(0,0,canvas.width,canvas.height);<br> B.  canvas.width = canvas.width;</p>\n</li>\n<li><p>绘制圆弧的方法：<br> A.<br> ctx.arc( 圆心坐标x,圆心坐标y, 圆弧的半径，圆弧开始的弧度,圆弧结束的弧度,圆绘制的方向 );<br> ctx.arc(100,100,50,0,2*Math.PI,true);</p>\n<p> ctx.stroke();</p>\n<p> B.<br> ctx.moveTo(x0,y0);<br> ctx.arcTo(x1,y1,x2,y2,半径);<br> //从x0,y0的点拉一条线到x1,y1  再从x1,y1拉一条线到x2,y2.<br> //以半径绘制两条线的相切圆。</p>\n</li>\n</ol>\n<ol>\n<li><p>弧度制：为了能够更好的表示的角度，<br>如果是360度就记做  2*PI</p>\n</li>\n<li><p>圆弧的0度角在圆心水平向右。<br>0度角顺时针是角度的正方向<br>0独角逆时针是角度的逆方向</p>\n</li>\n<li><p>当我们绘制圆弧的时候，有一个特性：<br> 会将圆弧的起始点和moveTo的定点连接起来</p>\n</li>\n<li><p>计算圆弧上坐标点的公式：<br> x = 圆心坐标x + 半径 <em> Math.cos(   toRadian(角度));<br> y = 圆心坐标y + 半径 </em> Math.sin(   toRadian(角度));</p>\n</li>\n<li><p>绘制扇形的步骤：<br> A.moveTo到圆心<br> B.绘制圆弧<br> C.ctx.closePath()</p>\n</li>\n</ol>\n<ol>\n<li>数据饼形图：</li>\n</ol>\n<ol>\n<li>绘制文本的方法：<br>A.ctx.fillText(文本字符串,x,y);<br>B.ctx.strokeText(文本字符串,x,y);</li>\n</ol>\n<p>注意：绘制的文本字符串会绘制在x,y坐标处，文字内容左下角对齐x,y坐标点。</p>\n<p>设置绘制文字的尺寸：<br>    ctx.font = “30px 黑体”;<br>设置绘制文字的水平对齐：<br>    ctx.textAlign = ‘left’;//left,center,right<br>设置绘制文字的垂直对齐：<br>    ctx.textBaseline = “top”;//top,middle,bottom</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-绘制折线图\"><a href=\"#1-绘制折线图\" class=\"headerlink\" title=\"1. 绘制折线图\"></a>1. 绘制折线图</h4><pre><code>假设有点: ( 10, 20 ), ( 15, 13 ), ( 17, 30 ), ( 30, 10 ), ( 20, 15 )\n将这些点绘制到坐标轴中.\n</code></pre><h4 id=\"2-绘制形状\"><a href=\"#2-绘制形状\" class=\"headerlink\" title=\"2. 绘制形状\"></a>2. 绘制形状</h4><pre><code>-&gt; 矩形\n    ctx.rect( x, y, width, heigth )        描边, 需要 stroke 或 fill\n    ctx.strokeRect( x, y, w, h )\n    ctx.fillRect( x, y, w, h )\n    ctx.clearRect( x, y, w, h )         清除该矩形区域的内容\n\n-&gt; 清除整个画布\n    ctx.clearRect( 0, 0, cas.width, cas.height );\n\n    cas.width = cas.width;\n\n-&gt; 圆弧\n    ctx.arc( x, y, r, startAngle, endAngle, clockwise )\n    ctx.arcTo() 了解\n    参数:x,y圆心 r半径，startAngle起始弧度，endAngle结束弧度，clockwise画圆方向（顺时针或者你时针）\n-&gt; 圆\n    ctx.arc( x, y, r, 0, 2 * Math.PI )\n</code></pre><h4 id=\"3-弧度制\"><a href=\"#3-弧度制\" class=\"headerlink\" title=\"3. 弧度制\"></a>3. 弧度制</h4><pre><code>为了更好的计算角度, 我们该角度提供一个新的定义, 用 PI 作为单位\n将单位圆的一个整圈( 360 度 )记作 2 倍 的 PI.\n\n这样的度量表示就是弧度制的表示方法.\n\n60 度 PI / 3\n45 度 PI / 4\n30 度 PI / 6\n\n学会进行转换\n\n2 PI 刚好是一圈\n一圈又是 360 度\n\n2 PI 比上 360 度 = 弧度 比上 对应的角度\n\nangle 角度\nradian 弧度\n\nfunction toAngle ( radian ) {\n    return radian * 180 / Math.PI; \n}\nfunction toRadian ( angle ) {\n    return angle * Math.PI / 180;\n}\n</code></pre><h4 id=\"4-角度的坐标\"><a href=\"#4-角度的坐标\" class=\"headerlink\" title=\"4. 角度的坐标\"></a>4. 角度的坐标</h4><pre><code>水平向右的角度是 0 度, 或 0 弧度\n顺时针是正方向, 逆时针是负方向\n\n练习: 绘制出, 圆心在 canva 正中心, 半径为 100, 角度从 -60度 到 120 度的圆弧\n</code></pre><h4 id=\"5-如果没有当前位置-绘制圆弧是没有任何问题\"><a href=\"#5-如果没有当前位置-绘制圆弧是没有任何问题\" class=\"headerlink\" title=\"5. 如果没有当前位置, 绘制圆弧是没有任何问题\"></a>5. 如果没有当前位置, 绘制圆弧是没有任何问题</h4><pre><code>但是如果有了当前位置, 绘制圆弧的时候会将当前位置连接到圆弧上\n</code></pre><h4 id=\"6-计算在圆弧上的点的坐标\"><a href=\"#6-计算在圆弧上的点的坐标\" class=\"headerlink\" title=\"6. 计算在圆弧上的点的坐标\"></a>6. 计算在圆弧上的点的坐标</h4><h4 id=\"7-根据固定到起始点到-圆心-结合圆弧和-closePath-方法可以绘制扇形-楔形-Wedge\"><a href=\"#7-根据固定到起始点到-圆心-结合圆弧和-closePath-方法可以绘制扇形-楔形-Wedge\" class=\"headerlink\" title=\"7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)\"></a>7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)</h4><h4 id=\"8-动态的通过动画-一点一点的添加角度-然后绘制一整个圆\"><a href=\"#8-动态的通过动画-一点一点的添加角度-然后绘制一整个圆\" class=\"headerlink\" title=\"8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆\"></a>8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆</h4><h4 id=\"9-绘制文字\"><a href=\"#9-绘制文字\" class=\"headerlink\" title=\"9. 绘制文字\"></a>9. 绘制文字</h4><pre><code>ctx.fillText( 文本内容, x, y )\nctx.strokeText( 文本内容, x, y );\n\n常用的属性\nctx.font = &apos;30px 黑体&apos;\n\nctx.textAlign        left, center, right.    start, end\nctx.textBaseline    top, middle, bottom.    hanging, ideographics, alphabetic\n\nctx.measureText( 文本 )        获取当前文字的字体设置下, 文字的宽度对象\n</code></pre><ol>\n<li><p>绘制矩形的方法：<br> A.rect(x,y,width,height);//rect方法只是打草稿，必须配合stroke()或fill()方法来绘制图形<br> B.strokeRect(x,y,width,height);//绘制空心矩形<br> C.fillRect(x,y,width,height);//绘制填充矩形。</p>\n</li>\n<li><p>清除矩形区域：<br> //擦除从x,y坐标开始的矩形区域，这个区域的大小由width，height来决定<br> ctx.clearRect(x,y,width,height);</p>\n</li>\n<li><p>清除整个画布的内容：<br> A.  ctx.clearRect(0,0,canvas.width,canvas.height);<br> B.  canvas.width = canvas.width;</p>\n</li>\n<li><p>绘制圆弧的方法：<br> A.<br> ctx.arc( 圆心坐标x,圆心坐标y, 圆弧的半径，圆弧开始的弧度,圆弧结束的弧度,圆绘制的方向 );<br> ctx.arc(100,100,50,0,2*Math.PI,true);</p>\n<p> ctx.stroke();</p>\n<p> B.<br> ctx.moveTo(x0,y0);<br> ctx.arcTo(x1,y1,x2,y2,半径);<br> //从x0,y0的点拉一条线到x1,y1  再从x1,y1拉一条线到x2,y2.<br> //以半径绘制两条线的相切圆。</p>\n</li>\n</ol>\n<ol>\n<li><p>弧度制：为了能够更好的表示的角度，<br>如果是360度就记做  2*PI</p>\n</li>\n<li><p>圆弧的0度角在圆心水平向右。<br>0度角顺时针是角度的正方向<br>0独角逆时针是角度的逆方向</p>\n</li>\n<li><p>当我们绘制圆弧的时候，有一个特性：<br> 会将圆弧的起始点和moveTo的定点连接起来</p>\n</li>\n<li><p>计算圆弧上坐标点的公式：<br> x = 圆心坐标x + 半径 <em> Math.cos(   toRadian(角度));<br> y = 圆心坐标y + 半径 </em> Math.sin(   toRadian(角度));</p>\n</li>\n<li><p>绘制扇形的步骤：<br> A.moveTo到圆心<br> B.绘制圆弧<br> C.ctx.closePath()</p>\n</li>\n</ol>\n<ol>\n<li>数据饼形图：</li>\n</ol>\n<ol>\n<li>绘制文本的方法：<br>A.ctx.fillText(文本字符串,x,y);<br>B.ctx.strokeText(文本字符串,x,y);</li>\n</ol>\n<p>注意：绘制的文本字符串会绘制在x,y坐标处，文字内容左下角对齐x,y坐标点。</p>\n<p>设置绘制文字的尺寸：<br>    ctx.font = “30px 黑体”;<br>设置绘制文字的水平对齐：<br>    ctx.textAlign = ‘left’;//left,center,right<br>设置绘制文字的垂直对齐：<br>    ctx.textBaseline = “top”;//top,middle,bottom</p>\n"},{"title":"git","_content":"## Git\n\n### 什么是Git?\n  - Git是一款源代码管理工具(版本控制工具)\n    - 我们写的代码需要使用Git进行管理。\n  1.0是稳定\n  2.0加了新功能\n  - 源代码有必要管理起吗？\n  - 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。\n  - svn,vss,vcs,tfs.....\n  -Git是linux之父当年为了维护linux---linus之前也是手动维护合并把文件发给Linus\n  - BitKeeper(收费)\n  - 有人想破解(不给提供免费使用)\n  - linus自己写了一个版本管理的工具（Git）\n\n\n### 分布式版本管理工具，集中式\n  - git属于分布式\n  - svn集中式\n\n### git安装\n\n### git初始化一个仓库\n  - 其实就是创建了一个.git隐藏目录\n  - 命令:` git init `;\n    + 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令.\n    + 一般是在项目的根目录执行这个命令.\n\n\n### 自报家门\n  - 配置用户名 : `git config user.name \"testName\"`\n  - 配置全局用户名 : `git config --global user.name \"testName\"`\n  - 配置邮箱   : `git config user.email \"test@sina.com\"`\n  - 配置邮箱   : `git config --global user.email \"test@sina.com\"`\n  - 查看配置信息: `git config --list`\n\n\n### 把代码提交到仓库中\n  - 1.先把代码添加到暂存区(就相当于放到仓库门口)\n    + 命令:`git add 文件路径/文件名`\n    + 示例:`git add ./reademe.md`\n    + 可以使用`git add .`这个命令，批量把当前目录下所有修改过的文件添加到暂存区。\n\n  - 2.把暂存区的文件提交仓库里\n    + 命令: `git commit -m \"注释\" `\n    + 示例: `git commit -m \"我们添加了一个新的功能\"`\n    + -m 表示指定一个字符串，作为提交的说明(相当于注释);\n\n  - 合并add 与commit 命令\n    + `git commit -a -m \"这是使用合并添加与提交的操作\"`;\n    + 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用)\n\n\n### 查看工作区状态\n  - 命令:`git status`\n\n\n### 添加忽略文件\n  - 在项目中有一些文件是不需要提交的,我们需要把它忽略掉\n  - 需要在.git文件夹所在目录新建一个名为.gitignore的文件\n    然后在这个文件中写上需要被忽略的文件的路径。\n    示例: /css/a.css\n        : /css/*.css\n        : /a.html\n\n\n### 比对文件差异\n  - 命令: `git diff`\n    + 用来比较暂存区文件内容与工作区文件内容的区别\n    + **如果暂存区没有文件，就会将工作与代码与最近一次提交对比**\n  - 命令：`git diff --cached`  比较暂存区的文件和仓库中文件的区别\n  - 对比之前某两次提交的文件的差异\n    + 命令:`git diff [版本号1] [版本号2] [想比较的文件路径]`\n\n### 查看日志\n  - 命令:`git log`,可以查看每一次提交的日志\n  - 命令:`git log --oneline` 表示使用简洁的形式输出提交日志\n\n\n### 版本回退\n  - 命令:`git reset --hard Head~1`\n    + 这是将代码回退到上上一次提交时的状态\n  - 命令:`git reset --hard Head~2`\n    + 回退到上上上次\n  - 命令:`git reset --hard Head~0`\n    + 回退到上次提交时的状态,~0可以省略\n\n  - 命令:`git reset --hard 版本号`\n    + 通过每次提交时生成的版本号来回退版本\n\n  - 通过`git reflog`命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。\n\n### 创建分支\n  - 命令:`git branch [分支名]`\n    + 创建一个新分支\n  - 命令:`git branch`\n    + 查看当前所有的分支\n\n### 切换分支\n  - 命令:`git checkout [分支名]`\n    + 切换分支后可以在切换后的分支中进行正常的操作\n\n### 合并分支\n  - 命令:`git merge [分支名]`\n    + git会将指定的分支合并到当前分支.\n\n### 删除分支\n  - 命令:`git branch -d [分支名]`\n    + 删除指定分支，-d参数表示要执行删除操作\n\n### git提交中的冲突\n  - 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交\n\n\n## github\n### github与git\n  - git 版本管理工具\n  - github 就是一个网站，只是这个网站提供git服务器的功能\n\n\n### 上传代码到git服务器(push)\n  - 命令:`git push [远程服务器地址] [远程服务器的分支]`\n     + 示例:`git push https://github.com/huoqishi/test002.git master`\n\n  - 上传时可以使用一些简化的命令\n    + 将远程服务器地址写成变量的形式\n      * `git remote add [变量名]  [远程服务器地址]`\n      * 示例:`git remote add origin https://github.com/huoqishi/test002.git`\n      * 这样之后就可以直接使用origin来代替git push 后面写的地址了\n        `git push origin master`\n  - 还可以尽一步简化\n    + 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了`git push origin`;\n\n## git使用ssh方式上传代码与github\n  - git生成公钥和私钥\n    + 命令:`ssh-keygen -t rsa`生成的公钥与私钥文件会在当用户目录的.ssh目录下.\n\n\n### 把代码push到服务器时需要先pull一下\n  - 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。\n\n### 从服务器上pull代码到本地\n  - 如果本地没有.git目录，需要先初始化一下。\n  - 命令:`git pull [远程服务器地址] [远程的分支]`\n\n### gh-pages分支-搭建博客.\n  - 需要把自已博客的网页代码上传到github上的gh-pages分支\n  - 然后就直接访问了\n    + 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面]","source":"_posts/git.md","raw":"---\ntitle: git\ncategories: ['前端']\ntags: ['工具']\n---\n## Git\n\n### 什么是Git?\n  - Git是一款源代码管理工具(版本控制工具)\n    - 我们写的代码需要使用Git进行管理。\n  1.0是稳定\n  2.0加了新功能\n  - 源代码有必要管理起吗？\n  - 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。\n  - svn,vss,vcs,tfs.....\n  -Git是linux之父当年为了维护linux---linus之前也是手动维护合并把文件发给Linus\n  - BitKeeper(收费)\n  - 有人想破解(不给提供免费使用)\n  - linus自己写了一个版本管理的工具（Git）\n\n\n### 分布式版本管理工具，集中式\n  - git属于分布式\n  - svn集中式\n\n### git安装\n\n### git初始化一个仓库\n  - 其实就是创建了一个.git隐藏目录\n  - 命令:` git init `;\n    + 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令.\n    + 一般是在项目的根目录执行这个命令.\n\n\n### 自报家门\n  - 配置用户名 : `git config user.name \"testName\"`\n  - 配置全局用户名 : `git config --global user.name \"testName\"`\n  - 配置邮箱   : `git config user.email \"test@sina.com\"`\n  - 配置邮箱   : `git config --global user.email \"test@sina.com\"`\n  - 查看配置信息: `git config --list`\n\n\n### 把代码提交到仓库中\n  - 1.先把代码添加到暂存区(就相当于放到仓库门口)\n    + 命令:`git add 文件路径/文件名`\n    + 示例:`git add ./reademe.md`\n    + 可以使用`git add .`这个命令，批量把当前目录下所有修改过的文件添加到暂存区。\n\n  - 2.把暂存区的文件提交仓库里\n    + 命令: `git commit -m \"注释\" `\n    + 示例: `git commit -m \"我们添加了一个新的功能\"`\n    + -m 表示指定一个字符串，作为提交的说明(相当于注释);\n\n  - 合并add 与commit 命令\n    + `git commit -a -m \"这是使用合并添加与提交的操作\"`;\n    + 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用)\n\n\n### 查看工作区状态\n  - 命令:`git status`\n\n\n### 添加忽略文件\n  - 在项目中有一些文件是不需要提交的,我们需要把它忽略掉\n  - 需要在.git文件夹所在目录新建一个名为.gitignore的文件\n    然后在这个文件中写上需要被忽略的文件的路径。\n    示例: /css/a.css\n        : /css/*.css\n        : /a.html\n\n\n### 比对文件差异\n  - 命令: `git diff`\n    + 用来比较暂存区文件内容与工作区文件内容的区别\n    + **如果暂存区没有文件，就会将工作与代码与最近一次提交对比**\n  - 命令：`git diff --cached`  比较暂存区的文件和仓库中文件的区别\n  - 对比之前某两次提交的文件的差异\n    + 命令:`git diff [版本号1] [版本号2] [想比较的文件路径]`\n\n### 查看日志\n  - 命令:`git log`,可以查看每一次提交的日志\n  - 命令:`git log --oneline` 表示使用简洁的形式输出提交日志\n\n\n### 版本回退\n  - 命令:`git reset --hard Head~1`\n    + 这是将代码回退到上上一次提交时的状态\n  - 命令:`git reset --hard Head~2`\n    + 回退到上上上次\n  - 命令:`git reset --hard Head~0`\n    + 回退到上次提交时的状态,~0可以省略\n\n  - 命令:`git reset --hard 版本号`\n    + 通过每次提交时生成的版本号来回退版本\n\n  - 通过`git reflog`命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。\n\n### 创建分支\n  - 命令:`git branch [分支名]`\n    + 创建一个新分支\n  - 命令:`git branch`\n    + 查看当前所有的分支\n\n### 切换分支\n  - 命令:`git checkout [分支名]`\n    + 切换分支后可以在切换后的分支中进行正常的操作\n\n### 合并分支\n  - 命令:`git merge [分支名]`\n    + git会将指定的分支合并到当前分支.\n\n### 删除分支\n  - 命令:`git branch -d [分支名]`\n    + 删除指定分支，-d参数表示要执行删除操作\n\n### git提交中的冲突\n  - 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交\n\n\n## github\n### github与git\n  - git 版本管理工具\n  - github 就是一个网站，只是这个网站提供git服务器的功能\n\n\n### 上传代码到git服务器(push)\n  - 命令:`git push [远程服务器地址] [远程服务器的分支]`\n     + 示例:`git push https://github.com/huoqishi/test002.git master`\n\n  - 上传时可以使用一些简化的命令\n    + 将远程服务器地址写成变量的形式\n      * `git remote add [变量名]  [远程服务器地址]`\n      * 示例:`git remote add origin https://github.com/huoqishi/test002.git`\n      * 这样之后就可以直接使用origin来代替git push 后面写的地址了\n        `git push origin master`\n  - 还可以尽一步简化\n    + 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了`git push origin`;\n\n## git使用ssh方式上传代码与github\n  - git生成公钥和私钥\n    + 命令:`ssh-keygen -t rsa`生成的公钥与私钥文件会在当用户目录的.ssh目录下.\n\n\n### 把代码push到服务器时需要先pull一下\n  - 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。\n\n### 从服务器上pull代码到本地\n  - 如果本地没有.git目录，需要先初始化一下。\n  - 命令:`git pull [远程服务器地址] [远程的分支]`\n\n### gh-pages分支-搭建博客.\n  - 需要把自已博客的网页代码上传到github上的gh-pages分支\n  - 然后就直接访问了\n    + 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面]","slug":"git","published":1,"date":"2017-02-18T06:41:33.000Z","updated":"2019-04-26T06:24:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gs000b7xuq9tkgdez6","content":"<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"什么是Git\"><a href=\"#什么是Git\" class=\"headerlink\" title=\"什么是Git?\"></a>什么是Git?</h3><ul>\n<li>Git是一款源代码管理工具(版本控制工具)<ul>\n<li>我们写的代码需要使用Git进行管理。<br>1.0是稳定<br>2.0加了新功能</li>\n</ul>\n</li>\n<li>源代码有必要管理起吗？</li>\n<li>有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。</li>\n<li>svn,vss,vcs,tfs…..<br>-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus</li>\n<li>BitKeeper(收费)</li>\n<li>有人想破解(不给提供免费使用)</li>\n<li>linus自己写了一个版本管理的工具（Git）</li>\n</ul>\n<h3 id=\"分布式版本管理工具，集中式\"><a href=\"#分布式版本管理工具，集中式\" class=\"headerlink\" title=\"分布式版本管理工具，集中式\"></a>分布式版本管理工具，集中式</h3><ul>\n<li>git属于分布式</li>\n<li>svn集中式</li>\n</ul>\n<h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><h3 id=\"git初始化一个仓库\"><a href=\"#git初始化一个仓库\" class=\"headerlink\" title=\"git初始化一个仓库\"></a>git初始化一个仓库</h3><ul>\n<li>其实就是创建了一个.git隐藏目录</li>\n<li>命令:<code>git init</code>;<ul>\n<li>想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令.</li>\n<li>一般是在项目的根目录执行这个命令.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自报家门\"><a href=\"#自报家门\" class=\"headerlink\" title=\"自报家门\"></a>自报家门</h3><ul>\n<li>配置用户名 : <code>git config user.name &quot;testName&quot;</code></li>\n<li>配置全局用户名 : <code>git config --global user.name &quot;testName&quot;</code></li>\n<li>配置邮箱   : <code>git config user.email &quot;test@sina.com&quot;</code></li>\n<li>配置邮箱   : <code>git config --global user.email &quot;test@sina.com&quot;</code></li>\n<li>查看配置信息: <code>git config --list</code></li>\n</ul>\n<h3 id=\"把代码提交到仓库中\"><a href=\"#把代码提交到仓库中\" class=\"headerlink\" title=\"把代码提交到仓库中\"></a>把代码提交到仓库中</h3><ul>\n<li><p>1.先把代码添加到暂存区(就相当于放到仓库门口)</p>\n<ul>\n<li>命令:<code>git add 文件路径/文件名</code></li>\n<li>示例:<code>git add ./reademe.md</code></li>\n<li>可以使用<code>git add .</code>这个命令，批量把当前目录下所有修改过的文件添加到暂存区。</li>\n</ul>\n</li>\n<li><p>2.把暂存区的文件提交仓库里</p>\n<ul>\n<li>命令: <code>git commit -m &quot;注释&quot;</code></li>\n<li>示例: <code>git commit -m &quot;我们添加了一个新的功能&quot;</code></li>\n<li>-m 表示指定一个字符串，作为提交的说明(相当于注释);</li>\n</ul>\n</li>\n<li><p>合并add 与commit 命令</p>\n<ul>\n<li><code>git commit -a -m &quot;这是使用合并添加与提交的操作&quot;</code>;</li>\n<li>这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看工作区状态\"><a href=\"#查看工作区状态\" class=\"headerlink\" title=\"查看工作区状态\"></a>查看工作区状态</h3><ul>\n<li>命令:<code>git status</code></li>\n</ul>\n<h3 id=\"添加忽略文件\"><a href=\"#添加忽略文件\" class=\"headerlink\" title=\"添加忽略文件\"></a>添加忽略文件</h3><ul>\n<li>在项目中有一些文件是不需要提交的,我们需要把它忽略掉</li>\n<li>需要在.git文件夹所在目录新建一个名为.gitignore的文件<br>然后在这个文件中写上需要被忽略的文件的路径。<br>示例: /css/a.css<pre><code>: /css/*.css\n: /a.html\n</code></pre></li>\n</ul>\n<h3 id=\"比对文件差异\"><a href=\"#比对文件差异\" class=\"headerlink\" title=\"比对文件差异\"></a>比对文件差异</h3><ul>\n<li>命令: <code>git diff</code><ul>\n<li>用来比较暂存区文件内容与工作区文件内容的区别</li>\n<li><strong>如果暂存区没有文件，就会将工作与代码与最近一次提交对比</strong></li>\n</ul>\n</li>\n<li>命令：<code>git diff --cached</code>  比较暂存区的文件和仓库中文件的区别</li>\n<li>对比之前某两次提交的文件的差异<ul>\n<li>命令:<code>git diff [版本号1] [版本号2] [想比较的文件路径]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><ul>\n<li>命令:<code>git log</code>,可以查看每一次提交的日志</li>\n<li>命令:<code>git log --oneline</code> 表示使用简洁的形式输出提交日志</li>\n</ul>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><ul>\n<li>命令:<code>git reset --hard Head~1</code><ul>\n<li>这是将代码回退到上上一次提交时的状态</li>\n</ul>\n</li>\n<li>命令:<code>git reset --hard Head~2</code><ul>\n<li>回退到上上上次</li>\n</ul>\n</li>\n<li><p>命令:<code>git reset --hard Head~0</code></p>\n<ul>\n<li>回退到上次提交时的状态,~0可以省略</li>\n</ul>\n</li>\n<li><p>命令:<code>git reset --hard 版本号</code></p>\n<ul>\n<li>通过每次提交时生成的版本号来回退版本</li>\n</ul>\n</li>\n<li><p>通过<code>git reflog</code>命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。</p>\n</li>\n</ul>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ul>\n<li>命令:<code>git branch [分支名]</code><ul>\n<li>创建一个新分支</li>\n</ul>\n</li>\n<li>命令:<code>git branch</code><ul>\n<li>查看当前所有的分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><ul>\n<li>命令:<code>git checkout [分支名]</code><ul>\n<li>切换分支后可以在切换后的分支中进行正常的操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><ul>\n<li>命令:<code>git merge [分支名]</code><ul>\n<li>git会将指定的分支合并到当前分支.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><ul>\n<li>命令:<code>git branch -d [分支名]</code><ul>\n<li>删除指定分支，-d参数表示要执行删除操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git提交中的冲突\"><a href=\"#git提交中的冲突\" class=\"headerlink\" title=\"git提交中的冲突\"></a>git提交中的冲突</h3><ul>\n<li>如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交</li>\n</ul>\n<h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h2><h3 id=\"github与git\"><a href=\"#github与git\" class=\"headerlink\" title=\"github与git\"></a>github与git</h3><ul>\n<li>git 版本管理工具</li>\n<li>github 就是一个网站，只是这个网站提供git服务器的功能</li>\n</ul>\n<h3 id=\"上传代码到git服务器-push\"><a href=\"#上传代码到git服务器-push\" class=\"headerlink\" title=\"上传代码到git服务器(push)\"></a>上传代码到git服务器(push)</h3><ul>\n<li><p>命令:<code>git push [远程服务器地址] [远程服务器的分支]</code></p>\n<ul>\n<li>示例:<code>git push https://github.com/huoqishi/test002.git master</code></li>\n</ul>\n</li>\n<li><p>上传时可以使用一些简化的命令</p>\n<ul>\n<li>将远程服务器地址写成变量的形式<ul>\n<li><code>git remote add [变量名]  [远程服务器地址]</code></li>\n<li>示例:<code>git remote add origin https://github.com/huoqishi/test002.git</code></li>\n<li>这样之后就可以直接使用origin来代替git push 后面写的地址了<br><code>git push origin master</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>还可以尽一步简化<ul>\n<li>在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了<code>git push origin</code>;</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"git使用ssh方式上传代码与github\"><a href=\"#git使用ssh方式上传代码与github\" class=\"headerlink\" title=\"git使用ssh方式上传代码与github\"></a>git使用ssh方式上传代码与github</h2><ul>\n<li>git生成公钥和私钥<ul>\n<li>命令:<code>ssh-keygen -t rsa</code>生成的公钥与私钥文件会在当用户目录的.ssh目录下.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"把代码push到服务器时需要先pull一下\"><a href=\"#把代码push到服务器时需要先pull一下\" class=\"headerlink\" title=\"把代码push到服务器时需要先pull一下\"></a>把代码push到服务器时需要先pull一下</h3><ul>\n<li>在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。</li>\n</ul>\n<h3 id=\"从服务器上pull代码到本地\"><a href=\"#从服务器上pull代码到本地\" class=\"headerlink\" title=\"从服务器上pull代码到本地\"></a>从服务器上pull代码到本地</h3><ul>\n<li>如果本地没有.git目录，需要先初始化一下。</li>\n<li>命令:<code>git pull [远程服务器地址] [远程的分支]</code></li>\n</ul>\n<h3 id=\"gh-pages分支-搭建博客\"><a href=\"#gh-pages分支-搭建博客\" class=\"headerlink\" title=\"gh-pages分支-搭建博客.\"></a>gh-pages分支-搭建博客.</h3><ul>\n<li>需要把自已博客的网页代码上传到github上的gh-pages分支</li>\n<li>然后就直接访问了<ul>\n<li>访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面]</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"什么是Git\"><a href=\"#什么是Git\" class=\"headerlink\" title=\"什么是Git?\"></a>什么是Git?</h3><ul>\n<li>Git是一款源代码管理工具(版本控制工具)<ul>\n<li>我们写的代码需要使用Git进行管理。<br>1.0是稳定<br>2.0加了新功能</li>\n</ul>\n</li>\n<li>源代码有必要管理起吗？</li>\n<li>有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。</li>\n<li>svn,vss,vcs,tfs…..<br>-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus</li>\n<li>BitKeeper(收费)</li>\n<li>有人想破解(不给提供免费使用)</li>\n<li>linus自己写了一个版本管理的工具（Git）</li>\n</ul>\n<h3 id=\"分布式版本管理工具，集中式\"><a href=\"#分布式版本管理工具，集中式\" class=\"headerlink\" title=\"分布式版本管理工具，集中式\"></a>分布式版本管理工具，集中式</h3><ul>\n<li>git属于分布式</li>\n<li>svn集中式</li>\n</ul>\n<h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><h3 id=\"git初始化一个仓库\"><a href=\"#git初始化一个仓库\" class=\"headerlink\" title=\"git初始化一个仓库\"></a>git初始化一个仓库</h3><ul>\n<li>其实就是创建了一个.git隐藏目录</li>\n<li>命令:<code>git init</code>;<ul>\n<li>想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令.</li>\n<li>一般是在项目的根目录执行这个命令.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自报家门\"><a href=\"#自报家门\" class=\"headerlink\" title=\"自报家门\"></a>自报家门</h3><ul>\n<li>配置用户名 : <code>git config user.name &quot;testName&quot;</code></li>\n<li>配置全局用户名 : <code>git config --global user.name &quot;testName&quot;</code></li>\n<li>配置邮箱   : <code>git config user.email &quot;test@sina.com&quot;</code></li>\n<li>配置邮箱   : <code>git config --global user.email &quot;test@sina.com&quot;</code></li>\n<li>查看配置信息: <code>git config --list</code></li>\n</ul>\n<h3 id=\"把代码提交到仓库中\"><a href=\"#把代码提交到仓库中\" class=\"headerlink\" title=\"把代码提交到仓库中\"></a>把代码提交到仓库中</h3><ul>\n<li><p>1.先把代码添加到暂存区(就相当于放到仓库门口)</p>\n<ul>\n<li>命令:<code>git add 文件路径/文件名</code></li>\n<li>示例:<code>git add ./reademe.md</code></li>\n<li>可以使用<code>git add .</code>这个命令，批量把当前目录下所有修改过的文件添加到暂存区。</li>\n</ul>\n</li>\n<li><p>2.把暂存区的文件提交仓库里</p>\n<ul>\n<li>命令: <code>git commit -m &quot;注释&quot;</code></li>\n<li>示例: <code>git commit -m &quot;我们添加了一个新的功能&quot;</code></li>\n<li>-m 表示指定一个字符串，作为提交的说明(相当于注释);</li>\n</ul>\n</li>\n<li><p>合并add 与commit 命令</p>\n<ul>\n<li><code>git commit -a -m &quot;这是使用合并添加与提交的操作&quot;</code>;</li>\n<li>这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看工作区状态\"><a href=\"#查看工作区状态\" class=\"headerlink\" title=\"查看工作区状态\"></a>查看工作区状态</h3><ul>\n<li>命令:<code>git status</code></li>\n</ul>\n<h3 id=\"添加忽略文件\"><a href=\"#添加忽略文件\" class=\"headerlink\" title=\"添加忽略文件\"></a>添加忽略文件</h3><ul>\n<li>在项目中有一些文件是不需要提交的,我们需要把它忽略掉</li>\n<li>需要在.git文件夹所在目录新建一个名为.gitignore的文件<br>然后在这个文件中写上需要被忽略的文件的路径。<br>示例: /css/a.css<pre><code>: /css/*.css\n: /a.html\n</code></pre></li>\n</ul>\n<h3 id=\"比对文件差异\"><a href=\"#比对文件差异\" class=\"headerlink\" title=\"比对文件差异\"></a>比对文件差异</h3><ul>\n<li>命令: <code>git diff</code><ul>\n<li>用来比较暂存区文件内容与工作区文件内容的区别</li>\n<li><strong>如果暂存区没有文件，就会将工作与代码与最近一次提交对比</strong></li>\n</ul>\n</li>\n<li>命令：<code>git diff --cached</code>  比较暂存区的文件和仓库中文件的区别</li>\n<li>对比之前某两次提交的文件的差异<ul>\n<li>命令:<code>git diff [版本号1] [版本号2] [想比较的文件路径]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><ul>\n<li>命令:<code>git log</code>,可以查看每一次提交的日志</li>\n<li>命令:<code>git log --oneline</code> 表示使用简洁的形式输出提交日志</li>\n</ul>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><ul>\n<li>命令:<code>git reset --hard Head~1</code><ul>\n<li>这是将代码回退到上上一次提交时的状态</li>\n</ul>\n</li>\n<li>命令:<code>git reset --hard Head~2</code><ul>\n<li>回退到上上上次</li>\n</ul>\n</li>\n<li><p>命令:<code>git reset --hard Head~0</code></p>\n<ul>\n<li>回退到上次提交时的状态,~0可以省略</li>\n</ul>\n</li>\n<li><p>命令:<code>git reset --hard 版本号</code></p>\n<ul>\n<li>通过每次提交时生成的版本号来回退版本</li>\n</ul>\n</li>\n<li><p>通过<code>git reflog</code>命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。</p>\n</li>\n</ul>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ul>\n<li>命令:<code>git branch [分支名]</code><ul>\n<li>创建一个新分支</li>\n</ul>\n</li>\n<li>命令:<code>git branch</code><ul>\n<li>查看当前所有的分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><ul>\n<li>命令:<code>git checkout [分支名]</code><ul>\n<li>切换分支后可以在切换后的分支中进行正常的操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><ul>\n<li>命令:<code>git merge [分支名]</code><ul>\n<li>git会将指定的分支合并到当前分支.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><ul>\n<li>命令:<code>git branch -d [分支名]</code><ul>\n<li>删除指定分支，-d参数表示要执行删除操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git提交中的冲突\"><a href=\"#git提交中的冲突\" class=\"headerlink\" title=\"git提交中的冲突\"></a>git提交中的冲突</h3><ul>\n<li>如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交</li>\n</ul>\n<h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h2><h3 id=\"github与git\"><a href=\"#github与git\" class=\"headerlink\" title=\"github与git\"></a>github与git</h3><ul>\n<li>git 版本管理工具</li>\n<li>github 就是一个网站，只是这个网站提供git服务器的功能</li>\n</ul>\n<h3 id=\"上传代码到git服务器-push\"><a href=\"#上传代码到git服务器-push\" class=\"headerlink\" title=\"上传代码到git服务器(push)\"></a>上传代码到git服务器(push)</h3><ul>\n<li><p>命令:<code>git push [远程服务器地址] [远程服务器的分支]</code></p>\n<ul>\n<li>示例:<code>git push https://github.com/huoqishi/test002.git master</code></li>\n</ul>\n</li>\n<li><p>上传时可以使用一些简化的命令</p>\n<ul>\n<li>将远程服务器地址写成变量的形式<ul>\n<li><code>git remote add [变量名]  [远程服务器地址]</code></li>\n<li>示例:<code>git remote add origin https://github.com/huoqishi/test002.git</code></li>\n<li>这样之后就可以直接使用origin来代替git push 后面写的地址了<br><code>git push origin master</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>还可以尽一步简化<ul>\n<li>在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了<code>git push origin</code>;</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"git使用ssh方式上传代码与github\"><a href=\"#git使用ssh方式上传代码与github\" class=\"headerlink\" title=\"git使用ssh方式上传代码与github\"></a>git使用ssh方式上传代码与github</h2><ul>\n<li>git生成公钥和私钥<ul>\n<li>命令:<code>ssh-keygen -t rsa</code>生成的公钥与私钥文件会在当用户目录的.ssh目录下.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"把代码push到服务器时需要先pull一下\"><a href=\"#把代码push到服务器时需要先pull一下\" class=\"headerlink\" title=\"把代码push到服务器时需要先pull一下\"></a>把代码push到服务器时需要先pull一下</h3><ul>\n<li>在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。</li>\n</ul>\n<h3 id=\"从服务器上pull代码到本地\"><a href=\"#从服务器上pull代码到本地\" class=\"headerlink\" title=\"从服务器上pull代码到本地\"></a>从服务器上pull代码到本地</h3><ul>\n<li>如果本地没有.git目录，需要先初始化一下。</li>\n<li>命令:<code>git pull [远程服务器地址] [远程的分支]</code></li>\n</ul>\n<h3 id=\"gh-pages分支-搭建博客\"><a href=\"#gh-pages分支-搭建博客\" class=\"headerlink\" title=\"gh-pages分支-搭建博客.\"></a>gh-pages分支-搭建博客.</h3><ul>\n<li>需要把自已博客的网页代码上传到github上的gh-pages分支</li>\n<li>然后就直接访问了<ul>\n<li>访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面]</li>\n</ul>\n</li>\n</ul>\n"},{"title":"html5兼容性","_content":"##HTML5的兼容性\n- 因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。\nHTML5的兼容性\n\n- 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。\n比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。\n这里就需要用到一个方法，document.createElement();\n\n\n- `var oHeader = document.createElement(\"header\");`//-> 动态创建一个标签‘header’\ndocument.body.appendChild(oHeader)//-> 把header标签动态添加到body中\n这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写\n\n\n- `document.createElement(\"header\");`\n这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。\n\n- 这里就不用我们自己来写了，只需要引入一个JS文件就可以了。\n就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。\n这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法：\n\n<!--[if lte IE 8]>\n这个注释是只属于IE的，也就是说只有IE浏览器才认识\t\n<![endif]-->\n这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。\n\n\n- <!--[if lte IE 8]>\n`<script>alert(123)</script>`\n<![endif]-->\n只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。\n\n所以我们可以用这个方法来引入刚才那段JS代码\n\n\n- <!--[if lte IE 8]>\n`<script src=\"./html5shiv.min\"></script>`\n<![endif]-->\n这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。","source":"_posts/html5标签兼容性.md","raw":"---\ntitle: html5兼容性\ncategories: ['前端']\ntags: ['兼容性']\n---\n##HTML5的兼容性\n- 因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。\nHTML5的兼容性\n\n- 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。\n比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。\n这里就需要用到一个方法，document.createElement();\n\n\n- `var oHeader = document.createElement(\"header\");`//-> 动态创建一个标签‘header’\ndocument.body.appendChild(oHeader)//-> 把header标签动态添加到body中\n这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写\n\n\n- `document.createElement(\"header\");`\n这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。\n\n- 这里就不用我们自己来写了，只需要引入一个JS文件就可以了。\n就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。\n这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法：\n\n<!--[if lte IE 8]>\n这个注释是只属于IE的，也就是说只有IE浏览器才认识\t\n<![endif]-->\n这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。\n\n\n- <!--[if lte IE 8]>\n`<script>alert(123)</script>`\n<![endif]-->\n只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。\n\n所以我们可以用这个方法来引入刚才那段JS代码\n\n\n- <!--[if lte IE 8]>\n`<script src=\"./html5shiv.min\"></script>`\n<![endif]-->\n这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。","slug":"html5标签兼容性","published":1,"date":"2017-02-21T14:32:13.000Z","updated":"2019-04-26T06:21:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gt000c7xuqyn2ykt0w","content":"<p>##HTML5的兼容性</p>\n<ul>\n<li><p>因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。<br>HTML5的兼容性</p>\n</li>\n<li><p>因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。<br>比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。<br>这里就需要用到一个方法，document.createElement();</p>\n</li>\n</ul>\n<ul>\n<li><code>var oHeader = document.createElement(&quot;header&quot;);</code>//-&gt; 动态创建一个标签‘header’<br>document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中<br>这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写</li>\n</ul>\n<ul>\n<li><p><code>document.createElement(&quot;header&quot;);</code><br>这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。</p>\n</li>\n<li><p>这里就不用我们自己来写了，只需要引入一个JS文件就可以了。<br>就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。<br>这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法：</p>\n</li>\n</ul>\n<!--[if lte IE 8]>\n这个注释是只属于IE的，也就是说只有IE浏览器才认识    \n<![endif]-->\n<p>这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。</p>\n<ul>\n<li><!--[if lte IE 8]>\n`<script>alert(123)</script>`\n<![endif]-->\n只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。</li>\n</ul>\n<p>所以我们可以用这个方法来引入刚才那段JS代码</p>\n<ul>\n<li><!--[if lte IE 8]>\n`<script src=\"./html5shiv.min\"></script>`\n<![endif]-->\n这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>##HTML5的兼容性</p>\n<ul>\n<li><p>因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。<br>HTML5的兼容性</p>\n</li>\n<li><p>因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。<br>比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。<br>这里就需要用到一个方法，document.createElement();</p>\n</li>\n</ul>\n<ul>\n<li><code>var oHeader = document.createElement(&quot;header&quot;);</code>//-&gt; 动态创建一个标签‘header’<br>document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中<br>这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写</li>\n</ul>\n<ul>\n<li><p><code>document.createElement(&quot;header&quot;);</code><br>这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。</p>\n</li>\n<li><p>这里就不用我们自己来写了，只需要引入一个JS文件就可以了。<br>就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。<br>这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法：</p>\n</li>\n</ul>\n<!--[if lte IE 8]>\n这个注释是只属于IE的，也就是说只有IE浏览器才认识    \n<![endif]-->\n<p>这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。</p>\n<ul>\n<li><!--[if lte IE 8]>\n`<script>alert(123)</script>`\n<![endif]-->\n只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。</li>\n</ul>\n<p>所以我们可以用这个方法来引入刚才那段JS代码</p>\n<ul>\n<li><!--[if lte IE 8]>\n`<script src=\"./html5shiv.min\"></script>`\n<![endif]-->\n这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。</li>\n</ul>\n"},{"title":"html5基础一","_content":"###1，严格模式strict.dtd。\n>在js开头处加\"use strict\";就成为严格模式\n\n###2，var fra = document.createDocumentFragment();创建文档碎片。\n>document.body.appendchild(fra);\n\n###3，cc:ie6（ie专用注释）\n\n###4，自执行函数(function(){})();\n\n###5，itemscope(那个元素设置了这个属性，就把他当做一个整体)itemprop等\n\n6，guoxiang1991.github.io\n\n7，\n<label for=\"\">\n\t课程：<input type=\"text\" list=\"course\">\n<label>\n<datalist id=\"course\">\n\t<option value=\"php\">php</option>\n</datalist>\n\n8，广告页必须要小，就可以用到html5的dom操作。\n\n9，html5表单：\n9.1 fieldset 元素可将表单内的相关元素分组\n9.2 legend标签为 <fieldset>、<figure> 以及 <details> 元素定义标题。\n9.3 required 必填项。\n9.4 multiple 属性规定输入域中可选择多个值。\n9.5 autofocus 默认获取焦点。\n9.6 placeholder 占位符。\n9.7 pattern 自定义验证。\n9.8 min 最大值。\n9.9 max 最小值。\n9.10 progress进度条\n9.11 meter 度量器  使用范列     <label for=\"\">\n           入学成绩: <input type=\"number\" max=\"100\" id=\"score\" min=\"0\" step=\"1\" value=\"0\"/>\n        </label>\n        <label for=\"\">\n            基础水平: <meter min=\"0\" max=\"100\" low=\"60\" high=\"80\" value=\"0\" id=\"level\" ></meter>\n        </label>\n        var score = document.getElementById(\"score\");\n        var level = document.getElementById(\"level\");\n        score.oninput = function () {\n            level.value=this.value;\n        }\n9.12 <label for=\"\">\n            所属学院: <input type=\"text\" list=\"xueYuan\" placeholder=\"前端与移动开发学院\"/>\n            <datalist id=\"xueYuan\">\n                <option value=\"前端\"></option>\n                <option value=\"移动开发\"></option>\n                <option value=\"Java\"></option>\n            </datalist>\n        </label>\n\n10，音乐添加\n<audio src = \"路径\"></audio>autopaly(自动播放 controls 是否显示默认播放控件  loop循环播放)\n多浏览器支持方案\n<audio controls>\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n</audio>\n\n11，视频添加\n<video src=\"路径\"></video>\nautoplay 自动播放\ncontrols 是否显示默认播放控件\nloop 循环播放\nwidth 设置播放窗口宽度\nheight 设置播放窗口的高度（查询浏览器支持情况）\n多浏览器支持的方案\n<audio controls>\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n</audio>\n\n12，语义化标签\nheader头部\ncontainer主体部分\narticle文章\naside侧旁栏\nfooter底部\nsection区块\n\n13，表单元素\n<datalist>\t数据列表\n<keygen>\t生成加密字符串\n<output>\t输出结果\n<meter>\t0度量器\n\n14，兼容处理：在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素（inline）对待。所以我们只需要将其转换成块元素即可使用。但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement('tagName')创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement('tagName')来创建一遍，这样IE低版本也能正常解析HTML5新标签了，但在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题，这个库文件会帮自动通过document.createElement('tagName')创建所有HTML5的新标签。\n \n15，微数据\n<div itemscope itemtype=\"http://schema.org/Movie\">\n\t\t<span itemprop=\"actor\">刘德华</span>\n\t\t<span itemprop=\"director\" datatime=\"2012-02-06T22:30:30.50+08:00\">2012年2月6日 22:30</span>\n\t\t<!--<a href=\"\" itemprop=\"url\"></a>-->\n\t\t<p itemprop=\"url\" >http://www.baidu.com</p>\n\t\t<span itemprop=\"description\">评论内容</span>\n\t</div>\n\n\n**dom**\n1，document.querySelector('selector')通过CSS选择器获取元素，符合匹配条件的第1个元素。\n\n2，document.querySelectorAll('selector') 通过CSS选择器获取元素，以伪数组形式存在。\n\n3，类名操作\n1、Node.classList.add('class') 添加class\n2、Node.classList.remove('class') 移除class\n3、Node.classList.toggle('class') 切换class，有则移除，无则添加\n4、Node.classList.contains('class') 检测是否存在class\nNode指一个有效的DOM节点，是一个通称。\n5，自定义属性\n假设某元素<div id=\"demo\" data-name=\"itcast\" data-age=\"10\">\nvar demo = document.querySelector('#demo');\n1、读取 demo.dataset['name']\n2、设置demo.dataset['name'] = 'web developer'\n\n","source":"_posts/html5第一天.md","raw":"---\ntitle: html5基础一\ncategories: ['前端']\ntags: ['html5']\n---\n###1，严格模式strict.dtd。\n>在js开头处加\"use strict\";就成为严格模式\n\n###2，var fra = document.createDocumentFragment();创建文档碎片。\n>document.body.appendchild(fra);\n\n###3，cc:ie6（ie专用注释）\n\n###4，自执行函数(function(){})();\n\n###5，itemscope(那个元素设置了这个属性，就把他当做一个整体)itemprop等\n\n6，guoxiang1991.github.io\n\n7，\n<label for=\"\">\n\t课程：<input type=\"text\" list=\"course\">\n<label>\n<datalist id=\"course\">\n\t<option value=\"php\">php</option>\n</datalist>\n\n8，广告页必须要小，就可以用到html5的dom操作。\n\n9，html5表单：\n9.1 fieldset 元素可将表单内的相关元素分组\n9.2 legend标签为 <fieldset>、<figure> 以及 <details> 元素定义标题。\n9.3 required 必填项。\n9.4 multiple 属性规定输入域中可选择多个值。\n9.5 autofocus 默认获取焦点。\n9.6 placeholder 占位符。\n9.7 pattern 自定义验证。\n9.8 min 最大值。\n9.9 max 最小值。\n9.10 progress进度条\n9.11 meter 度量器  使用范列     <label for=\"\">\n           入学成绩: <input type=\"number\" max=\"100\" id=\"score\" min=\"0\" step=\"1\" value=\"0\"/>\n        </label>\n        <label for=\"\">\n            基础水平: <meter min=\"0\" max=\"100\" low=\"60\" high=\"80\" value=\"0\" id=\"level\" ></meter>\n        </label>\n        var score = document.getElementById(\"score\");\n        var level = document.getElementById(\"level\");\n        score.oninput = function () {\n            level.value=this.value;\n        }\n9.12 <label for=\"\">\n            所属学院: <input type=\"text\" list=\"xueYuan\" placeholder=\"前端与移动开发学院\"/>\n            <datalist id=\"xueYuan\">\n                <option value=\"前端\"></option>\n                <option value=\"移动开发\"></option>\n                <option value=\"Java\"></option>\n            </datalist>\n        </label>\n\n10，音乐添加\n<audio src = \"路径\"></audio>autopaly(自动播放 controls 是否显示默认播放控件  loop循环播放)\n多浏览器支持方案\n<audio controls>\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n</audio>\n\n11，视频添加\n<video src=\"路径\"></video>\nautoplay 自动播放\ncontrols 是否显示默认播放控件\nloop 循环播放\nwidth 设置播放窗口宽度\nheight 设置播放窗口的高度（查询浏览器支持情况）\n多浏览器支持的方案\n<audio controls>\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n\t<source src\"路径加不同格式的音乐\">\n</audio>\n\n12，语义化标签\nheader头部\ncontainer主体部分\narticle文章\naside侧旁栏\nfooter底部\nsection区块\n\n13，表单元素\n<datalist>\t数据列表\n<keygen>\t生成加密字符串\n<output>\t输出结果\n<meter>\t0度量器\n\n14，兼容处理：在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素（inline）对待。所以我们只需要将其转换成块元素即可使用。但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement('tagName')创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement('tagName')来创建一遍，这样IE低版本也能正常解析HTML5新标签了，但在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题，这个库文件会帮自动通过document.createElement('tagName')创建所有HTML5的新标签。\n \n15，微数据\n<div itemscope itemtype=\"http://schema.org/Movie\">\n\t\t<span itemprop=\"actor\">刘德华</span>\n\t\t<span itemprop=\"director\" datatime=\"2012-02-06T22:30:30.50+08:00\">2012年2月6日 22:30</span>\n\t\t<!--<a href=\"\" itemprop=\"url\"></a>-->\n\t\t<p itemprop=\"url\" >http://www.baidu.com</p>\n\t\t<span itemprop=\"description\">评论内容</span>\n\t</div>\n\n\n**dom**\n1，document.querySelector('selector')通过CSS选择器获取元素，符合匹配条件的第1个元素。\n\n2，document.querySelectorAll('selector') 通过CSS选择器获取元素，以伪数组形式存在。\n\n3，类名操作\n1、Node.classList.add('class') 添加class\n2、Node.classList.remove('class') 移除class\n3、Node.classList.toggle('class') 切换class，有则移除，无则添加\n4、Node.classList.contains('class') 检测是否存在class\nNode指一个有效的DOM节点，是一个通称。\n5，自定义属性\n假设某元素<div id=\"demo\" data-name=\"itcast\" data-age=\"10\">\nvar demo = document.querySelector('#demo');\n1、读取 demo.dataset['name']\n2、设置demo.dataset['name'] = 'web developer'\n\n","slug":"html5第一天","published":1,"date":"2017-02-23T13:18:45.000Z","updated":"2019-04-26T06:58:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gv000g7xuqa4jnkqag","content":"<p>###1，严格模式strict.dtd。</p>\n<blockquote>\n<p>在js开头处加”use strict”;就成为严格模式</p>\n</blockquote>\n<p>###2，var fra = document.createDocumentFragment();创建文档碎片。</p>\n<blockquote>\n<p>document.body.appendchild(fra);</p>\n</blockquote>\n<p>###3，cc:ie6（ie专用注释）</p>\n<p>###4，自执行函数(function(){})();</p>\n<p>###5，itemscope(那个元素设置了这个属性，就把他当做一个整体)itemprop等</p>\n<p>6，guoxiang1991.github.io</p>\n<p>7，</p>\n<label for><br>    课程：<input type=\"text\" list=\"course\"><br><label><br><datalist id=\"course\"><br>    <option value=\"php\">php</option><br></datalist><br><br>8，广告页必须要小，就可以用到html5的dom操作。<br><br>9，html5表单：<br>9.1 fieldset 元素可将表单内的相关元素分组<br>9.2 legend标签为 <fieldset>、<figure> 以及 <details> 元素定义标题。<br>9.3 required 必填项。<br>9.4 multiple 属性规定输入域中可选择多个值。<br>9.5 autofocus 默认获取焦点。<br>9.6 placeholder 占位符。<br>9.7 pattern 自定义验证。<br>9.8 min 最大值。<br>9.9 max 最小值。<br>9.10 progress进度条<br>9.11 meter 度量器  使用范列     <label for><br>           入学成绩: <input type=\"number\" max=\"100\" id=\"score\" min=\"0\" step=\"1\" value=\"0\"><br>        </label><br>        <label for><br>            基础水平: <meter min=\"0\" max=\"100\" low=\"60\" high=\"80\" value=\"0\" id=\"level\"></meter><br>        </label><br>        var score = document.getElementById(“score”);<br>        var level = document.getElementById(“level”);<br>        score.oninput = function () {<br>            level.value=this.value;<br>        }<br>9.12 <label for><br>            所属学院: <input type=\"text\" list=\"xueYuan\" placeholder=\"前端与移动开发学院\"><br>            <datalist id=\"xueYuan\"><br>                <option value=\"前端\"></option><br>                <option value=\"移动开发\"></option><br>                <option value=\"Java\"></option><br>            </datalist><br>        </label>\n\n<p>10，音乐添加</p>\n<audio src=\"路径\"></audio>autopaly(自动播放 controls 是否显示默认播放控件  loop循环播放)<br>多浏览器支持方案<br><audio controls><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br></audio>\n\n<p>11，视频添加</p>\n<p><video src=\"路径\"></video><br>autoplay 自动播放<br>controls 是否显示默认播放控件<br>loop 循环播放<br>width 设置播放窗口宽度<br>height 设置播放窗口的高度（查询浏览器支持情况）<br>多浏览器支持的方案</p>\n<audio controls><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br></audio>\n\n<p>12，语义化标签<br>header头部<br>container主体部分<br>article文章<br>aside侧旁栏<br>footer底部<br>section区块</p>\n<p>13，表单元素</p>\n<p><datalist>    数据列表</datalist></p>\n<p><keygen>    生成加密字符串</p>\n<p><output>    输出结果</output></p>\n<p><meter>    0度量器</meter></p>\n<p>14，兼容处理：在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素（inline）对待。所以我们只需要将其转换成块元素即可使用。但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement(‘tagName’)创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了，但在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题，这个库文件会帮自动通过document.createElement(‘tagName’)创建所有HTML5的新标签。</p>\n<p>15，微数据</p>\n<div itemscope itemtype=\"http://schema.org/Movie\"><br>        <span itemprop=\"actor\">刘德华</span><br>        <span itemprop=\"director\" datatime=\"2012-02-06T22:30:30.50+08:00\">2012年2月6日 22:30</span><br>        <!--<a href=\"\" itemprop=\"url\"></a>--><br>        <p itemprop=\"url\"><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p><br>        <span itemprop=\"description\">评论内容</span><br>    </div>\n\n\n<p><strong>dom</strong><br>1，document.querySelector(‘selector’)通过CSS选择器获取元素，符合匹配条件的第1个元素。</p>\n<p>2，document.querySelectorAll(‘selector’) 通过CSS选择器获取元素，以伪数组形式存在。</p>\n<p>3，类名操作<br>1、Node.classList.add(‘class’) 添加class<br>2、Node.classList.remove(‘class’) 移除class<br>3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加<br>4、Node.classList.contains(‘class’) 检测是否存在class<br>Node指一个有效的DOM节点，是一个通称。<br>5，自定义属性<br>假设某元素<div id=\"demo\" data-name=\"itcast\" data-age=\"10\"><br>var demo = document.querySelector(‘#demo’);<br>1、读取 demo.dataset[‘name’]<br>2、设置demo.dataset[‘name’] = ‘web developer’</div></p>\n</details></figure></fieldset></label></label>","site":{"data":{}},"excerpt":"","more":"<p>###1，严格模式strict.dtd。</p>\n<blockquote>\n<p>在js开头处加”use strict”;就成为严格模式</p>\n</blockquote>\n<p>###2，var fra = document.createDocumentFragment();创建文档碎片。</p>\n<blockquote>\n<p>document.body.appendchild(fra);</p>\n</blockquote>\n<p>###3，cc:ie6（ie专用注释）</p>\n<p>###4，自执行函数(function(){})();</p>\n<p>###5，itemscope(那个元素设置了这个属性，就把他当做一个整体)itemprop等</p>\n<p>6，guoxiang1991.github.io</p>\n<p>7，</p>\n<label for><br>    课程：<input type=\"text\" list=\"course\"><br><label><br><datalist id=\"course\"><br>    <option value=\"php\">php</option><br></datalist><br><br>8，广告页必须要小，就可以用到html5的dom操作。<br><br>9，html5表单：<br>9.1 fieldset 元素可将表单内的相关元素分组<br>9.2 legend标签为 <fieldset>、<figure> 以及 <details> 元素定义标题。<br>9.3 required 必填项。<br>9.4 multiple 属性规定输入域中可选择多个值。<br>9.5 autofocus 默认获取焦点。<br>9.6 placeholder 占位符。<br>9.7 pattern 自定义验证。<br>9.8 min 最大值。<br>9.9 max 最小值。<br>9.10 progress进度条<br>9.11 meter 度量器  使用范列     <label for><br>           入学成绩: <input type=\"number\" max=\"100\" id=\"score\" min=\"0\" step=\"1\" value=\"0\"><br>        </label><br>        <label for><br>            基础水平: <meter min=\"0\" max=\"100\" low=\"60\" high=\"80\" value=\"0\" id=\"level\"></meter><br>        </label><br>        var score = document.getElementById(“score”);<br>        var level = document.getElementById(“level”);<br>        score.oninput = function () {<br>            level.value=this.value;<br>        }<br>9.12 <label for><br>            所属学院: <input type=\"text\" list=\"xueYuan\" placeholder=\"前端与移动开发学院\"><br>            <datalist id=\"xueYuan\"><br>                <option value=\"前端\"></option><br>                <option value=\"移动开发\"></option><br>                <option value=\"Java\"></option><br>            </datalist><br>        </label>\n\n<p>10，音乐添加</p>\n<audio src=\"路径\"></audio>autopaly(自动播放 controls 是否显示默认播放控件  loop循环播放)<br>多浏览器支持方案<br><audio controls><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br></audio>\n\n<p>11，视频添加</p>\n<p><video src=\"路径\"></video><br>autoplay 自动播放<br>controls 是否显示默认播放控件<br>loop 循环播放<br>width 设置播放窗口宽度<br>height 设置播放窗口的高度（查询浏览器支持情况）<br>多浏览器支持的方案</p>\n<audio controls><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br>    <source src\"路径加不同格式的音乐\"><br></audio>\n\n<p>12，语义化标签<br>header头部<br>container主体部分<br>article文章<br>aside侧旁栏<br>footer底部<br>section区块</p>\n<p>13，表单元素</p>\n<p><datalist>    数据列表</datalist></p>\n<p><keygen>    生成加密字符串</p>\n<p><output>    输出结果</output></p>\n<p><meter>    0度量器</meter></p>\n<p>14，兼容处理：在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素（inline）对待。所以我们只需要将其转换成块元素即可使用。但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement(‘tagName’)创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了，但在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题，这个库文件会帮自动通过document.createElement(‘tagName’)创建所有HTML5的新标签。</p>\n<p>15，微数据</p>\n<div itemscope itemtype=\"http://schema.org/Movie\"><br>        <span itemprop=\"actor\">刘德华</span><br>        <span itemprop=\"director\" datatime=\"2012-02-06T22:30:30.50+08:00\">2012年2月6日 22:30</span><br>        <!--<a href=\"\" itemprop=\"url\"></a>--><br>        <p itemprop=\"url\"><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p><br>        <span itemprop=\"description\">评论内容</span><br>    </div>\n\n\n<p><strong>dom</strong><br>1，document.querySelector(‘selector’)通过CSS选择器获取元素，符合匹配条件的第1个元素。</p>\n<p>2，document.querySelectorAll(‘selector’) 通过CSS选择器获取元素，以伪数组形式存在。</p>\n<p>3，类名操作<br>1、Node.classList.add(‘class’) 添加class<br>2、Node.classList.remove(‘class’) 移除class<br>3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加<br>4、Node.classList.contains(‘class’) 检测是否存在class<br>Node指一个有效的DOM节点，是一个通称。<br>5，自定义属性<br>假设某元素<div id=\"demo\" data-name=\"itcast\" data-age=\"10\"><br>var demo = document.querySelector(‘#demo’);<br>1、读取 demo.dataset[‘name’]<br>2、设置demo.dataset[‘name’] = ‘web developer’</div></p>\n</details></figure></fieldset></label></label>"},{"title":"html5表单","_content":"## HTML5的表单\n- HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。\n- 输入类型\n\n+ 输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有\n\n\t\t<input type=\"text\">//-> 文本框\n\t\t<input type=\"password\">//-> 密码框\n\t\t<input type=\"checkbox\">//-> 复选框\n\t\t<input type=\"radio\">//-> 单选框\n\t\t<input type=\"submit\">//-> 提交\n\t\t<input type=\"button\">//-> 按钮\n\t\t<input type=\"reset\">//-> 重置\n\t\t<input type=\"file\">//-> 文件选择\n+ 这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类\n\n\t\t<input type=\"email\">//-> email地址匹配\n\t\t<input type=\"url\">//-> url地址匹配\n\t\t<input type=\"tel\">//-> 电话号码\n\t\t<input type=\"number\">//-> 数字\n\t\t<input type=\"search\">//-> 搜索框\n\t\t<input type=\"color\">//-> 拾色器\n\t\t<input type=\"time\">//-> 时间选择\n\t\t<input type=\"date\">//-> 日期选择\n\t\t<input type=\"month\">//-> 月份选择\n\t\t<input type=\"week\">//-> 周选择\n- 这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。\n\n- 当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。\n## 表单元素\n\n- 表单元素其实就是HTML5中新增加的一些属于表单的新标签。\n- 以前我们接触的表单元素有\n\n\t\t<form></form>//-> 表单\n\t\t<fieldset></fieldset>//-> 表单框\n\t\t<legend></legend>//-> 表单框的标题\n\t\t<label></label>//-> 表单里的控件标签\n\t\t<textarea></textarea>//-> 文本区域\n\t\t<select></select>//-> 选择列表\n\t\t<option></option>//-> 选择列表的下拉项\n\n\n##### 下面是我们HTML5中新增加的表单元素\n\t\t<datalist></datalist>//-> 数据列表\n\t\t<output></output>//-> 输出结果\n\t\t<meter></meter>//-> 度量器\n\t\t<keygen></keygen>//-> 生成加密字符串\n- 这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。\n\n#### 表单属性\n\n- 表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。\n- 比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。\n\n\n\t\t<input type=\"number\" min=\"10\" max=\"20\">\n- 这样的话就只能填写10到20之间的数字了。\n\n- 以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性\n\n\t\tplaceholder//-> 占位符\n\t\tautofocus//-> 自动获取焦点\n\t\tmultiple//-> 多文件上传\n\t\tautocomplete//-> 自动填充\n\t\tform//-> 表单关联\n\t\tnovalidate//-> 关闭验证\n\t\trequired//-> 必填\n\t\tpattern//-> 自定义验证\n- 通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。","source":"_posts/html5表单.md","raw":"---\ntitle: html5表单\ncategories: ['前端']\ntags: ['html']\n---\n## HTML5的表单\n- HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。\n- 输入类型\n\n+ 输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有\n\n\t\t<input type=\"text\">//-> 文本框\n\t\t<input type=\"password\">//-> 密码框\n\t\t<input type=\"checkbox\">//-> 复选框\n\t\t<input type=\"radio\">//-> 单选框\n\t\t<input type=\"submit\">//-> 提交\n\t\t<input type=\"button\">//-> 按钮\n\t\t<input type=\"reset\">//-> 重置\n\t\t<input type=\"file\">//-> 文件选择\n+ 这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类\n\n\t\t<input type=\"email\">//-> email地址匹配\n\t\t<input type=\"url\">//-> url地址匹配\n\t\t<input type=\"tel\">//-> 电话号码\n\t\t<input type=\"number\">//-> 数字\n\t\t<input type=\"search\">//-> 搜索框\n\t\t<input type=\"color\">//-> 拾色器\n\t\t<input type=\"time\">//-> 时间选择\n\t\t<input type=\"date\">//-> 日期选择\n\t\t<input type=\"month\">//-> 月份选择\n\t\t<input type=\"week\">//-> 周选择\n- 这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。\n\n- 当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。\n## 表单元素\n\n- 表单元素其实就是HTML5中新增加的一些属于表单的新标签。\n- 以前我们接触的表单元素有\n\n\t\t<form></form>//-> 表单\n\t\t<fieldset></fieldset>//-> 表单框\n\t\t<legend></legend>//-> 表单框的标题\n\t\t<label></label>//-> 表单里的控件标签\n\t\t<textarea></textarea>//-> 文本区域\n\t\t<select></select>//-> 选择列表\n\t\t<option></option>//-> 选择列表的下拉项\n\n\n##### 下面是我们HTML5中新增加的表单元素\n\t\t<datalist></datalist>//-> 数据列表\n\t\t<output></output>//-> 输出结果\n\t\t<meter></meter>//-> 度量器\n\t\t<keygen></keygen>//-> 生成加密字符串\n- 这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。\n\n#### 表单属性\n\n- 表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。\n- 比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。\n\n\n\t\t<input type=\"number\" min=\"10\" max=\"20\">\n- 这样的话就只能填写10到20之间的数字了。\n\n- 以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性\n\n\t\tplaceholder//-> 占位符\n\t\tautofocus//-> 自动获取焦点\n\t\tmultiple//-> 多文件上传\n\t\tautocomplete//-> 自动填充\n\t\tform//-> 表单关联\n\t\tnovalidate//-> 关闭验证\n\t\trequired//-> 必填\n\t\tpattern//-> 自定义验证\n- 通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。","slug":"html5表单","published":1,"date":"2017-02-21T14:55:22.000Z","updated":"2019-04-26T06:20:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gx000j7xuqngf4zxa5","content":"<h2 id=\"HTML5的表单\"><a href=\"#HTML5的表单\" class=\"headerlink\" title=\"HTML5的表单\"></a>HTML5的表单</h2><ul>\n<li>HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。</li>\n<li>输入类型</li>\n</ul>\n<ul>\n<li><p>输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有</p>\n<pre><code>&lt;input type=&quot;text&quot;&gt;//-&gt; 文本框\n&lt;input type=&quot;password&quot;&gt;//-&gt; 密码框\n&lt;input type=&quot;checkbox&quot;&gt;//-&gt; 复选框\n&lt;input type=&quot;radio&quot;&gt;//-&gt; 单选框\n&lt;input type=&quot;submit&quot;&gt;//-&gt; 提交\n&lt;input type=&quot;button&quot;&gt;//-&gt; 按钮\n&lt;input type=&quot;reset&quot;&gt;//-&gt; 重置\n&lt;input type=&quot;file&quot;&gt;//-&gt; 文件选择\n</code></pre></li>\n<li><p>这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类</p>\n<pre><code>&lt;input type=&quot;email&quot;&gt;//-&gt; email地址匹配\n&lt;input type=&quot;url&quot;&gt;//-&gt; url地址匹配\n&lt;input type=&quot;tel&quot;&gt;//-&gt; 电话号码\n&lt;input type=&quot;number&quot;&gt;//-&gt; 数字\n&lt;input type=&quot;search&quot;&gt;//-&gt; 搜索框\n&lt;input type=&quot;color&quot;&gt;//-&gt; 拾色器\n&lt;input type=&quot;time&quot;&gt;//-&gt; 时间选择\n&lt;input type=&quot;date&quot;&gt;//-&gt; 日期选择\n&lt;input type=&quot;month&quot;&gt;//-&gt; 月份选择\n&lt;input type=&quot;week&quot;&gt;//-&gt; 周选择\n</code></pre></li>\n</ul>\n<ul>\n<li><p>这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。</p>\n</li>\n<li><p>当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。</p>\n<h2 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h2></li>\n<li><p>表单元素其实就是HTML5中新增加的一些属于表单的新标签。</p>\n</li>\n<li><p>以前我们接触的表单元素有</p>\n<pre><code>&lt;form&gt;&lt;/form&gt;//-&gt; 表单\n&lt;fieldset&gt;&lt;/fieldset&gt;//-&gt; 表单框\n&lt;legend&gt;&lt;/legend&gt;//-&gt; 表单框的标题\n&lt;label&gt;&lt;/label&gt;//-&gt; 表单里的控件标签\n&lt;textarea&gt;&lt;/textarea&gt;//-&gt; 文本区域\n&lt;select&gt;&lt;/select&gt;//-&gt; 选择列表\n&lt;option&gt;&lt;/option&gt;//-&gt; 选择列表的下拉项\n</code></pre></li>\n</ul>\n<h5 id=\"下面是我们HTML5中新增加的表单元素\"><a href=\"#下面是我们HTML5中新增加的表单元素\" class=\"headerlink\" title=\"下面是我们HTML5中新增加的表单元素\"></a>下面是我们HTML5中新增加的表单元素</h5><pre><code>&lt;datalist&gt;&lt;/datalist&gt;//-&gt; 数据列表\n&lt;output&gt;&lt;/output&gt;//-&gt; 输出结果\n&lt;meter&gt;&lt;/meter&gt;//-&gt; 度量器\n&lt;keygen&gt;&lt;/keygen&gt;//-&gt; 生成加密字符串\n</code></pre><ul>\n<li>这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。</li>\n</ul>\n<h4 id=\"表单属性\"><a href=\"#表单属性\" class=\"headerlink\" title=\"表单属性\"></a>表单属性</h4><ul>\n<li>表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。</li>\n<li>比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。</li>\n</ul>\n<pre><code>&lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;&gt;\n</code></pre><ul>\n<li><p>这样的话就只能填写10到20之间的数字了。</p>\n</li>\n<li><p>以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性</p>\n<pre><code>placeholder//-&gt; 占位符\nautofocus//-&gt; 自动获取焦点\nmultiple//-&gt; 多文件上传\nautocomplete//-&gt; 自动填充\nform//-&gt; 表单关联\nnovalidate//-&gt; 关闭验证\nrequired//-&gt; 必填\npattern//-&gt; 自定义验证\n</code></pre></li>\n<li>通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTML5的表单\"><a href=\"#HTML5的表单\" class=\"headerlink\" title=\"HTML5的表单\"></a>HTML5的表单</h2><ul>\n<li>HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。</li>\n<li>输入类型</li>\n</ul>\n<ul>\n<li><p>输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有</p>\n<pre><code>&lt;input type=&quot;text&quot;&gt;//-&gt; 文本框\n&lt;input type=&quot;password&quot;&gt;//-&gt; 密码框\n&lt;input type=&quot;checkbox&quot;&gt;//-&gt; 复选框\n&lt;input type=&quot;radio&quot;&gt;//-&gt; 单选框\n&lt;input type=&quot;submit&quot;&gt;//-&gt; 提交\n&lt;input type=&quot;button&quot;&gt;//-&gt; 按钮\n&lt;input type=&quot;reset&quot;&gt;//-&gt; 重置\n&lt;input type=&quot;file&quot;&gt;//-&gt; 文件选择\n</code></pre></li>\n<li><p>这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类</p>\n<pre><code>&lt;input type=&quot;email&quot;&gt;//-&gt; email地址匹配\n&lt;input type=&quot;url&quot;&gt;//-&gt; url地址匹配\n&lt;input type=&quot;tel&quot;&gt;//-&gt; 电话号码\n&lt;input type=&quot;number&quot;&gt;//-&gt; 数字\n&lt;input type=&quot;search&quot;&gt;//-&gt; 搜索框\n&lt;input type=&quot;color&quot;&gt;//-&gt; 拾色器\n&lt;input type=&quot;time&quot;&gt;//-&gt; 时间选择\n&lt;input type=&quot;date&quot;&gt;//-&gt; 日期选择\n&lt;input type=&quot;month&quot;&gt;//-&gt; 月份选择\n&lt;input type=&quot;week&quot;&gt;//-&gt; 周选择\n</code></pre></li>\n</ul>\n<ul>\n<li><p>这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。</p>\n</li>\n<li><p>当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。</p>\n<h2 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h2></li>\n<li><p>表单元素其实就是HTML5中新增加的一些属于表单的新标签。</p>\n</li>\n<li><p>以前我们接触的表单元素有</p>\n<pre><code>&lt;form&gt;&lt;/form&gt;//-&gt; 表单\n&lt;fieldset&gt;&lt;/fieldset&gt;//-&gt; 表单框\n&lt;legend&gt;&lt;/legend&gt;//-&gt; 表单框的标题\n&lt;label&gt;&lt;/label&gt;//-&gt; 表单里的控件标签\n&lt;textarea&gt;&lt;/textarea&gt;//-&gt; 文本区域\n&lt;select&gt;&lt;/select&gt;//-&gt; 选择列表\n&lt;option&gt;&lt;/option&gt;//-&gt; 选择列表的下拉项\n</code></pre></li>\n</ul>\n<h5 id=\"下面是我们HTML5中新增加的表单元素\"><a href=\"#下面是我们HTML5中新增加的表单元素\" class=\"headerlink\" title=\"下面是我们HTML5中新增加的表单元素\"></a>下面是我们HTML5中新增加的表单元素</h5><pre><code>&lt;datalist&gt;&lt;/datalist&gt;//-&gt; 数据列表\n&lt;output&gt;&lt;/output&gt;//-&gt; 输出结果\n&lt;meter&gt;&lt;/meter&gt;//-&gt; 度量器\n&lt;keygen&gt;&lt;/keygen&gt;//-&gt; 生成加密字符串\n</code></pre><ul>\n<li>这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。</li>\n</ul>\n<h4 id=\"表单属性\"><a href=\"#表单属性\" class=\"headerlink\" title=\"表单属性\"></a>表单属性</h4><ul>\n<li>表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。</li>\n<li>比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。</li>\n</ul>\n<pre><code>&lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;&gt;\n</code></pre><ul>\n<li><p>这样的话就只能填写10到20之间的数字了。</p>\n</li>\n<li><p>以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性</p>\n<pre><code>placeholder//-&gt; 占位符\nautofocus//-&gt; 自动获取焦点\nmultiple//-&gt; 多文件上传\nautocomplete//-&gt; 自动填充\nform//-&gt; 表单关联\nnovalidate//-&gt; 关闭验证\nrequired//-&gt; 必填\npattern//-&gt; 自定义验证\n</code></pre></li>\n<li>通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。</li>\n</ul>\n"},{"title":"less基础语法","_content":"## less语法\n#### 一、注释的区别\n\t/**/会编译在css文件中\n\t//不会编译在css中\n#### 二、声明变量及使用 \n\t@maincolor:#92322;\n\t使用变量 body{ color:@maincolor;}\n#### 三、mixin混入\n\t.redFont{\n\t\tcolor:red;\n\t}\n\t.redBorder {\n\t\tborder:1px solid red;\n\t}\n\t//红色文字和边框 通过class混合\n\t.redFontBorder-class {\n\t\t.redFont();\n\t\t.redBOrder();\n\t}\n\t//方法\n\t.redFont-func(){\n\t\tcolor:red;\n\t}\n\t.redBorder-func(){\n\t\tborder:1px solid red;\n\t}\n\t\n\t//红色文字和边框 通过func混合\n\t.redFontBorder-func{\n\t\t.redFont-func();\n\t\t.redBorder-func();\n\t}\n\n#### 四、嵌套\n\t#header{\n\t\twidth:100px;\n\t\t>div{\n          width:100px;\n\t\t\tp{\n\t\t\t\twidth:100px;\n\t\t\t\t&:hover {\n\t\t\t\t\twidth:100px;\n\t\t\t\t}\n\t\t\t}\n\t\t\t&+div {\n\t\t\t\twidth:100px;\n\t\t\t}\n\t\t\t//&~div {\n\t\t\t\twidth:100px;\n\t\t\t}\n\t\t}\n\t}\n\t直接写在里面就是 后代选择器\n\t&：hover\n\t> 子代选择器\n\t&+ 加号选择器\n\t&~ 波浪选择器\n\n#### 五、导入@import\n\t注意这里引入less文件的时候不用加后缀名\n\t如: @import \"文件名\"；\n\t可以使用引入文件的变量和函数以及类名。\n\n#### 六、运算\n\t颜色运算\n\t@red:red*0.5;\n\t内置函数\n\t@gary:darken(#333,10%);\n\n#### 七、less的使用\n\t引用less文件 注意在引用的时候文件类型写type/less\n\t引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载\n\t注意：他是一部加载less文件　然后解析\n\t一定要求是　使用http形式访问　否则无法加载less文件\n\t不建议使用less.js这种形式来用less\n","source":"_posts/less使用.md","raw":"---\ntitle: less基础语法\ncategories: ['前端']\ntags: ['css预处理器']\n---\n## less语法\n#### 一、注释的区别\n\t/**/会编译在css文件中\n\t//不会编译在css中\n#### 二、声明变量及使用 \n\t@maincolor:#92322;\n\t使用变量 body{ color:@maincolor;}\n#### 三、mixin混入\n\t.redFont{\n\t\tcolor:red;\n\t}\n\t.redBorder {\n\t\tborder:1px solid red;\n\t}\n\t//红色文字和边框 通过class混合\n\t.redFontBorder-class {\n\t\t.redFont();\n\t\t.redBOrder();\n\t}\n\t//方法\n\t.redFont-func(){\n\t\tcolor:red;\n\t}\n\t.redBorder-func(){\n\t\tborder:1px solid red;\n\t}\n\t\n\t//红色文字和边框 通过func混合\n\t.redFontBorder-func{\n\t\t.redFont-func();\n\t\t.redBorder-func();\n\t}\n\n#### 四、嵌套\n\t#header{\n\t\twidth:100px;\n\t\t>div{\n          width:100px;\n\t\t\tp{\n\t\t\t\twidth:100px;\n\t\t\t\t&:hover {\n\t\t\t\t\twidth:100px;\n\t\t\t\t}\n\t\t\t}\n\t\t\t&+div {\n\t\t\t\twidth:100px;\n\t\t\t}\n\t\t\t//&~div {\n\t\t\t\twidth:100px;\n\t\t\t}\n\t\t}\n\t}\n\t直接写在里面就是 后代选择器\n\t&：hover\n\t> 子代选择器\n\t&+ 加号选择器\n\t&~ 波浪选择器\n\n#### 五、导入@import\n\t注意这里引入less文件的时候不用加后缀名\n\t如: @import \"文件名\"；\n\t可以使用引入文件的变量和函数以及类名。\n\n#### 六、运算\n\t颜色运算\n\t@red:red*0.5;\n\t内置函数\n\t@gary:darken(#333,10%);\n\n#### 七、less的使用\n\t引用less文件 注意在引用的时候文件类型写type/less\n\t引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载\n\t注意：他是一部加载less文件　然后解析\n\t一定要求是　使用http形式访问　否则无法加载less文件\n\t不建议使用less.js这种形式来用less\n","slug":"less使用","published":1,"date":"2017-02-10T02:55:16.000Z","updated":"2019-04-26T06:06:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0gz000n7xuq6u9glw5z","content":"<h2 id=\"less语法\"><a href=\"#less语法\" class=\"headerlink\" title=\"less语法\"></a>less语法</h2><h4 id=\"一、注释的区别\"><a href=\"#一、注释的区别\" class=\"headerlink\" title=\"一、注释的区别\"></a>一、注释的区别</h4><pre><code>/**/会编译在css文件中\n//不会编译在css中\n</code></pre><h4 id=\"二、声明变量及使用\"><a href=\"#二、声明变量及使用\" class=\"headerlink\" title=\"二、声明变量及使用\"></a>二、声明变量及使用</h4><pre><code>@maincolor:#92322;\n使用变量 body{ color:@maincolor;}\n</code></pre><h4 id=\"三、mixin混入\"><a href=\"#三、mixin混入\" class=\"headerlink\" title=\"三、mixin混入\"></a>三、mixin混入</h4><pre><code>.redFont{\n    color:red;\n}\n.redBorder {\n    border:1px solid red;\n}\n//红色文字和边框 通过class混合\n.redFontBorder-class {\n    .redFont();\n    .redBOrder();\n}\n//方法\n.redFont-func(){\n    color:red;\n}\n.redBorder-func(){\n    border:1px solid red;\n}\n\n//红色文字和边框 通过func混合\n.redFontBorder-func{\n    .redFont-func();\n    .redBorder-func();\n}\n</code></pre><h4 id=\"四、嵌套\"><a href=\"#四、嵌套\" class=\"headerlink\" title=\"四、嵌套\"></a>四、嵌套</h4><pre><code>#header{\n    width:100px;\n    &gt;div{\n      width:100px;\n        p{\n            width:100px;\n            &amp;:hover {\n                width:100px;\n            }\n        }\n        &amp;+div {\n            width:100px;\n        }\n        //&amp;~div {\n            width:100px;\n        }\n    }\n}\n直接写在里面就是 后代选择器\n&amp;：hover\n&gt; 子代选择器\n&amp;+ 加号选择器\n&amp;~ 波浪选择器\n</code></pre><h4 id=\"五、导入-import\"><a href=\"#五、导入-import\" class=\"headerlink\" title=\"五、导入@import\"></a>五、导入@import</h4><pre><code>注意这里引入less文件的时候不用加后缀名\n如: @import &quot;文件名&quot;；\n可以使用引入文件的变量和函数以及类名。\n</code></pre><h4 id=\"六、运算\"><a href=\"#六、运算\" class=\"headerlink\" title=\"六、运算\"></a>六、运算</h4><pre><code>颜色运算\n@red:red*0.5;\n内置函数\n@gary:darken(#333,10%);\n</code></pre><h4 id=\"七、less的使用\"><a href=\"#七、less的使用\" class=\"headerlink\" title=\"七、less的使用\"></a>七、less的使用</h4><pre><code>引用less文件 注意在引用的时候文件类型写type/less\n引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载\n注意：他是一部加载less文件　然后解析\n一定要求是　使用http形式访问　否则无法加载less文件\n不建议使用less.js这种形式来用less\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"less语法\"><a href=\"#less语法\" class=\"headerlink\" title=\"less语法\"></a>less语法</h2><h4 id=\"一、注释的区别\"><a href=\"#一、注释的区别\" class=\"headerlink\" title=\"一、注释的区别\"></a>一、注释的区别</h4><pre><code>/**/会编译在css文件中\n//不会编译在css中\n</code></pre><h4 id=\"二、声明变量及使用\"><a href=\"#二、声明变量及使用\" class=\"headerlink\" title=\"二、声明变量及使用\"></a>二、声明变量及使用</h4><pre><code>@maincolor:#92322;\n使用变量 body{ color:@maincolor;}\n</code></pre><h4 id=\"三、mixin混入\"><a href=\"#三、mixin混入\" class=\"headerlink\" title=\"三、mixin混入\"></a>三、mixin混入</h4><pre><code>.redFont{\n    color:red;\n}\n.redBorder {\n    border:1px solid red;\n}\n//红色文字和边框 通过class混合\n.redFontBorder-class {\n    .redFont();\n    .redBOrder();\n}\n//方法\n.redFont-func(){\n    color:red;\n}\n.redBorder-func(){\n    border:1px solid red;\n}\n\n//红色文字和边框 通过func混合\n.redFontBorder-func{\n    .redFont-func();\n    .redBorder-func();\n}\n</code></pre><h4 id=\"四、嵌套\"><a href=\"#四、嵌套\" class=\"headerlink\" title=\"四、嵌套\"></a>四、嵌套</h4><pre><code>#header{\n    width:100px;\n    &gt;div{\n      width:100px;\n        p{\n            width:100px;\n            &amp;:hover {\n                width:100px;\n            }\n        }\n        &amp;+div {\n            width:100px;\n        }\n        //&amp;~div {\n            width:100px;\n        }\n    }\n}\n直接写在里面就是 后代选择器\n&amp;：hover\n&gt; 子代选择器\n&amp;+ 加号选择器\n&amp;~ 波浪选择器\n</code></pre><h4 id=\"五、导入-import\"><a href=\"#五、导入-import\" class=\"headerlink\" title=\"五、导入@import\"></a>五、导入@import</h4><pre><code>注意这里引入less文件的时候不用加后缀名\n如: @import &quot;文件名&quot;；\n可以使用引入文件的变量和函数以及类名。\n</code></pre><h4 id=\"六、运算\"><a href=\"#六、运算\" class=\"headerlink\" title=\"六、运算\"></a>六、运算</h4><pre><code>颜色运算\n@red:red*0.5;\n内置函数\n@gary:darken(#333,10%);\n</code></pre><h4 id=\"七、less的使用\"><a href=\"#七、less的使用\" class=\"headerlink\" title=\"七、less的使用\"></a>七、less的使用</h4><pre><code>引用less文件 注意在引用的时候文件类型写type/less\n引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载\n注意：他是一部加载less文件　然后解析\n一定要求是　使用http形式访问　否则无法加载less文件\n不建议使用less.js这种形式来用less\n</code></pre>"},{"title":"npm browser gulp使用","_content":"# 流行框架第2天\n\n\n\n\n### sourceTree , tortoiseGit\n\n\n### npm\n  - 官网[https://www.npmjs.com]\n  - node package manager\n  - 命令:\n    + 初始化:`npm init`\n    + 安装指定包:`npm install jquery --save`\n    + 安装指定包:`npm install jquery@版本号 --save`\n    + 删除指定包:`npm remove jquery --save`\n    + 下载安装package.json中dependencies属性对的文件:`npm install --production`\n\n### browser-sync\n  - 更改代码之后自动刷新浏览器\n  - 需要使用npm进行全局安装:`npm install browser-sync -g`,-g表示安装到全局\n  - 使用:`browser-sync start --server --files \"./index.html,app.css,./css/*.css,*.*\" ``z注意这里父文件和子文件都不要用中文  后面指定文件用双引号`\n  - --files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。\n\n## gulp\n  [官网](http://www.gulpjs.com)\n  [中文网](http://www.gulpjs.com.cn)\n\n- 前端自动化构建工具\n  js压缩,var x,xname，混淆\n  合并.\n  css压缩\n  html压压缩\n\n- grunt ,webpack...\n\n\n### 核心就5个方法\n  - task,gulp中是一个个任务的形式来实现功能。\n    + task('任务名',function(){\n      .....\n    });\n  - src\n    + src('./*.js')\n  - dest('./minjs/')// 指定处理后的文件的输出路径.\n  - watch('./*.js',['任务名1','任务名2']);\n  - run('任务名');//执行指定的任务.\n\n### gulp的安装\n  - 使用npm 进行安装\n  - `npm install gulp-cli -g`;\n\n### gulp 使用\n\n#### 使用时还需要在项目中通过npm非全局安装gulp\n  - `npm install gulp --save-dev`\n\n\n#### 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.\n\n### gulp的一些插件\n  - 也是使用npm安装\n  - 对js代码进行压缩 gulp-uglify\n  - 对代码进行合并 gulp-concat\n  - 对css进行压缩 gulp-cssnano\n  - 对html进行压缩 gulp-htmlmin","source":"_posts/npm browser gulp使用.md","raw":"---\ntitle: npm browser gulp使用\ncategories: ['前端']\ntags: ['工具']\n---\n# 流行框架第2天\n\n\n\n\n### sourceTree , tortoiseGit\n\n\n### npm\n  - 官网[https://www.npmjs.com]\n  - node package manager\n  - 命令:\n    + 初始化:`npm init`\n    + 安装指定包:`npm install jquery --save`\n    + 安装指定包:`npm install jquery@版本号 --save`\n    + 删除指定包:`npm remove jquery --save`\n    + 下载安装package.json中dependencies属性对的文件:`npm install --production`\n\n### browser-sync\n  - 更改代码之后自动刷新浏览器\n  - 需要使用npm进行全局安装:`npm install browser-sync -g`,-g表示安装到全局\n  - 使用:`browser-sync start --server --files \"./index.html,app.css,./css/*.css,*.*\" ``z注意这里父文件和子文件都不要用中文  后面指定文件用双引号`\n  - --files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。\n\n## gulp\n  [官网](http://www.gulpjs.com)\n  [中文网](http://www.gulpjs.com.cn)\n\n- 前端自动化构建工具\n  js压缩,var x,xname，混淆\n  合并.\n  css压缩\n  html压压缩\n\n- grunt ,webpack...\n\n\n### 核心就5个方法\n  - task,gulp中是一个个任务的形式来实现功能。\n    + task('任务名',function(){\n      .....\n    });\n  - src\n    + src('./*.js')\n  - dest('./minjs/')// 指定处理后的文件的输出路径.\n  - watch('./*.js',['任务名1','任务名2']);\n  - run('任务名');//执行指定的任务.\n\n### gulp的安装\n  - 使用npm 进行安装\n  - `npm install gulp-cli -g`;\n\n### gulp 使用\n\n#### 使用时还需要在项目中通过npm非全局安装gulp\n  - `npm install gulp --save-dev`\n\n\n#### 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.\n\n### gulp的一些插件\n  - 也是使用npm安装\n  - 对js代码进行压缩 gulp-uglify\n  - 对代码进行合并 gulp-concat\n  - 对css进行压缩 gulp-cssnano\n  - 对html进行压缩 gulp-htmlmin","slug":"npm browser gulp使用","published":1,"date":"2017-02-18T08:47:55.000Z","updated":"2019-04-26T06:26:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0h0000q7xuq2weeschb","content":"<h1 id=\"流行框架第2天\"><a href=\"#流行框架第2天\" class=\"headerlink\" title=\"流行框架第2天\"></a>流行框架第2天</h1><h3 id=\"sourceTree-tortoiseGit\"><a href=\"#sourceTree-tortoiseGit\" class=\"headerlink\" title=\"sourceTree , tortoiseGit\"></a>sourceTree , tortoiseGit</h3><h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><ul>\n<li>官网[<a href=\"https://www.npmjs.com\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com</a>]</li>\n<li>node package manager</li>\n<li>命令:<ul>\n<li>初始化:<code>npm init</code></li>\n<li>安装指定包:<code>npm install jquery --save</code></li>\n<li>安装指定包:<code>npm install jquery@版本号 --save</code></li>\n<li>删除指定包:<code>npm remove jquery --save</code></li>\n<li>下载安装package.json中dependencies属性对的文件:<code>npm install --production</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"browser-sync\"><a href=\"#browser-sync\" class=\"headerlink\" title=\"browser-sync\"></a>browser-sync</h3><ul>\n<li>更改代码之后自动刷新浏览器</li>\n<li>需要使用npm进行全局安装:<code>npm install browser-sync -g</code>,-g表示安装到全局</li>\n<li>使用:<code>browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; ``z注意这里父文件和子文件都不要用中文  后面指定文件用双引号</code></li>\n<li>–files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。</li>\n</ul>\n<h2 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h2><p>  <a href=\"http://www.gulpjs.com\" target=\"_blank\" rel=\"noopener\">官网</a><br>  <a href=\"http://www.gulpjs.com.cn\" target=\"_blank\" rel=\"noopener\">中文网</a></p>\n<ul>\n<li><p>前端自动化构建工具<br>js压缩,var x,xname，混淆<br>合并.<br>css压缩<br>html压压缩</p>\n</li>\n<li><p>grunt ,webpack…</p>\n</li>\n</ul>\n<h3 id=\"核心就5个方法\"><a href=\"#核心就5个方法\" class=\"headerlink\" title=\"核心就5个方法\"></a>核心就5个方法</h3><ul>\n<li>task,gulp中是一个个任务的形式来实现功能。<ul>\n<li>task(‘任务名’,function(){<br>…..<br>});</li>\n</ul>\n</li>\n<li>src<ul>\n<li>src(‘./*.js’)</li>\n</ul>\n</li>\n<li>dest(‘./minjs/‘)// 指定处理后的文件的输出路径.</li>\n<li>watch(‘./*.js’,[‘任务名1’,’任务名2’]);</li>\n<li>run(‘任务名’);//执行指定的任务.</li>\n</ul>\n<h3 id=\"gulp的安装\"><a href=\"#gulp的安装\" class=\"headerlink\" title=\"gulp的安装\"></a>gulp的安装</h3><ul>\n<li>使用npm 进行安装</li>\n<li><code>npm install gulp-cli -g</code>;</li>\n</ul>\n<h3 id=\"gulp-使用\"><a href=\"#gulp-使用\" class=\"headerlink\" title=\"gulp 使用\"></a>gulp 使用</h3><h4 id=\"使用时还需要在项目中通过npm非全局安装gulp\"><a href=\"#使用时还需要在项目中通过npm非全局安装gulp\" class=\"headerlink\" title=\"使用时还需要在项目中通过npm非全局安装gulp\"></a>使用时还需要在项目中通过npm非全局安装gulp</h4><ul>\n<li><code>npm install gulp --save-dev</code></li>\n</ul>\n<h4 id=\"还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码\"><a href=\"#还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码\" class=\"headerlink\" title=\"还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.\"></a>还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.</h4><h3 id=\"gulp的一些插件\"><a href=\"#gulp的一些插件\" class=\"headerlink\" title=\"gulp的一些插件\"></a>gulp的一些插件</h3><ul>\n<li>也是使用npm安装</li>\n<li>对js代码进行压缩 gulp-uglify</li>\n<li>对代码进行合并 gulp-concat</li>\n<li>对css进行压缩 gulp-cssnano</li>\n<li>对html进行压缩 gulp-htmlmin</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"流行框架第2天\"><a href=\"#流行框架第2天\" class=\"headerlink\" title=\"流行框架第2天\"></a>流行框架第2天</h1><h3 id=\"sourceTree-tortoiseGit\"><a href=\"#sourceTree-tortoiseGit\" class=\"headerlink\" title=\"sourceTree , tortoiseGit\"></a>sourceTree , tortoiseGit</h3><h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><ul>\n<li>官网[<a href=\"https://www.npmjs.com\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com</a>]</li>\n<li>node package manager</li>\n<li>命令:<ul>\n<li>初始化:<code>npm init</code></li>\n<li>安装指定包:<code>npm install jquery --save</code></li>\n<li>安装指定包:<code>npm install jquery@版本号 --save</code></li>\n<li>删除指定包:<code>npm remove jquery --save</code></li>\n<li>下载安装package.json中dependencies属性对的文件:<code>npm install --production</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"browser-sync\"><a href=\"#browser-sync\" class=\"headerlink\" title=\"browser-sync\"></a>browser-sync</h3><ul>\n<li>更改代码之后自动刷新浏览器</li>\n<li>需要使用npm进行全局安装:<code>npm install browser-sync -g</code>,-g表示安装到全局</li>\n<li>使用:<code>browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; ``z注意这里父文件和子文件都不要用中文  后面指定文件用双引号</code></li>\n<li>–files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。</li>\n</ul>\n<h2 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h2><p>  <a href=\"http://www.gulpjs.com\" target=\"_blank\" rel=\"noopener\">官网</a><br>  <a href=\"http://www.gulpjs.com.cn\" target=\"_blank\" rel=\"noopener\">中文网</a></p>\n<ul>\n<li><p>前端自动化构建工具<br>js压缩,var x,xname，混淆<br>合并.<br>css压缩<br>html压压缩</p>\n</li>\n<li><p>grunt ,webpack…</p>\n</li>\n</ul>\n<h3 id=\"核心就5个方法\"><a href=\"#核心就5个方法\" class=\"headerlink\" title=\"核心就5个方法\"></a>核心就5个方法</h3><ul>\n<li>task,gulp中是一个个任务的形式来实现功能。<ul>\n<li>task(‘任务名’,function(){<br>…..<br>});</li>\n</ul>\n</li>\n<li>src<ul>\n<li>src(‘./*.js’)</li>\n</ul>\n</li>\n<li>dest(‘./minjs/‘)// 指定处理后的文件的输出路径.</li>\n<li>watch(‘./*.js’,[‘任务名1’,’任务名2’]);</li>\n<li>run(‘任务名’);//执行指定的任务.</li>\n</ul>\n<h3 id=\"gulp的安装\"><a href=\"#gulp的安装\" class=\"headerlink\" title=\"gulp的安装\"></a>gulp的安装</h3><ul>\n<li>使用npm 进行安装</li>\n<li><code>npm install gulp-cli -g</code>;</li>\n</ul>\n<h3 id=\"gulp-使用\"><a href=\"#gulp-使用\" class=\"headerlink\" title=\"gulp 使用\"></a>gulp 使用</h3><h4 id=\"使用时还需要在项目中通过npm非全局安装gulp\"><a href=\"#使用时还需要在项目中通过npm非全局安装gulp\" class=\"headerlink\" title=\"使用时还需要在项目中通过npm非全局安装gulp\"></a>使用时还需要在项目中通过npm非全局安装gulp</h4><ul>\n<li><code>npm install gulp --save-dev</code></li>\n</ul>\n<h4 id=\"还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码\"><a href=\"#还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码\" class=\"headerlink\" title=\"还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.\"></a>还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.</h4><h3 id=\"gulp的一些插件\"><a href=\"#gulp的一些插件\" class=\"headerlink\" title=\"gulp的一些插件\"></a>gulp的一些插件</h3><ul>\n<li>也是使用npm安装</li>\n<li>对js代码进行压缩 gulp-uglify</li>\n<li>对代码进行合并 gulp-concat</li>\n<li>对css进行压缩 gulp-cssnano</li>\n<li>对html进行压缩 gulp-htmlmin</li>\n</ul>\n"},{"title":"seajs和requirejs","_content":"## 为什么要使用模块化\n1. 全局变量、全局函数，容易造成变量名冲突\n2. 页面引入了一堆的js文件，存在先后顺序的问题\n\t+ 代码由于组织混乱很容易出错\n\t+ 出错了很难调试\n\t+ 后期难以维护\n3. 模块化的好处\n\t+ 提升开发效率\n\t+ 便于后期维护\n\n## 模块化理解\n模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。\n\n#### cmd规范特性\n- 一个模块就是一个单独的文件\n- 由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域\n- 预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块）\n\n#### 关键字\n- define\t定义一个模块\n- require\t加载一个模块\n- exports\t暴露一个模块\n- module\t模块\n\n#### 注意点\n- define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem\n- 如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 --> 推荐写全，不要省\n- 如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略\n- seajs.use(\"入口模块\")可以加回调函数，形式如：seajs.use(\"入口模块\",callback);\n\n#### 路径问题\n\n1. 在sea.js当中，js/main和./js/main的含义不是一样的\n\t+ js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 --> SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径)\n\t+ ./js/main代表的是以当前html文件去找js文件夹下面的main.js\n\t+ require(\"xxx\") --> 其实这里的xxx叫模块标识，不是路径\n\n2. config的作用就是为了简化调用模块\n\t+ base 设置路径\n\t+ alias 设置模块的别名，简化调用\n\n\n\n## seajs使用\n#### 1. 引包 \n\t<script src=\"js/sea.js\"></script>\n#### 2. 入口模块 \n\t//为了简洁，路径最好不加.js\n\t//加载完成后触发回调函数\n\t//简化调用模块\n\tseajs.config({\n\t//base 设置路径\n\t//alias 设置模块的别名，简化调用\n\t\tbase:\"./js\"\n\t\talias:{\t\n\t\t\tm:\"main\"\n\t\t}\n\t})\n\tseajs.use(\"./js/main\",function(){ \n\t  console.log('代码执行成功');\n\t});\n#### 3. 主模块\n\t// 名字写全 并且顺序和单词都要写对（便于记住rem）\n\tdefine(function (require, exports, module) {\n\t// require 方法得到的就是指定的模块中向外暴露的接口对象 \tmodule.exports\n\t// var fooModule = require('./foo')\n\t// console.log(fooModule.foo)\n\tvar foo = require('./foo')\n\t\tconsole.log(foo)\n\t});\n#### 4. 第三方模块\n\tdefine(function (require, exports, module) {\n\t// 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的\n\tvar foo = 'bar';\n\t// 默认情况下 module.exports 就是一个空对象\n\t// module.exports.foo = foo\n\t\n\tmodule.exports = 'bar';\n\t});\n\n#### sea.js把非cmd模块转换成cmd模块\n\t\t// 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用\n\t\tif (typeof define === 'function' && define.cmd) {\n\t\t\tdefine(function(require,exports,module){\n\t\t\t\tmodule.exports = jQuery;\n\t\t\t});\n\t\t}\n\n## require.js\n#### 引包\n\t//data-main引入主模块包\n\t<script src=\"js/lib/require.js\" data-main=\"js/app/main\"></script>\n\n\n\t//如果想用jQuery,则必须配置如下：\n    require.config({\n      baseUrl:'./js/app/',//这里设置的是main的路径\n      paths:{\n        \"jquery\":\"../lib/jquery\"\n      }\n    });\n\n#### main\n\t//类似angular\n\t//['./cal']映入第三方模块\n\trequirejs(['./cal'],function(calculator){\n\t\t\t\n\t\t\t});\n#### 第三方模块\n\tdefine(function(){\n\t\t//用return 提供接口暴露数据\n\t\treturn \n\t});","source":"_posts/seajs  and requirejs.md","raw":"---\ntitle: seajs和requirejs\ncategories: ['前端']\ntags: ['模块化开发']\n---\n## 为什么要使用模块化\n1. 全局变量、全局函数，容易造成变量名冲突\n2. 页面引入了一堆的js文件，存在先后顺序的问题\n\t+ 代码由于组织混乱很容易出错\n\t+ 出错了很难调试\n\t+ 后期难以维护\n3. 模块化的好处\n\t+ 提升开发效率\n\t+ 便于后期维护\n\n## 模块化理解\n模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。\n\n#### cmd规范特性\n- 一个模块就是一个单独的文件\n- 由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域\n- 预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块）\n\n#### 关键字\n- define\t定义一个模块\n- require\t加载一个模块\n- exports\t暴露一个模块\n- module\t模块\n\n#### 注意点\n- define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem\n- 如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 --> 推荐写全，不要省\n- 如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略\n- seajs.use(\"入口模块\")可以加回调函数，形式如：seajs.use(\"入口模块\",callback);\n\n#### 路径问题\n\n1. 在sea.js当中，js/main和./js/main的含义不是一样的\n\t+ js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 --> SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径)\n\t+ ./js/main代表的是以当前html文件去找js文件夹下面的main.js\n\t+ require(\"xxx\") --> 其实这里的xxx叫模块标识，不是路径\n\n2. config的作用就是为了简化调用模块\n\t+ base 设置路径\n\t+ alias 设置模块的别名，简化调用\n\n\n\n## seajs使用\n#### 1. 引包 \n\t<script src=\"js/sea.js\"></script>\n#### 2. 入口模块 \n\t//为了简洁，路径最好不加.js\n\t//加载完成后触发回调函数\n\t//简化调用模块\n\tseajs.config({\n\t//base 设置路径\n\t//alias 设置模块的别名，简化调用\n\t\tbase:\"./js\"\n\t\talias:{\t\n\t\t\tm:\"main\"\n\t\t}\n\t})\n\tseajs.use(\"./js/main\",function(){ \n\t  console.log('代码执行成功');\n\t});\n#### 3. 主模块\n\t// 名字写全 并且顺序和单词都要写对（便于记住rem）\n\tdefine(function (require, exports, module) {\n\t// require 方法得到的就是指定的模块中向外暴露的接口对象 \tmodule.exports\n\t// var fooModule = require('./foo')\n\t// console.log(fooModule.foo)\n\tvar foo = require('./foo')\n\t\tconsole.log(foo)\n\t});\n#### 4. 第三方模块\n\tdefine(function (require, exports, module) {\n\t// 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的\n\tvar foo = 'bar';\n\t// 默认情况下 module.exports 就是一个空对象\n\t// module.exports.foo = foo\n\t\n\tmodule.exports = 'bar';\n\t});\n\n#### sea.js把非cmd模块转换成cmd模块\n\t\t// 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用\n\t\tif (typeof define === 'function' && define.cmd) {\n\t\t\tdefine(function(require,exports,module){\n\t\t\t\tmodule.exports = jQuery;\n\t\t\t});\n\t\t}\n\n## require.js\n#### 引包\n\t//data-main引入主模块包\n\t<script src=\"js/lib/require.js\" data-main=\"js/app/main\"></script>\n\n\n\t//如果想用jQuery,则必须配置如下：\n    require.config({\n      baseUrl:'./js/app/',//这里设置的是main的路径\n      paths:{\n        \"jquery\":\"../lib/jquery\"\n      }\n    });\n\n#### main\n\t//类似angular\n\t//['./cal']映入第三方模块\n\trequirejs(['./cal'],function(calculator){\n\t\t\t\n\t\t\t});\n#### 第三方模块\n\tdefine(function(){\n\t\t//用return 提供接口暴露数据\n\t\treturn \n\t});","slug":"seajs  and requirejs","published":1,"date":"2017-03-04T04:50:07.000Z","updated":"2019-04-26T06:09:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0h2000t7xuq8hbg061j","content":"<h2 id=\"为什么要使用模块化\"><a href=\"#为什么要使用模块化\" class=\"headerlink\" title=\"为什么要使用模块化\"></a>为什么要使用模块化</h2><ol>\n<li>全局变量、全局函数，容易造成变量名冲突</li>\n<li>页面引入了一堆的js文件，存在先后顺序的问题<ul>\n<li>代码由于组织混乱很容易出错</li>\n<li>出错了很难调试</li>\n<li>后期难以维护</li>\n</ul>\n</li>\n<li>模块化的好处<ul>\n<li>提升开发效率</li>\n<li>便于后期维护</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"模块化理解\"><a href=\"#模块化理解\" class=\"headerlink\" title=\"模块化理解\"></a>模块化理解</h2><p>模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。</p>\n<h4 id=\"cmd规范特性\"><a href=\"#cmd规范特性\" class=\"headerlink\" title=\"cmd规范特性\"></a>cmd规范特性</h4><ul>\n<li>一个模块就是一个单独的文件</li>\n<li>由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域</li>\n<li>预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块）</li>\n</ul>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><ul>\n<li>define    定义一个模块</li>\n<li>require    加载一个模块</li>\n<li>exports    暴露一个模块</li>\n<li>module    模块</li>\n</ul>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ul>\n<li>define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem</li>\n<li>如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 –&gt; 推荐写全，不要省</li>\n<li>如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略</li>\n<li>seajs.use(“入口模块”)可以加回调函数，形式如：seajs.use(“入口模块”,callback);</li>\n</ul>\n<h4 id=\"路径问题\"><a href=\"#路径问题\" class=\"headerlink\" title=\"路径问题\"></a>路径问题</h4><ol>\n<li><p>在sea.js当中，js/main和./js/main的含义不是一样的</p>\n<ul>\n<li>js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 –&gt; SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径)</li>\n<li>./js/main代表的是以当前html文件去找js文件夹下面的main.js</li>\n<li>require(“xxx”) –&gt; 其实这里的xxx叫模块标识，不是路径</li>\n</ul>\n</li>\n<li><p>config的作用就是为了简化调用模块</p>\n<ul>\n<li>base 设置路径</li>\n<li>alias 设置模块的别名，简化调用</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"seajs使用\"><a href=\"#seajs使用\" class=\"headerlink\" title=\"seajs使用\"></a>seajs使用</h2><h4 id=\"1-引包\"><a href=\"#1-引包\" class=\"headerlink\" title=\"1. 引包\"></a>1. 引包</h4><pre><code>&lt;script src=&quot;js/sea.js&quot;&gt;&lt;/script&gt;\n</code></pre><h4 id=\"2-入口模块\"><a href=\"#2-入口模块\" class=\"headerlink\" title=\"2. 入口模块\"></a>2. 入口模块</h4><pre><code>//为了简洁，路径最好不加.js\n//加载完成后触发回调函数\n//简化调用模块\nseajs.config({\n//base 设置路径\n//alias 设置模块的别名，简化调用\n    base:&quot;./js&quot;\n    alias:{    \n        m:&quot;main&quot;\n    }\n})\nseajs.use(&quot;./js/main&quot;,function(){ \n  console.log(&apos;代码执行成功&apos;);\n});\n</code></pre><h4 id=\"3-主模块\"><a href=\"#3-主模块\" class=\"headerlink\" title=\"3. 主模块\"></a>3. 主模块</h4><pre><code>// 名字写全 并且顺序和单词都要写对（便于记住rem）\ndefine(function (require, exports, module) {\n// require 方法得到的就是指定的模块中向外暴露的接口对象     module.exports\n// var fooModule = require(&apos;./foo&apos;)\n// console.log(fooModule.foo)\nvar foo = require(&apos;./foo&apos;)\n    console.log(foo)\n});\n</code></pre><h4 id=\"4-第三方模块\"><a href=\"#4-第三方模块\" class=\"headerlink\" title=\"4. 第三方模块\"></a>4. 第三方模块</h4><pre><code>define(function (require, exports, module) {\n// 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的\nvar foo = &apos;bar&apos;;\n// 默认情况下 module.exports 就是一个空对象\n// module.exports.foo = foo\n\nmodule.exports = &apos;bar&apos;;\n});\n</code></pre><h4 id=\"sea-js把非cmd模块转换成cmd模块\"><a href=\"#sea-js把非cmd模块转换成cmd模块\" class=\"headerlink\" title=\"sea.js把非cmd模块转换成cmd模块\"></a>sea.js把非cmd模块转换成cmd模块</h4><pre><code>// 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用\nif (typeof define === &apos;function&apos; &amp;&amp; define.cmd) {\n    define(function(require,exports,module){\n        module.exports = jQuery;\n    });\n}\n</code></pre><h2 id=\"require-js\"><a href=\"#require-js\" class=\"headerlink\" title=\"require.js\"></a>require.js</h2><h4 id=\"引包\"><a href=\"#引包\" class=\"headerlink\" title=\"引包\"></a>引包</h4><pre><code>//data-main引入主模块包\n&lt;script src=&quot;js/lib/require.js&quot; data-main=&quot;js/app/main&quot;&gt;&lt;/script&gt;\n\n\n//如果想用jQuery,则必须配置如下：\nrequire.config({\n  baseUrl:&apos;./js/app/&apos;,//这里设置的是main的路径\n  paths:{\n    &quot;jquery&quot;:&quot;../lib/jquery&quot;\n  }\n});\n</code></pre><h4 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h4><pre><code>//类似angular\n//[&apos;./cal&apos;]映入第三方模块\nrequirejs([&apos;./cal&apos;],function(calculator){\n\n        });\n</code></pre><h4 id=\"第三方模块\"><a href=\"#第三方模块\" class=\"headerlink\" title=\"第三方模块\"></a>第三方模块</h4><pre><code>define(function(){\n    //用return 提供接口暴露数据\n    return \n});\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要使用模块化\"><a href=\"#为什么要使用模块化\" class=\"headerlink\" title=\"为什么要使用模块化\"></a>为什么要使用模块化</h2><ol>\n<li>全局变量、全局函数，容易造成变量名冲突</li>\n<li>页面引入了一堆的js文件，存在先后顺序的问题<ul>\n<li>代码由于组织混乱很容易出错</li>\n<li>出错了很难调试</li>\n<li>后期难以维护</li>\n</ul>\n</li>\n<li>模块化的好处<ul>\n<li>提升开发效率</li>\n<li>便于后期维护</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"模块化理解\"><a href=\"#模块化理解\" class=\"headerlink\" title=\"模块化理解\"></a>模块化理解</h2><p>模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。</p>\n<h4 id=\"cmd规范特性\"><a href=\"#cmd规范特性\" class=\"headerlink\" title=\"cmd规范特性\"></a>cmd规范特性</h4><ul>\n<li>一个模块就是一个单独的文件</li>\n<li>由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域</li>\n<li>预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块）</li>\n</ul>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><ul>\n<li>define    定义一个模块</li>\n<li>require    加载一个模块</li>\n<li>exports    暴露一个模块</li>\n<li>module    模块</li>\n</ul>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ul>\n<li>define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem</li>\n<li>如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 –&gt; 推荐写全，不要省</li>\n<li>如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略</li>\n<li>seajs.use(“入口模块”)可以加回调函数，形式如：seajs.use(“入口模块”,callback);</li>\n</ul>\n<h4 id=\"路径问题\"><a href=\"#路径问题\" class=\"headerlink\" title=\"路径问题\"></a>路径问题</h4><ol>\n<li><p>在sea.js当中，js/main和./js/main的含义不是一样的</p>\n<ul>\n<li>js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 –&gt; SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径)</li>\n<li>./js/main代表的是以当前html文件去找js文件夹下面的main.js</li>\n<li>require(“xxx”) –&gt; 其实这里的xxx叫模块标识，不是路径</li>\n</ul>\n</li>\n<li><p>config的作用就是为了简化调用模块</p>\n<ul>\n<li>base 设置路径</li>\n<li>alias 设置模块的别名，简化调用</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"seajs使用\"><a href=\"#seajs使用\" class=\"headerlink\" title=\"seajs使用\"></a>seajs使用</h2><h4 id=\"1-引包\"><a href=\"#1-引包\" class=\"headerlink\" title=\"1. 引包\"></a>1. 引包</h4><pre><code>&lt;script src=&quot;js/sea.js&quot;&gt;&lt;/script&gt;\n</code></pre><h4 id=\"2-入口模块\"><a href=\"#2-入口模块\" class=\"headerlink\" title=\"2. 入口模块\"></a>2. 入口模块</h4><pre><code>//为了简洁，路径最好不加.js\n//加载完成后触发回调函数\n//简化调用模块\nseajs.config({\n//base 设置路径\n//alias 设置模块的别名，简化调用\n    base:&quot;./js&quot;\n    alias:{    \n        m:&quot;main&quot;\n    }\n})\nseajs.use(&quot;./js/main&quot;,function(){ \n  console.log(&apos;代码执行成功&apos;);\n});\n</code></pre><h4 id=\"3-主模块\"><a href=\"#3-主模块\" class=\"headerlink\" title=\"3. 主模块\"></a>3. 主模块</h4><pre><code>// 名字写全 并且顺序和单词都要写对（便于记住rem）\ndefine(function (require, exports, module) {\n// require 方法得到的就是指定的模块中向外暴露的接口对象     module.exports\n// var fooModule = require(&apos;./foo&apos;)\n// console.log(fooModule.foo)\nvar foo = require(&apos;./foo&apos;)\n    console.log(foo)\n});\n</code></pre><h4 id=\"4-第三方模块\"><a href=\"#4-第三方模块\" class=\"headerlink\" title=\"4. 第三方模块\"></a>4. 第三方模块</h4><pre><code>define(function (require, exports, module) {\n// 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的\nvar foo = &apos;bar&apos;;\n// 默认情况下 module.exports 就是一个空对象\n// module.exports.foo = foo\n\nmodule.exports = &apos;bar&apos;;\n});\n</code></pre><h4 id=\"sea-js把非cmd模块转换成cmd模块\"><a href=\"#sea-js把非cmd模块转换成cmd模块\" class=\"headerlink\" title=\"sea.js把非cmd模块转换成cmd模块\"></a>sea.js把非cmd模块转换成cmd模块</h4><pre><code>// 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用\nif (typeof define === &apos;function&apos; &amp;&amp; define.cmd) {\n    define(function(require,exports,module){\n        module.exports = jQuery;\n    });\n}\n</code></pre><h2 id=\"require-js\"><a href=\"#require-js\" class=\"headerlink\" title=\"require.js\"></a>require.js</h2><h4 id=\"引包\"><a href=\"#引包\" class=\"headerlink\" title=\"引包\"></a>引包</h4><pre><code>//data-main引入主模块包\n&lt;script src=&quot;js/lib/require.js&quot; data-main=&quot;js/app/main&quot;&gt;&lt;/script&gt;\n\n\n//如果想用jQuery,则必须配置如下：\nrequire.config({\n  baseUrl:&apos;./js/app/&apos;,//这里设置的是main的路径\n  paths:{\n    &quot;jquery&quot;:&quot;../lib/jquery&quot;\n  }\n});\n</code></pre><h4 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h4><pre><code>//类似angular\n//[&apos;./cal&apos;]映入第三方模块\nrequirejs([&apos;./cal&apos;],function(calculator){\n\n        });\n</code></pre><h4 id=\"第三方模块\"><a href=\"#第三方模块\" class=\"headerlink\" title=\"第三方模块\"></a>第三方模块</h4><pre><code>define(function(){\n    //用return 提供接口暴露数据\n    return \n});\n</code></pre>"},{"title":"事件冒泡和捕获","_content":"##事件冒泡和捕获\n#### 事件冒泡\n\t当一个元素接收到事件的时候，会把他接收到的事件传给他的父级，一直到顶层window，事件冒泡机制。\n###### 事件冒泡阻止\n\te.cancelBubble = true;//阻止当前对象的当前事件冒泡\n\te.stopPropagation();\n###### 开启事件捕获\n\telement.addEventListener(eventName,handler,true)\n\t","source":"_posts/事件冒泡与捕获.md","raw":"---\ntitle: 事件冒泡和捕获\ncategories: ['前端']\ntags: ['javaScript']\n---\n##事件冒泡和捕获\n#### 事件冒泡\n\t当一个元素接收到事件的时候，会把他接收到的事件传给他的父级，一直到顶层window，事件冒泡机制。\n###### 事件冒泡阻止\n\te.cancelBubble = true;//阻止当前对象的当前事件冒泡\n\te.stopPropagation();\n###### 开启事件捕获\n\telement.addEventListener(eventName,handler,true)\n\t","slug":"事件冒泡与捕获","published":1,"date":"2017-02-25T14:39:04.000Z","updated":"2019-04-26T06:56:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0h3000w7xuq1dy021so","content":"<p>##事件冒泡和捕获</p>\n<h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><pre><code>当一个元素接收到事件的时候，会把他接收到的事件传给他的父级，一直到顶层window，事件冒泡机制。\n</code></pre><h6 id=\"事件冒泡阻止\"><a href=\"#事件冒泡阻止\" class=\"headerlink\" title=\"事件冒泡阻止\"></a>事件冒泡阻止</h6><pre><code>e.cancelBubble = true;//阻止当前对象的当前事件冒泡\ne.stopPropagation();\n</code></pre><h6 id=\"开启事件捕获\"><a href=\"#开启事件捕获\" class=\"headerlink\" title=\"开启事件捕获\"></a>开启事件捕获</h6><pre><code>element.addEventListener(eventName,handler,true)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>##事件冒泡和捕获</p>\n<h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><pre><code>当一个元素接收到事件的时候，会把他接收到的事件传给他的父级，一直到顶层window，事件冒泡机制。\n</code></pre><h6 id=\"事件冒泡阻止\"><a href=\"#事件冒泡阻止\" class=\"headerlink\" title=\"事件冒泡阻止\"></a>事件冒泡阻止</h6><pre><code>e.cancelBubble = true;//阻止当前对象的当前事件冒泡\ne.stopPropagation();\n</code></pre><h6 id=\"开启事件捕获\"><a href=\"#开启事件捕获\" class=\"headerlink\" title=\"开启事件捕获\"></a>开启事件捕获</h6><pre><code>element.addEventListener(eventName,handler,true)\n</code></pre>"},{"title":"javaScript 字符串操作","_content":"# javaScript 字符串操作\n1. 获取字符串长度Length属性\nstring.length\n2. 连接字符串：concat\ns1.concat(1,2,3);\n3. 获取索引值：indexOf()\nstring.indexof(\"v\")\nstring.indexof(\"v\",fromIndex)\n如果没有就返回-1\n表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找\n若fromIndex为负，则从索引0开始查找.\n4. 根据索引值获取单个字符：charAt()\n5. substr(fromIndex,length)\n获取部分字符串从起始索引fromIndex开始截取长度length的字符串\n6. substring(startIndex,endIndex)\n获取部分字符串\n截取 起始索引startIndex  到  结束索引endIndex的子字符串，\n结果包含startIndex处的字符，不包含endIndex处的字符。\n7. slice(startIndex,endIndex)\n获取部分字符串\n截取 起始索引startIndex  到  结束索引endIndex的子字符串，\n结果包含startIndex处的字符，不包含endIndex处的字符。\n8. split()分割\n按给定字符串分割，返回分割后的多个字符串组成的字符串数组。\n9. Join()合并\n使用您选择的分隔符将一个数组合并为一个字符串\n10. toLowerCase()转小写\ntoUpperCase()转大写\n字符串大小写转换\n使用您选择的分隔符将一个数组合并为一个字符串","source":"_posts/字符串方法.md","raw":"---\ntitle: javaScript 字符串操作\ncategories: ['前端']\ntags: ['javaScript']\n---\n# javaScript 字符串操作\n1. 获取字符串长度Length属性\nstring.length\n2. 连接字符串：concat\ns1.concat(1,2,3);\n3. 获取索引值：indexOf()\nstring.indexof(\"v\")\nstring.indexof(\"v\",fromIndex)\n如果没有就返回-1\n表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找\n若fromIndex为负，则从索引0开始查找.\n4. 根据索引值获取单个字符：charAt()\n5. substr(fromIndex,length)\n获取部分字符串从起始索引fromIndex开始截取长度length的字符串\n6. substring(startIndex,endIndex)\n获取部分字符串\n截取 起始索引startIndex  到  结束索引endIndex的子字符串，\n结果包含startIndex处的字符，不包含endIndex处的字符。\n7. slice(startIndex,endIndex)\n获取部分字符串\n截取 起始索引startIndex  到  结束索引endIndex的子字符串，\n结果包含startIndex处的字符，不包含endIndex处的字符。\n8. split()分割\n按给定字符串分割，返回分割后的多个字符串组成的字符串数组。\n9. Join()合并\n使用您选择的分隔符将一个数组合并为一个字符串\n10. toLowerCase()转小写\ntoUpperCase()转大写\n字符串大小写转换\n使用您选择的分隔符将一个数组合并为一个字符串","slug":"字符串方法","published":1,"date":"2016-12-26T00:59:17.000Z","updated":"2019-04-26T06:04:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0h4000z7xuq7gq2wpia","content":"<h1 id=\"javaScript-字符串操作\"><a href=\"#javaScript-字符串操作\" class=\"headerlink\" title=\"javaScript 字符串操作\"></a>javaScript 字符串操作</h1><ol>\n<li>获取字符串长度Length属性<br>string.length</li>\n<li>连接字符串：concat<br>s1.concat(1,2,3);</li>\n<li>获取索引值：indexOf()<br>string.indexof(“v”)<br>string.indexof(“v”,fromIndex)<br>如果没有就返回-1<br>表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找<br>若fromIndex为负，则从索引0开始查找.</li>\n<li>根据索引值获取单个字符：charAt()</li>\n<li>substr(fromIndex,length)<br>获取部分字符串从起始索引fromIndex开始截取长度length的字符串</li>\n<li>substring(startIndex,endIndex)<br>获取部分字符串<br>截取 起始索引startIndex  到  结束索引endIndex的子字符串，<br>结果包含startIndex处的字符，不包含endIndex处的字符。</li>\n<li>slice(startIndex,endIndex)<br>获取部分字符串<br>截取 起始索引startIndex  到  结束索引endIndex的子字符串，<br>结果包含startIndex处的字符，不包含endIndex处的字符。</li>\n<li>split()分割<br>按给定字符串分割，返回分割后的多个字符串组成的字符串数组。</li>\n<li>Join()合并<br>使用您选择的分隔符将一个数组合并为一个字符串</li>\n<li>toLowerCase()转小写<br>toUpperCase()转大写<br>字符串大小写转换<br>使用您选择的分隔符将一个数组合并为一个字符串</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"javaScript-字符串操作\"><a href=\"#javaScript-字符串操作\" class=\"headerlink\" title=\"javaScript 字符串操作\"></a>javaScript 字符串操作</h1><ol>\n<li>获取字符串长度Length属性<br>string.length</li>\n<li>连接字符串：concat<br>s1.concat(1,2,3);</li>\n<li>获取索引值：indexOf()<br>string.indexof(“v”)<br>string.indexof(“v”,fromIndex)<br>如果没有就返回-1<br>表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找<br>若fromIndex为负，则从索引0开始查找.</li>\n<li>根据索引值获取单个字符：charAt()</li>\n<li>substr(fromIndex,length)<br>获取部分字符串从起始索引fromIndex开始截取长度length的字符串</li>\n<li>substring(startIndex,endIndex)<br>获取部分字符串<br>截取 起始索引startIndex  到  结束索引endIndex的子字符串，<br>结果包含startIndex处的字符，不包含endIndex处的字符。</li>\n<li>slice(startIndex,endIndex)<br>获取部分字符串<br>截取 起始索引startIndex  到  结束索引endIndex的子字符串，<br>结果包含startIndex处的字符，不包含endIndex处的字符。</li>\n<li>split()分割<br>按给定字符串分割，返回分割后的多个字符串组成的字符串数组。</li>\n<li>Join()合并<br>使用您选择的分隔符将一个数组合并为一个字符串</li>\n<li>toLowerCase()转小写<br>toUpperCase()转大写<br>字符串大小写转换<br>使用您选择的分隔符将一个数组合并为一个字符串</li>\n</ol>\n"},{"title":"正则","_content":"##正则表达式\n####RegExp对象创建的方法\n\t\n\tnew RegExp(\"a\",\"i\"); //后面的i就是忽略字母大小写。\n\t/a/i //后面的i就是忽略字母大小写。\n\tg全局\n\t+0个或者多个\n\t| 或者\n\t[a,b,c] a或者b或者c\n\t[0-9]数字\n\t[a-z]字符\n\t[0-9a-z]数字字符\n\t[^a]除了a\n\t+ 1个或者多个\n\t？0个或者1个\n\t*0或者多个\n\t\\转移符\n    \n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则\ncategories: ['前端']\ntags: ['javaScript']\n---\n##正则表达式\n####RegExp对象创建的方法\n\t\n\tnew RegExp(\"a\",\"i\"); //后面的i就是忽略字母大小写。\n\t/a/i //后面的i就是忽略字母大小写。\n\tg全局\n\t+0个或者多个\n\t| 或者\n\t[a,b,c] a或者b或者c\n\t[0-9]数字\n\t[a-z]字符\n\t[0-9a-z]数字字符\n\t[^a]除了a\n\t+ 1个或者多个\n\t？0个或者1个\n\t*0或者多个\n\t\\转移符\n    \n","slug":"正则表达式","published":1,"date":"2017-02-12T15:11:44.000Z","updated":"2019-04-26T06:27:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0h500127xuqkdbuc20g","content":"<p>##正则表达式</p>\n<p>####RegExp对象创建的方法</p>\n<pre><code>new RegExp(&quot;a&quot;,&quot;i&quot;); //后面的i就是忽略字母大小写。\n/a/i //后面的i就是忽略字母大小写。\ng全局\n+0个或者多个\n| 或者\n[a,b,c] a或者b或者c\n[0-9]数字\n[a-z]字符\n[0-9a-z]数字字符\n[^a]除了a\n+ 1个或者多个\n？0个或者1个\n*0或者多个\n\\转移符\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>##正则表达式</p>\n<p>####RegExp对象创建的方法</p>\n<pre><code>new RegExp(&quot;a&quot;,&quot;i&quot;); //后面的i就是忽略字母大小写。\n/a/i //后面的i就是忽略字母大小写。\ng全局\n+0个或者多个\n| 或者\n[a,b,c] a或者b或者c\n[0-9]数字\n[a-z]字符\n[0-9a-z]数字字符\n[^a]除了a\n+ 1个或者多个\n？0个或者1个\n*0或者多个\n\\转移符\n</code></pre>"},{"title":"html5基础二","_content":"1,window.addEventListener\n\n2,onLine \"L\"大写的时候是一个属性，后面不用加括号，直接调用就行，返回一个布尔值。用法:alert（window.navigator.onLine）;返回浏览器是否联网（boolean值）\nonlone \"l\"小写的时候是一件事件，这个事件只能用dom二级事件来绑定\n“navigator”是window上的一个属性，所以写的时候window可以不写，但是建议写上（代码的完整性）\nonline事件在pc端的时候一定是从离线状态变到上线状态的时候才会触发。\n\n2,判断当前设备状态\n2.1 监听设备在线\nwindow.addEventListener('online', function () {\n\t\t\t// alert('online');\n\t\t\t$('.tips').text('网络已连接').fadeIn(500).delay(1000).fadeOut();\n\t\t});\ndelay(时间值)方法 ：是设置延迟时间。\n\n2.2 监听设备离线\nwindow.addEventListener('offline', function () {\n\t\t\t// alert('offline');\n\t\t\t$('.tips').text('网络已断开').fadeIn(500).delay(1000).fadeOut();\n\t\t});\n\n\n3，html全屏 document.documentElement.webkitRequestFullScreen();\n\n任意元素全屏显示\nnode.webkitRequestFullScreen();（谷歌浏览器加webkit）\nnode.mozRequestFullScreen();（火狐加moz）\n任意元素关闭全屏显示\nNode.cancelFullScreen()（理论是这样关闭实际上是用document.webkitCancelFullScreen()关闭）\n\n兼容写法：\t\t\t\t\tfunction FullScreen(node){\n\t\t\tif (node.mozRequestFullScreen){\n\t\t\t\tnode.mozRequestFullScreen();\n\t\t\t}\n\t\t\telse if(node.webkitRequestFullScreen){\n\t\t\t\tnode.webkitRequestFullScreen();\n\t\t\t}else if(node.msRequestFullScreen){\n\t\t\t\tnode.msRequestFullScreen();\n\t\t\t}else if(node.oRequestFullScreen){\n\t\t\t\tnode.oRequestFullScreen();\n\t\t\t}\n\t\t}\n\n\n4，所有元素只能通过document才能调用关闭全屏\ndocument.webkitCancelFullScreen();\n\n4,检测当前是否处于全屏\ndocument.webkitIsFullScreen\n(返回一个boolean值)\n\n5，webkit谷歌浏览器  moz火狐浏览器 msIE浏览器 o欧朋浏览器\n\n6，全屏伪类\n\t\t.box:-webkit-full-screen {\n\t\t\tbackground-color: blue;\n\t\t}（当box全屏的时候，box的背景变为蓝色）\n:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {}\n\n7，状态改变触发事件.change();\n\n8，base64码。\n\n9，拖拽事件：\n在HTML5的规范中，我们可以通过为元素增加draggable=\"true\"来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。\n页面中任何一个元素都可以成为目标元素，不需要特殊指定\n\n9.1、拖拽元素\ndragstart事件 ：一定是点击加位移才会触发\ndragend事件 ：一定是位移以后再松开鼠标才会触发\n拖拽元素开始拖拽以后他的元素会变成光标，松开鼠标以后他会回到原点这段时间，元素会变成本身大小。\ndragleave事件 ：一定是光标离开拖拽元素的时候才会触发。\ndrag事件 ：只要拖拽开始就一直在不停的触发，直到拖拽结束（期间不管光标是否移动，都会一直触发）\n\n9.2目标元素\ndragenter事件 一定是光标进入目标元素的时候才触发\ndragover事件 只要拖拽元素在目标元素内就会触发，无论光标是否移动\ndrop事件 在目标元素内松开鼠标才会触发，但是必须加上dragover事件并且清除dragover事件的默认行为。\ndragleave事件 在拖拽元素离开目标元素的时候触发，但是一旦我们阻止了dragover事件的默认事件，就不会再松开后触发一个dragleave事件。\n\n\n\n11，由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过<input>上传文件后得到的是一个FileList对象（伪数组形式）。\n\n12，\n\nif（navigator.userAgent.indexOf(\"Chrome\") !== -1）{\n\twebkit\n}else if（navigator.userAgent.indexOf(\"Firefox\") !== -1）{\n\tmoz\n}\n\n13,navigator.userAgent获取那个版本。\n\n14，onchange事件 当调用者发生改变是触发。\n\n15，FileReader对象\nHTML5新增内建对象，可以读取本地文件内容。\n\nvar reader = new FileReader;\n\n实例方法：\nreadAsDataURL()  以DataURL形式读取文件\n事件监听：onload事件\nreader.onload = function () {\n\t\t\t\tdocument.querySelector('img').src = this.result;\n\t\t\t}\n\n16，百度地图api使用\n1、获取当前地理信息\nnavigator. geolocation.getCurrentPosition(successCallback, errorCallback, options)\n2、重复获取当前地理信息\nnavigator. geolocation.watchPosition(successCallback, errorCallback, options)\n\n\t\t function success(position) {\n\t\t \t// alert(1);\n\t\t \tconsole.log(position);\n\t\t }\n\n\t\t // 失败的回调\n\t\t function error(err) {\n\t\t \tconsole.log('error');\n\n\t\t \tconsole.log(err);\n\t\t }\n\n\t\t // 获得用户当前信息\n\t\t navigator.geolocation.getCurrentPosition(success, error, {\n\t\t \t// enableHighAccuracy: true,\n\t\t \t// timeout: 3000,\n\t\t \t// maximumAge: 1000\n\t\t });\nposition.coords.latitude纬度\nposition.coords.longitude经度\nposition.coords.accuracy精度\nposition.coords.altitude海拔高度\n\n17,history.pushState({},'','地址');\n\t\t\t// 1、对象，在添加历史时，会设置一些数据，一般会设置null\n\t\t\t// 2、一般不生效，没意义\n\t\t\t// 3、我们要更改址址，并且会当一条新记录\n\n\n   history.replaceState({key:123},'','地址');[这里添加的数据在后面onpopstate事件时可以读取和使用]\n不会新生成网页记录,只是替换当前的地址.\n\t\t\t// 1、对象，在添加历史时，会设置一些数据，一般会设置null\n\t\t\t// 2、一般不生效，没意义\n\t\t\t// 3、我们要更改址址，并且会当一条新记录\n\n   onpopstate()事件 在历史区发生改变后并操作历史区的时候.(历史发生改变后,在操作前进或后退会触发)\n要绑定给window   window.onpopstate = function(state){}为了获取数据加载在页面中\n以后当我们访问一个网站的时候发现地址发生了改变,网页局部发生了改变,实现网页更新,那么他就用了window.onpopstate事件实现的功能.(主要应用于单页面应用)\n\n\n18，document.cookie  是一串字符串\n\n19，sessionStorage 同窗口多页面\n1，是存储在本地的浏览器窗口里，而不是存在地址中\n2，只要是同一个浏览器窗口，跨页面以后也能得到\n3，关闭浏览器窗口以后会自动删除\n4，如果我们换一个浏览器窗口打开就没有了\n\n20，localStorage\n1，是存储在本地的浏览器中，不再是某一个窗口下，但是不能跨域（传输学医、域名、端口号只要有一个不一样）实现。\n2，因为是存在浏览器的缓存中，所以关闭浏览器不会丢失数据\n3，数据消失只能靠手动删除或者清除浏览器缓存\n\n方法：\nwindow.localStorage.getItem()\n（sessionStorage/LocalStorage）：setItem(\"key\",\"value\")-->设置\n（sessionStorage/LocalStorage）：getItem(\"key\")-->获取，返回value值\n（sessionStorage/LocalStorage）：removeItem（\"key\"）-->删除\n（sessionStorage/LocalStorage）：clear()-->清空\n（sessionStorage/LocalStorage）：key(0)-->按索引下标查找，返回的是\"key\"\nwindow.localStorage.key(0);获取索引下标为0的值\n\n\n21,应用缓存:\n想用应用缓存第一步需要加载进来\n在<html manifest=\"./study.appcache\">\nmanifest文件格式\n1、顶行写CACHE MANIFEST\n2、CACHE: 换行指定我们需要缓存的静态资源，如.css、image、js等\n3、NETWORK: 换行指定需要在线访问的资源，可使用通配符\n4、FALLBACK: 换行当被缓存的文件找不到时的备用资源\n\n\n\n\nCACHE MANIFEST\n\n#版本号 1.0.0\n\nCACHE:\n\n#此部分写需要缓存的资源 如.css、image、js等\n\n./images/img1.jpg\n./images/img2.jpg\n./images/img3.jpg\n./images/img4.jpg\n./images/img5.jpg\n\nNETWORK: \n\n#此部分要写需要有网络才可访问的资源，无网络刚不访问(更新最新的内容来代替之前缓存的内容)    （记得清缓存）\n\n#./js/main.js\n\n*代表所有\n\nFALLBACK:         回滚的意思\n\n#当访问不到某个资源的情况下，自动由另一个资源替换\n\n./css/online.css ./css/offline.css\n\n./online.html ./offline.html\n当我们找不到源文件就使用备用文件\n\n应用缓存注意事项\n1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST\n2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制\n3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。\n4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存\n","source":"_posts/html5第二天.md","raw":"---\ntitle: html5基础二\ncategories: ['前端']\ntags: ['html5']\n---\n1,window.addEventListener\n\n2,onLine \"L\"大写的时候是一个属性，后面不用加括号，直接调用就行，返回一个布尔值。用法:alert（window.navigator.onLine）;返回浏览器是否联网（boolean值）\nonlone \"l\"小写的时候是一件事件，这个事件只能用dom二级事件来绑定\n“navigator”是window上的一个属性，所以写的时候window可以不写，但是建议写上（代码的完整性）\nonline事件在pc端的时候一定是从离线状态变到上线状态的时候才会触发。\n\n2,判断当前设备状态\n2.1 监听设备在线\nwindow.addEventListener('online', function () {\n\t\t\t// alert('online');\n\t\t\t$('.tips').text('网络已连接').fadeIn(500).delay(1000).fadeOut();\n\t\t});\ndelay(时间值)方法 ：是设置延迟时间。\n\n2.2 监听设备离线\nwindow.addEventListener('offline', function () {\n\t\t\t// alert('offline');\n\t\t\t$('.tips').text('网络已断开').fadeIn(500).delay(1000).fadeOut();\n\t\t});\n\n\n3，html全屏 document.documentElement.webkitRequestFullScreen();\n\n任意元素全屏显示\nnode.webkitRequestFullScreen();（谷歌浏览器加webkit）\nnode.mozRequestFullScreen();（火狐加moz）\n任意元素关闭全屏显示\nNode.cancelFullScreen()（理论是这样关闭实际上是用document.webkitCancelFullScreen()关闭）\n\n兼容写法：\t\t\t\t\tfunction FullScreen(node){\n\t\t\tif (node.mozRequestFullScreen){\n\t\t\t\tnode.mozRequestFullScreen();\n\t\t\t}\n\t\t\telse if(node.webkitRequestFullScreen){\n\t\t\t\tnode.webkitRequestFullScreen();\n\t\t\t}else if(node.msRequestFullScreen){\n\t\t\t\tnode.msRequestFullScreen();\n\t\t\t}else if(node.oRequestFullScreen){\n\t\t\t\tnode.oRequestFullScreen();\n\t\t\t}\n\t\t}\n\n\n4，所有元素只能通过document才能调用关闭全屏\ndocument.webkitCancelFullScreen();\n\n4,检测当前是否处于全屏\ndocument.webkitIsFullScreen\n(返回一个boolean值)\n\n5，webkit谷歌浏览器  moz火狐浏览器 msIE浏览器 o欧朋浏览器\n\n6，全屏伪类\n\t\t.box:-webkit-full-screen {\n\t\t\tbackground-color: blue;\n\t\t}（当box全屏的时候，box的背景变为蓝色）\n:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {}\n\n7，状态改变触发事件.change();\n\n8，base64码。\n\n9，拖拽事件：\n在HTML5的规范中，我们可以通过为元素增加draggable=\"true\"来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。\n页面中任何一个元素都可以成为目标元素，不需要特殊指定\n\n9.1、拖拽元素\ndragstart事件 ：一定是点击加位移才会触发\ndragend事件 ：一定是位移以后再松开鼠标才会触发\n拖拽元素开始拖拽以后他的元素会变成光标，松开鼠标以后他会回到原点这段时间，元素会变成本身大小。\ndragleave事件 ：一定是光标离开拖拽元素的时候才会触发。\ndrag事件 ：只要拖拽开始就一直在不停的触发，直到拖拽结束（期间不管光标是否移动，都会一直触发）\n\n9.2目标元素\ndragenter事件 一定是光标进入目标元素的时候才触发\ndragover事件 只要拖拽元素在目标元素内就会触发，无论光标是否移动\ndrop事件 在目标元素内松开鼠标才会触发，但是必须加上dragover事件并且清除dragover事件的默认行为。\ndragleave事件 在拖拽元素离开目标元素的时候触发，但是一旦我们阻止了dragover事件的默认事件，就不会再松开后触发一个dragleave事件。\n\n\n\n11，由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过<input>上传文件后得到的是一个FileList对象（伪数组形式）。\n\n12，\n\nif（navigator.userAgent.indexOf(\"Chrome\") !== -1）{\n\twebkit\n}else if（navigator.userAgent.indexOf(\"Firefox\") !== -1）{\n\tmoz\n}\n\n13,navigator.userAgent获取那个版本。\n\n14，onchange事件 当调用者发生改变是触发。\n\n15，FileReader对象\nHTML5新增内建对象，可以读取本地文件内容。\n\nvar reader = new FileReader;\n\n实例方法：\nreadAsDataURL()  以DataURL形式读取文件\n事件监听：onload事件\nreader.onload = function () {\n\t\t\t\tdocument.querySelector('img').src = this.result;\n\t\t\t}\n\n16，百度地图api使用\n1、获取当前地理信息\nnavigator. geolocation.getCurrentPosition(successCallback, errorCallback, options)\n2、重复获取当前地理信息\nnavigator. geolocation.watchPosition(successCallback, errorCallback, options)\n\n\t\t function success(position) {\n\t\t \t// alert(1);\n\t\t \tconsole.log(position);\n\t\t }\n\n\t\t // 失败的回调\n\t\t function error(err) {\n\t\t \tconsole.log('error');\n\n\t\t \tconsole.log(err);\n\t\t }\n\n\t\t // 获得用户当前信息\n\t\t navigator.geolocation.getCurrentPosition(success, error, {\n\t\t \t// enableHighAccuracy: true,\n\t\t \t// timeout: 3000,\n\t\t \t// maximumAge: 1000\n\t\t });\nposition.coords.latitude纬度\nposition.coords.longitude经度\nposition.coords.accuracy精度\nposition.coords.altitude海拔高度\n\n17,history.pushState({},'','地址');\n\t\t\t// 1、对象，在添加历史时，会设置一些数据，一般会设置null\n\t\t\t// 2、一般不生效，没意义\n\t\t\t// 3、我们要更改址址，并且会当一条新记录\n\n\n   history.replaceState({key:123},'','地址');[这里添加的数据在后面onpopstate事件时可以读取和使用]\n不会新生成网页记录,只是替换当前的地址.\n\t\t\t// 1、对象，在添加历史时，会设置一些数据，一般会设置null\n\t\t\t// 2、一般不生效，没意义\n\t\t\t// 3、我们要更改址址，并且会当一条新记录\n\n   onpopstate()事件 在历史区发生改变后并操作历史区的时候.(历史发生改变后,在操作前进或后退会触发)\n要绑定给window   window.onpopstate = function(state){}为了获取数据加载在页面中\n以后当我们访问一个网站的时候发现地址发生了改变,网页局部发生了改变,实现网页更新,那么他就用了window.onpopstate事件实现的功能.(主要应用于单页面应用)\n\n\n18，document.cookie  是一串字符串\n\n19，sessionStorage 同窗口多页面\n1，是存储在本地的浏览器窗口里，而不是存在地址中\n2，只要是同一个浏览器窗口，跨页面以后也能得到\n3，关闭浏览器窗口以后会自动删除\n4，如果我们换一个浏览器窗口打开就没有了\n\n20，localStorage\n1，是存储在本地的浏览器中，不再是某一个窗口下，但是不能跨域（传输学医、域名、端口号只要有一个不一样）实现。\n2，因为是存在浏览器的缓存中，所以关闭浏览器不会丢失数据\n3，数据消失只能靠手动删除或者清除浏览器缓存\n\n方法：\nwindow.localStorage.getItem()\n（sessionStorage/LocalStorage）：setItem(\"key\",\"value\")-->设置\n（sessionStorage/LocalStorage）：getItem(\"key\")-->获取，返回value值\n（sessionStorage/LocalStorage）：removeItem（\"key\"）-->删除\n（sessionStorage/LocalStorage）：clear()-->清空\n（sessionStorage/LocalStorage）：key(0)-->按索引下标查找，返回的是\"key\"\nwindow.localStorage.key(0);获取索引下标为0的值\n\n\n21,应用缓存:\n想用应用缓存第一步需要加载进来\n在<html manifest=\"./study.appcache\">\nmanifest文件格式\n1、顶行写CACHE MANIFEST\n2、CACHE: 换行指定我们需要缓存的静态资源，如.css、image、js等\n3、NETWORK: 换行指定需要在线访问的资源，可使用通配符\n4、FALLBACK: 换行当被缓存的文件找不到时的备用资源\n\n\n\n\nCACHE MANIFEST\n\n#版本号 1.0.0\n\nCACHE:\n\n#此部分写需要缓存的资源 如.css、image、js等\n\n./images/img1.jpg\n./images/img2.jpg\n./images/img3.jpg\n./images/img4.jpg\n./images/img5.jpg\n\nNETWORK: \n\n#此部分要写需要有网络才可访问的资源，无网络刚不访问(更新最新的内容来代替之前缓存的内容)    （记得清缓存）\n\n#./js/main.js\n\n*代表所有\n\nFALLBACK:         回滚的意思\n\n#当访问不到某个资源的情况下，自动由另一个资源替换\n\n./css/online.css ./css/offline.css\n\n./online.html ./offline.html\n当我们找不到源文件就使用备用文件\n\n应用缓存注意事项\n1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST\n2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制\n3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。\n4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存\n","slug":"html5第二天","published":1,"date":"2016-11-28T12:21:49.000Z","updated":"2019-04-26T06:58:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0i5001r7xuqtc52xwy4","content":"<p>1,window.addEventListener</p>\n<p>2,onLine “L”大写的时候是一个属性，后面不用加括号，直接调用就行，返回一个布尔值。用法:alert（window.navigator.onLine）;返回浏览器是否联网（boolean值）<br>onlone “l”小写的时候是一件事件，这个事件只能用dom二级事件来绑定<br>“navigator”是window上的一个属性，所以写的时候window可以不写，但是建议写上（代码的完整性）<br>online事件在pc端的时候一定是从离线状态变到上线状态的时候才会触发。</p>\n<p>2,判断当前设备状态<br>2.1 监听设备在线<br>window.addEventListener(‘online’, function () {<br>            // alert(‘online’);<br>            $(‘.tips’).text(‘网络已连接’).fadeIn(500).delay(1000).fadeOut();<br>        });<br>delay(时间值)方法 ：是设置延迟时间。</p>\n<p>2.2 监听设备离线<br>window.addEventListener(‘offline’, function () {<br>            // alert(‘offline’);<br>            $(‘.tips’).text(‘网络已断开’).fadeIn(500).delay(1000).fadeOut();<br>        });</p>\n<p>3，html全屏 document.documentElement.webkitRequestFullScreen();</p>\n<p>任意元素全屏显示<br>node.webkitRequestFullScreen();（谷歌浏览器加webkit）<br>node.mozRequestFullScreen();（火狐加moz）<br>任意元素关闭全屏显示<br>Node.cancelFullScreen()（理论是这样关闭实际上是用document.webkitCancelFullScreen()关闭）</p>\n<p>兼容写法：                    function FullScreen(node){<br>            if (node.mozRequestFullScreen){<br>                node.mozRequestFullScreen();<br>            }<br>            else if(node.webkitRequestFullScreen){<br>                node.webkitRequestFullScreen();<br>            }else if(node.msRequestFullScreen){<br>                node.msRequestFullScreen();<br>            }else if(node.oRequestFullScreen){<br>                node.oRequestFullScreen();<br>            }<br>        }</p>\n<p>4，所有元素只能通过document才能调用关闭全屏<br>document.webkitCancelFullScreen();</p>\n<p>4,检测当前是否处于全屏<br>document.webkitIsFullScreen<br>(返回一个boolean值)</p>\n<p>5，webkit谷歌浏览器  moz火狐浏览器 msIE浏览器 o欧朋浏览器</p>\n<p>6，全屏伪类<br>        .box:-webkit-full-screen {<br>            background-color: blue;<br>        }（当box全屏的时候，box的背景变为蓝色）<br>:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {}</p>\n<p>7，状态改变触发事件.change();</p>\n<p>8，base64码。</p>\n<p>9，拖拽事件：<br>在HTML5的规范中，我们可以通过为元素增加draggable=”true”来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。<br>页面中任何一个元素都可以成为目标元素，不需要特殊指定</p>\n<p>9.1、拖拽元素<br>dragstart事件 ：一定是点击加位移才会触发<br>dragend事件 ：一定是位移以后再松开鼠标才会触发<br>拖拽元素开始拖拽以后他的元素会变成光标，松开鼠标以后他会回到原点这段时间，元素会变成本身大小。<br>dragleave事件 ：一定是光标离开拖拽元素的时候才会触发。<br>drag事件 ：只要拖拽开始就一直在不停的触发，直到拖拽结束（期间不管光标是否移动，都会一直触发）</p>\n<p>9.2目标元素<br>dragenter事件 一定是光标进入目标元素的时候才触发<br>dragover事件 只要拖拽元素在目标元素内就会触发，无论光标是否移动<br>drop事件 在目标元素内松开鼠标才会触发，但是必须加上dragover事件并且清除dragover事件的默认行为。<br>dragleave事件 在拖拽元素离开目标元素的时候触发，但是一旦我们阻止了dragover事件的默认事件，就不会再松开后触发一个dragleave事件。</p>\n<p>11，由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过<input>上传文件后得到的是一个FileList对象（伪数组形式）。</p>\n<p>12，</p>\n<p>if（navigator.userAgent.indexOf(“Chrome”) !== -1）{<br>    webkit<br>}else if（navigator.userAgent.indexOf(“Firefox”) !== -1）{<br>    moz<br>}</p>\n<p>13,navigator.userAgent获取那个版本。</p>\n<p>14，onchange事件 当调用者发生改变是触发。</p>\n<p>15，FileReader对象<br>HTML5新增内建对象，可以读取本地文件内容。</p>\n<p>var reader = new FileReader;</p>\n<p>实例方法：<br>readAsDataURL()  以DataURL形式读取文件<br>事件监听：onload事件<br>reader.onload = function () {<br>                document.querySelector(‘img’).src = this.result;<br>            }</p>\n<p>16，百度地图api使用<br>1、获取当前地理信息<br>navigator. geolocation.getCurrentPosition(successCallback, errorCallback, options)<br>2、重复获取当前地理信息<br>navigator. geolocation.watchPosition(successCallback, errorCallback, options)</p>\n<pre><code>function success(position) {\n    // alert(1);\n    console.log(position);\n}\n\n// 失败的回调\nfunction error(err) {\n    console.log(&apos;error&apos;);\n\n    console.log(err);\n}\n\n// 获得用户当前信息\nnavigator.geolocation.getCurrentPosition(success, error, {\n    // enableHighAccuracy: true,\n    // timeout: 3000,\n    // maximumAge: 1000\n});\n</code></pre><p>position.coords.latitude纬度<br>position.coords.longitude经度<br>position.coords.accuracy精度<br>position.coords.altitude海拔高度</p>\n<p>17,history.pushState({},’’,’地址’);<br>            // 1、对象，在添加历史时，会设置一些数据，一般会设置null<br>            // 2、一般不生效，没意义<br>            // 3、我们要更改址址，并且会当一条新记录</p>\n<p>   history.replaceState({key:123},’’,’地址’);[这里添加的数据在后面onpopstate事件时可以读取和使用]<br>不会新生成网页记录,只是替换当前的地址.<br>            // 1、对象，在添加历史时，会设置一些数据，一般会设置null<br>            // 2、一般不生效，没意义<br>            // 3、我们要更改址址，并且会当一条新记录</p>\n<p>   onpopstate()事件 在历史区发生改变后并操作历史区的时候.(历史发生改变后,在操作前进或后退会触发)<br>要绑定给window   window.onpopstate = function(state){}为了获取数据加载在页面中<br>以后当我们访问一个网站的时候发现地址发生了改变,网页局部发生了改变,实现网页更新,那么他就用了window.onpopstate事件实现的功能.(主要应用于单页面应用)</p>\n<p>18，document.cookie  是一串字符串</p>\n<p>19，sessionStorage 同窗口多页面<br>1，是存储在本地的浏览器窗口里，而不是存在地址中<br>2，只要是同一个浏览器窗口，跨页面以后也能得到<br>3，关闭浏览器窗口以后会自动删除<br>4，如果我们换一个浏览器窗口打开就没有了</p>\n<p>20，localStorage<br>1，是存储在本地的浏览器中，不再是某一个窗口下，但是不能跨域（传输学医、域名、端口号只要有一个不一样）实现。<br>2，因为是存在浏览器的缓存中，所以关闭浏览器不会丢失数据<br>3，数据消失只能靠手动删除或者清除浏览器缓存</p>\n<p>方法：<br>window.localStorage.getItem()<br>（sessionStorage/LocalStorage）：setItem(“key”,”value”)–&gt;设置<br>（sessionStorage/LocalStorage）：getItem(“key”)–&gt;获取，返回value值<br>（sessionStorage/LocalStorage）：removeItem（”key”）–&gt;删除<br>（sessionStorage/LocalStorage）：clear()–&gt;清空<br>（sessionStorage/LocalStorage）：key(0)–&gt;按索引下标查找，返回的是”key”<br>window.localStorage.key(0);获取索引下标为0的值</p>\n<p>21,应用缓存:<br>想用应用缓存第一步需要加载进来<br>在<html manifest=\"./study.appcache\"><br>manifest文件格式<br>1、顶行写CACHE MANIFEST<br>2、CACHE: 换行指定我们需要缓存的静态资源，如.css、image、js等<br>3、NETWORK: 换行指定需要在线访问的资源，可使用通配符<br>4、FALLBACK: 换行当被缓存的文件找不到时的备用资源</html></p>\n<p>CACHE MANIFEST</p>\n<p>#版本号 1.0.0</p>\n<p>CACHE:</p>\n<p>#此部分写需要缓存的资源 如.css、image、js等</p>\n<p>./images/img1.jpg<br>./images/img2.jpg<br>./images/img3.jpg<br>./images/img4.jpg<br>./images/img5.jpg</p>\n<p>NETWORK: </p>\n<p>#此部分要写需要有网络才可访问的资源，无网络刚不访问(更新最新的内容来代替之前缓存的内容)    （记得清缓存）</p>\n<p>#./js/main.js</p>\n<p>*代表所有</p>\n<p>FALLBACK:         回滚的意思</p>\n<p>#当访问不到某个资源的情况下，自动由另一个资源替换</p>\n<p>./css/online.css ./css/offline.css</p>\n<p>./online.html ./offline.html<br>当我们找不到源文件就使用备用文件</p>\n<p>应用缓存注意事项<br>1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST<br>2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制<br>3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。<br>4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1,window.addEventListener</p>\n<p>2,onLine “L”大写的时候是一个属性，后面不用加括号，直接调用就行，返回一个布尔值。用法:alert（window.navigator.onLine）;返回浏览器是否联网（boolean值）<br>onlone “l”小写的时候是一件事件，这个事件只能用dom二级事件来绑定<br>“navigator”是window上的一个属性，所以写的时候window可以不写，但是建议写上（代码的完整性）<br>online事件在pc端的时候一定是从离线状态变到上线状态的时候才会触发。</p>\n<p>2,判断当前设备状态<br>2.1 监听设备在线<br>window.addEventListener(‘online’, function () {<br>            // alert(‘online’);<br>            $(‘.tips’).text(‘网络已连接’).fadeIn(500).delay(1000).fadeOut();<br>        });<br>delay(时间值)方法 ：是设置延迟时间。</p>\n<p>2.2 监听设备离线<br>window.addEventListener(‘offline’, function () {<br>            // alert(‘offline’);<br>            $(‘.tips’).text(‘网络已断开’).fadeIn(500).delay(1000).fadeOut();<br>        });</p>\n<p>3，html全屏 document.documentElement.webkitRequestFullScreen();</p>\n<p>任意元素全屏显示<br>node.webkitRequestFullScreen();（谷歌浏览器加webkit）<br>node.mozRequestFullScreen();（火狐加moz）<br>任意元素关闭全屏显示<br>Node.cancelFullScreen()（理论是这样关闭实际上是用document.webkitCancelFullScreen()关闭）</p>\n<p>兼容写法：                    function FullScreen(node){<br>            if (node.mozRequestFullScreen){<br>                node.mozRequestFullScreen();<br>            }<br>            else if(node.webkitRequestFullScreen){<br>                node.webkitRequestFullScreen();<br>            }else if(node.msRequestFullScreen){<br>                node.msRequestFullScreen();<br>            }else if(node.oRequestFullScreen){<br>                node.oRequestFullScreen();<br>            }<br>        }</p>\n<p>4，所有元素只能通过document才能调用关闭全屏<br>document.webkitCancelFullScreen();</p>\n<p>4,检测当前是否处于全屏<br>document.webkitIsFullScreen<br>(返回一个boolean值)</p>\n<p>5，webkit谷歌浏览器  moz火狐浏览器 msIE浏览器 o欧朋浏览器</p>\n<p>6，全屏伪类<br>        .box:-webkit-full-screen {<br>            background-color: blue;<br>        }（当box全屏的时候，box的背景变为蓝色）<br>:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {}</p>\n<p>7，状态改变触发事件.change();</p>\n<p>8，base64码。</p>\n<p>9，拖拽事件：<br>在HTML5的规范中，我们可以通过为元素增加draggable=”true”来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。<br>页面中任何一个元素都可以成为目标元素，不需要特殊指定</p>\n<p>9.1、拖拽元素<br>dragstart事件 ：一定是点击加位移才会触发<br>dragend事件 ：一定是位移以后再松开鼠标才会触发<br>拖拽元素开始拖拽以后他的元素会变成光标，松开鼠标以后他会回到原点这段时间，元素会变成本身大小。<br>dragleave事件 ：一定是光标离开拖拽元素的时候才会触发。<br>drag事件 ：只要拖拽开始就一直在不停的触发，直到拖拽结束（期间不管光标是否移动，都会一直触发）</p>\n<p>9.2目标元素<br>dragenter事件 一定是光标进入目标元素的时候才触发<br>dragover事件 只要拖拽元素在目标元素内就会触发，无论光标是否移动<br>drop事件 在目标元素内松开鼠标才会触发，但是必须加上dragover事件并且清除dragover事件的默认行为。<br>dragleave事件 在拖拽元素离开目标元素的时候触发，但是一旦我们阻止了dragover事件的默认事件，就不会再松开后触发一个dragleave事件。</p>\n<p>11，由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过<input>上传文件后得到的是一个FileList对象（伪数组形式）。</p>\n<p>12，</p>\n<p>if（navigator.userAgent.indexOf(“Chrome”) !== -1）{<br>    webkit<br>}else if（navigator.userAgent.indexOf(“Firefox”) !== -1）{<br>    moz<br>}</p>\n<p>13,navigator.userAgent获取那个版本。</p>\n<p>14，onchange事件 当调用者发生改变是触发。</p>\n<p>15，FileReader对象<br>HTML5新增内建对象，可以读取本地文件内容。</p>\n<p>var reader = new FileReader;</p>\n<p>实例方法：<br>readAsDataURL()  以DataURL形式读取文件<br>事件监听：onload事件<br>reader.onload = function () {<br>                document.querySelector(‘img’).src = this.result;<br>            }</p>\n<p>16，百度地图api使用<br>1、获取当前地理信息<br>navigator. geolocation.getCurrentPosition(successCallback, errorCallback, options)<br>2、重复获取当前地理信息<br>navigator. geolocation.watchPosition(successCallback, errorCallback, options)</p>\n<pre><code>function success(position) {\n    // alert(1);\n    console.log(position);\n}\n\n// 失败的回调\nfunction error(err) {\n    console.log(&apos;error&apos;);\n\n    console.log(err);\n}\n\n// 获得用户当前信息\nnavigator.geolocation.getCurrentPosition(success, error, {\n    // enableHighAccuracy: true,\n    // timeout: 3000,\n    // maximumAge: 1000\n});\n</code></pre><p>position.coords.latitude纬度<br>position.coords.longitude经度<br>position.coords.accuracy精度<br>position.coords.altitude海拔高度</p>\n<p>17,history.pushState({},’’,’地址’);<br>            // 1、对象，在添加历史时，会设置一些数据，一般会设置null<br>            // 2、一般不生效，没意义<br>            // 3、我们要更改址址，并且会当一条新记录</p>\n<p>   history.replaceState({key:123},’’,’地址’);[这里添加的数据在后面onpopstate事件时可以读取和使用]<br>不会新生成网页记录,只是替换当前的地址.<br>            // 1、对象，在添加历史时，会设置一些数据，一般会设置null<br>            // 2、一般不生效，没意义<br>            // 3、我们要更改址址，并且会当一条新记录</p>\n<p>   onpopstate()事件 在历史区发生改变后并操作历史区的时候.(历史发生改变后,在操作前进或后退会触发)<br>要绑定给window   window.onpopstate = function(state){}为了获取数据加载在页面中<br>以后当我们访问一个网站的时候发现地址发生了改变,网页局部发生了改变,实现网页更新,那么他就用了window.onpopstate事件实现的功能.(主要应用于单页面应用)</p>\n<p>18，document.cookie  是一串字符串</p>\n<p>19，sessionStorage 同窗口多页面<br>1，是存储在本地的浏览器窗口里，而不是存在地址中<br>2，只要是同一个浏览器窗口，跨页面以后也能得到<br>3，关闭浏览器窗口以后会自动删除<br>4，如果我们换一个浏览器窗口打开就没有了</p>\n<p>20，localStorage<br>1，是存储在本地的浏览器中，不再是某一个窗口下，但是不能跨域（传输学医、域名、端口号只要有一个不一样）实现。<br>2，因为是存在浏览器的缓存中，所以关闭浏览器不会丢失数据<br>3，数据消失只能靠手动删除或者清除浏览器缓存</p>\n<p>方法：<br>window.localStorage.getItem()<br>（sessionStorage/LocalStorage）：setItem(“key”,”value”)–&gt;设置<br>（sessionStorage/LocalStorage）：getItem(“key”)–&gt;获取，返回value值<br>（sessionStorage/LocalStorage）：removeItem（”key”）–&gt;删除<br>（sessionStorage/LocalStorage）：clear()–&gt;清空<br>（sessionStorage/LocalStorage）：key(0)–&gt;按索引下标查找，返回的是”key”<br>window.localStorage.key(0);获取索引下标为0的值</p>\n<p>21,应用缓存:<br>想用应用缓存第一步需要加载进来<br>在<html manifest=\"./study.appcache\"><br>manifest文件格式<br>1、顶行写CACHE MANIFEST<br>2、CACHE: 换行指定我们需要缓存的静态资源，如.css、image、js等<br>3、NETWORK: 换行指定需要在线访问的资源，可使用通配符<br>4、FALLBACK: 换行当被缓存的文件找不到时的备用资源</html></p>\n<p>CACHE MANIFEST</p>\n<p>#版本号 1.0.0</p>\n<p>CACHE:</p>\n<p>#此部分写需要缓存的资源 如.css、image、js等</p>\n<p>./images/img1.jpg<br>./images/img2.jpg<br>./images/img3.jpg<br>./images/img4.jpg<br>./images/img5.jpg</p>\n<p>NETWORK: </p>\n<p>#此部分要写需要有网络才可访问的资源，无网络刚不访问(更新最新的内容来代替之前缓存的内容)    （记得清缓存）</p>\n<p>#./js/main.js</p>\n<p>*代表所有</p>\n<p>FALLBACK:         回滚的意思</p>\n<p>#当访问不到某个资源的情况下，自动由另一个资源替换</p>\n<p>./css/online.css ./css/offline.css</p>\n<p>./online.html ./offline.html<br>当我们找不到源文件就使用备用文件</p>\n<p>应用缓存注意事项<br>1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST<br>2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制<br>3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。<br>4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存</p>\n"},{"title":"JavaScript字典和散列表","_content":"\n### 一、概念\n- 字典存储的是【键，值】其中键名是用来查询特定的元素的（不重复元素）字典也称作映射、符号表、关联数组。\n\n```\nfunction defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } if (item === undefined) {\n    return 'UNDEFINED';\n  } if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString();\n}\nclass Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key);\n      this.table[tableKey] = new ValuePair(key, value);\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n\n  values() {\n    return this.keyValues().map(valuePair => valuePair.value);\n  }\n\n  keys() {\n    return this.keyValues().map(valuePair => valuePair.key);\n  }\n\n  keyValues() {\n    return Object.values(this.table);\n  }\n\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues();\n    for (let i = 0; i < valuePairs.length; i++) {\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  size() {\n    return Object.keys(this.table).length;\n  }\n\n  clear() {\n    this.table = {};\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`;\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`;\n    }\n    return objString;\n  }\n}\n\n\n\n```","source":"_posts/DataStructure/JavaScript字典和散列表.md","raw":"---\ntitle: JavaScript字典和散列表\ncategories: ['数据结构']\ntags: ['JavaScript'] \n---\n\n### 一、概念\n- 字典存储的是【键，值】其中键名是用来查询特定的元素的（不重复元素）字典也称作映射、符号表、关联数组。\n\n```\nfunction defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } if (item === undefined) {\n    return 'UNDEFINED';\n  } if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString();\n}\nclass Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key);\n      this.table[tableKey] = new ValuePair(key, value);\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n\n  values() {\n    return this.keyValues().map(valuePair => valuePair.value);\n  }\n\n  keys() {\n    return this.keyValues().map(valuePair => valuePair.key);\n  }\n\n  keyValues() {\n    return Object.values(this.table);\n  }\n\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues();\n    for (let i = 0; i < valuePairs.length; i++) {\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  size() {\n    return Object.keys(this.table).length;\n  }\n\n  clear() {\n    this.table = {};\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`;\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`;\n    }\n    return objString;\n  }\n}\n\n\n\n```","slug":"DataStructure/JavaScript字典和散列表","published":1,"date":"2019-06-18T09:50:19.000Z","updated":"2019-06-18T10:03:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ie001u7xuqk1cj7dnf","content":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>字典存储的是【键，值】其中键名是用来查询特定的元素的（不重复元素）字典也称作映射、符号表、关联数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultToString(item) &#123;</span><br><span class=\"line\">  if (item === null) &#123;</span><br><span class=\"line\">    return &apos;NULL&apos;;</span><br><span class=\"line\">  &#125; if (item === undefined) &#123;</span><br><span class=\"line\">    return &apos;UNDEFINED&apos;;</span><br><span class=\"line\">  &#125; if (typeof item === &apos;string&apos; || item instanceof String) &#123;</span><br><span class=\"line\">    return `$&#123;item&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return item.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dictionary &#123;</span><br><span class=\"line\">  constructor(toStrFn = defaultToString) &#123;</span><br><span class=\"line\">    this.toStrFn = toStrFn;</span><br><span class=\"line\">    this.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set(key, value) &#123;</span><br><span class=\"line\">    if (key != null &amp;&amp; value != null) &#123;</span><br><span class=\"line\">      const tableKey = this.toStrFn(key);</span><br><span class=\"line\">      this.table[tableKey] = new ValuePair(key, value);</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get(key) &#123;</span><br><span class=\"line\">    const valuePair = this.table[this.toStrFn(key)];</span><br><span class=\"line\">    return valuePair == null ? undefined : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  hasKey(key) &#123;</span><br><span class=\"line\">    return this.table[this.toStrFn(key)] != null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(key) &#123;</span><br><span class=\"line\">    if (this.hasKey(key)) &#123;</span><br><span class=\"line\">      delete this.table[this.toStrFn(key)];</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values() &#123;</span><br><span class=\"line\">    return this.keyValues().map(valuePair =&gt; valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  keys() &#123;</span><br><span class=\"line\">    return this.keyValues().map(valuePair =&gt; valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  keyValues() &#123;</span><br><span class=\"line\">    return Object.values(this.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  forEach(callbackFn) &#123;</span><br><span class=\"line\">    const valuePairs = this.keyValues();</span><br><span class=\"line\">    for (let i = 0; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      const result = callbackFn(valuePairs[i].key, valuePairs[i].value);</span><br><span class=\"line\">      if (result === false) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return Object.keys(this.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const valuePairs = this.keyValues();</span><br><span class=\"line\">    let objString = `$&#123;valuePairs[0].toString()&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;valuePairs[i].toString()&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>字典存储的是【键，值】其中键名是用来查询特定的元素的（不重复元素）字典也称作映射、符号表、关联数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultToString(item) &#123;</span><br><span class=\"line\">  if (item === null) &#123;</span><br><span class=\"line\">    return &apos;NULL&apos;;</span><br><span class=\"line\">  &#125; if (item === undefined) &#123;</span><br><span class=\"line\">    return &apos;UNDEFINED&apos;;</span><br><span class=\"line\">  &#125; if (typeof item === &apos;string&apos; || item instanceof String) &#123;</span><br><span class=\"line\">    return `$&#123;item&#125;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return item.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dictionary &#123;</span><br><span class=\"line\">  constructor(toStrFn = defaultToString) &#123;</span><br><span class=\"line\">    this.toStrFn = toStrFn;</span><br><span class=\"line\">    this.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set(key, value) &#123;</span><br><span class=\"line\">    if (key != null &amp;&amp; value != null) &#123;</span><br><span class=\"line\">      const tableKey = this.toStrFn(key);</span><br><span class=\"line\">      this.table[tableKey] = new ValuePair(key, value);</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get(key) &#123;</span><br><span class=\"line\">    const valuePair = this.table[this.toStrFn(key)];</span><br><span class=\"line\">    return valuePair == null ? undefined : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  hasKey(key) &#123;</span><br><span class=\"line\">    return this.table[this.toStrFn(key)] != null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(key) &#123;</span><br><span class=\"line\">    if (this.hasKey(key)) &#123;</span><br><span class=\"line\">      delete this.table[this.toStrFn(key)];</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values() &#123;</span><br><span class=\"line\">    return this.keyValues().map(valuePair =&gt; valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  keys() &#123;</span><br><span class=\"line\">    return this.keyValues().map(valuePair =&gt; valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  keyValues() &#123;</span><br><span class=\"line\">    return Object.values(this.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  forEach(callbackFn) &#123;</span><br><span class=\"line\">    const valuePairs = this.keyValues();</span><br><span class=\"line\">    for (let i = 0; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      const result = callbackFn(valuePairs[i].key, valuePairs[i].value);</span><br><span class=\"line\">      if (result === false) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return Object.keys(this.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const valuePairs = this.keyValues();</span><br><span class=\"line\">    let objString = `$&#123;valuePairs[0].toString()&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;valuePairs[i].toString()&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript队列(Queue)","_content":"\n### 一、概念\n- 栈：先进先出。队列尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾。\n\n```\nclass Queue {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n\n  size() {\n    return this.count - this.lowestCount;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n\n```","source":"_posts/DataStructure/JavaScript队列(Queue).md","raw":"---\ntitle: JavaScript队列(Queue)\ncategories: ['数据结构']\ntags: ['JavaScript'] \n---\n\n### 一、概念\n- 栈：先进先出。队列尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾。\n\n```\nclass Queue {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n\n  size() {\n    return this.count - this.lowestCount;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n\n```","slug":"DataStructure/JavaScript队列(Queue)","published":1,"date":"2019-06-14T07:26:34.000Z","updated":"2019-06-14T07:38:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ie001v7xuqqguw857i","content":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>栈：先进先出。队列尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Queue &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  enqueue(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dequeue() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const result = this.items[this.lowestCount];</span><br><span class=\"line\">    delete this.items[this.lowestCount];</span><br><span class=\"line\">    this.lowestCount++;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count - this.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[this.lowestCount]&#125;`;</span><br><span class=\"line\">    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>栈：先进先出。队列尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Queue &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  enqueue(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dequeue() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const result = this.items[this.lowestCount];</span><br><span class=\"line\">    delete this.items[this.lowestCount];</span><br><span class=\"line\">    this.lowestCount++;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count - this.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[this.lowestCount]&#125;`;</span><br><span class=\"line\">    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Mongodb","_content":"\n### 一、 基础Shell命令。\n- show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。\n- use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。9（如果当前数据库名字不存在则建立该名字的数据库，但是在没有集合前，它还是默认为空。）\n- show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。\n- db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。\n### 二、 数据操作基础命令：\n\n- use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。\n- db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”})\n- db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find()\n- db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。\n- db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。\n```\ndb.jspang.update({\"name\":\"jspang\"},{\"name\":\"jspang\",\"age\":\"32\"})\n```\n- db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”})\n- db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。\n- db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。\n### 三、在操作数据库时要注意两个能力：\n\n1. 第一个是快速存储能力。\n2. 第二个是方便迅速查询能力。\n### 四、 批量插入\n```\ndb.test.insert([\n    {\"_id\":1},\n    {\"_id\":2},\n    {\"_id\":3}\n])\n```\n> 1. 注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好，这也算是一个规则。 \n> 2. 数据插入选用批量插入性能远远大于循环插入。\n### 五、 update修改器\n1. 修改非嵌入文档\n```\ndbd .workmate.update({\"name\":\"MinJie\"},{\"$set\":{sex:2,age:21}})\n```\n2. 修改嵌入文档\n```\ndb.workmate.update({\"name\":\"MinJie\"},{\"$set\":{\"skill.skillThree\":'word'}})\n```\n3. $unset用于将key删除\n```\ndb.workmate.update({\"name\":\"MinJie\"},{$unset:{\"age\":''}})\n```\n4. $inc对数字进行计算\n```\ndb.workmate.update({\"name\":\"MinJie\"},{$inc:{\"age\":-2}})\n```\n5. multi选项\n```\ndb.workmate.update({},{$set:{interset:[]}})\n```\n> 只改变了第一个数据\n```\ndb.workmate.update({},{$set:{interset:[]}},{multi:true})\n```\n> 每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）\n6. upsert选项\n```\ndb.workmate.update({name:'xiaoWang'},{$set:{age:20}},{upsert:true})\n```\n> upsert是在找不到值的情况下，直接插入这条数据。upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)。\n### 六. update数组修改器\n1. $push追加数组/内嵌文档值\n```\ndb.workmate.update({name:'xiaoWang'},{$push:{interest:'draw'}})\n```\n> $push的功能是追加数组中的值\n```\ndb.workmate.update({name:'MinJie'},{$push:{\"skill.skillFour\":'draw'}})\n```\n> $push修饰符内嵌文档增加值\n2. $ne查找是否存在\n```\ndb.workmate.update({name:'xiaoWang',\"interest\":{$ne:'playGame'}},{$push:{interest:'Game'}})\n```\n> 如果xiaoWang的爱好（interest）里没有palyGame这个值，我们就加入Game这个爱好。总结：没有则修改，有则不修改。\n3. \\$addToSet 升级版的\\$ne\n```\ndb.workmate.update({name:\"xiaoWang\"},{$addToSet:{interest:\"readBook\"}})\n```\n> 我们现在要查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.\n4. $each 批量追加\n```\nvar newInterset=[\"Sing\",\"Dance\",\"Code\"];\ndb.workmate.update({name:\"xiaoWang\"},{$addToSet:{interest:{$each:newInterset}}})\n````\n> 它可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作.\n5. $pop 删除数组值\n```\ndb.workmate.update({name:'xiaoWang'},{$pop:{interest:1}})\n```\n> $pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。\n\n> 1：从数组末端进行删除,\n> -1：从数组开端进行删除\n6. 数组定位修改\n```\ndb.workmate.update({name:'xiaoWang'},{$set:{\"interest.2\":\"Code\"}})\n```\n### 七、修改：状态返回与安全\n\n\n","source":"_posts/Mongodb/Mongodb.md","raw":"---\ntitle: Mongodb\ncategories: ['数据库']\ntags: ['Mongodb'] \n---\n\n### 一、 基础Shell命令。\n- show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。\n- use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。9（如果当前数据库名字不存在则建立该名字的数据库，但是在没有集合前，它还是默认为空。）\n- show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。\n- db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。\n### 二、 数据操作基础命令：\n\n- use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。\n- db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”})\n- db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find()\n- db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。\n- db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。\n```\ndb.jspang.update({\"name\":\"jspang\"},{\"name\":\"jspang\",\"age\":\"32\"})\n```\n- db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”})\n- db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。\n- db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。\n### 三、在操作数据库时要注意两个能力：\n\n1. 第一个是快速存储能力。\n2. 第二个是方便迅速查询能力。\n### 四、 批量插入\n```\ndb.test.insert([\n    {\"_id\":1},\n    {\"_id\":2},\n    {\"_id\":3}\n])\n```\n> 1. 注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好，这也算是一个规则。 \n> 2. 数据插入选用批量插入性能远远大于循环插入。\n### 五、 update修改器\n1. 修改非嵌入文档\n```\ndbd .workmate.update({\"name\":\"MinJie\"},{\"$set\":{sex:2,age:21}})\n```\n2. 修改嵌入文档\n```\ndb.workmate.update({\"name\":\"MinJie\"},{\"$set\":{\"skill.skillThree\":'word'}})\n```\n3. $unset用于将key删除\n```\ndb.workmate.update({\"name\":\"MinJie\"},{$unset:{\"age\":''}})\n```\n4. $inc对数字进行计算\n```\ndb.workmate.update({\"name\":\"MinJie\"},{$inc:{\"age\":-2}})\n```\n5. multi选项\n```\ndb.workmate.update({},{$set:{interset:[]}})\n```\n> 只改变了第一个数据\n```\ndb.workmate.update({},{$set:{interset:[]}},{multi:true})\n```\n> 每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）\n6. upsert选项\n```\ndb.workmate.update({name:'xiaoWang'},{$set:{age:20}},{upsert:true})\n```\n> upsert是在找不到值的情况下，直接插入这条数据。upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)。\n### 六. update数组修改器\n1. $push追加数组/内嵌文档值\n```\ndb.workmate.update({name:'xiaoWang'},{$push:{interest:'draw'}})\n```\n> $push的功能是追加数组中的值\n```\ndb.workmate.update({name:'MinJie'},{$push:{\"skill.skillFour\":'draw'}})\n```\n> $push修饰符内嵌文档增加值\n2. $ne查找是否存在\n```\ndb.workmate.update({name:'xiaoWang',\"interest\":{$ne:'playGame'}},{$push:{interest:'Game'}})\n```\n> 如果xiaoWang的爱好（interest）里没有palyGame这个值，我们就加入Game这个爱好。总结：没有则修改，有则不修改。\n3. \\$addToSet 升级版的\\$ne\n```\ndb.workmate.update({name:\"xiaoWang\"},{$addToSet:{interest:\"readBook\"}})\n```\n> 我们现在要查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.\n4. $each 批量追加\n```\nvar newInterset=[\"Sing\",\"Dance\",\"Code\"];\ndb.workmate.update({name:\"xiaoWang\"},{$addToSet:{interest:{$each:newInterset}}})\n````\n> 它可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作.\n5. $pop 删除数组值\n```\ndb.workmate.update({name:'xiaoWang'},{$pop:{interest:1}})\n```\n> $pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。\n\n> 1：从数组末端进行删除,\n> -1：从数组开端进行删除\n6. 数组定位修改\n```\ndb.workmate.update({name:'xiaoWang'},{$set:{\"interest.2\":\"Code\"}})\n```\n### 七、修改：状态返回与安全\n\n\n","slug":"Mongodb/Mongodb","published":1,"date":"2019-06-06T08:32:58.000Z","updated":"2019-06-06T08:33:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ig001y7xuqh7bnopa2","content":"<h3 id=\"一、-基础Shell命令。\"><a href=\"#一、-基础Shell命令。\" class=\"headerlink\" title=\"一、 基础Shell命令。\"></a>一、 基础Shell命令。</h3><ul>\n<li>show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。</li>\n<li>use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。9（如果当前数据库名字不存在则建立该名字的数据库，但是在没有集合前，它还是默认为空。）</li>\n<li>show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。</li>\n<li><p>db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。</p>\n<h3 id=\"二、-数据操作基础命令：\"><a href=\"#二、-数据操作基础命令：\" class=\"headerlink\" title=\"二、 数据操作基础命令：\"></a>二、 数据操作基础命令：</h3></li>\n<li><p>use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。</p>\n</li>\n<li>db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”})</li>\n<li>db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find()</li>\n<li>db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。</li>\n<li><p>db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.jspang.update(&#123;&quot;name&quot;:&quot;jspang&quot;&#125;,&#123;&quot;name&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;32&quot;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”})</p>\n</li>\n<li>db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。</li>\n<li>db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。<h3 id=\"三、在操作数据库时要注意两个能力：\"><a href=\"#三、在操作数据库时要注意两个能力：\" class=\"headerlink\" title=\"三、在操作数据库时要注意两个能力：\"></a>三、在操作数据库时要注意两个能力：</h3></li>\n</ul>\n<ol>\n<li>第一个是快速存储能力。</li>\n<li>第二个是方便迅速查询能力。<h3 id=\"四、-批量插入\"><a href=\"#四、-批量插入\" class=\"headerlink\" title=\"四、 批量插入\"></a>四、 批量插入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.test.insert([</span><br><span class=\"line\">    &#123;&quot;_id&quot;:1&#125;,</span><br><span class=\"line\">    &#123;&quot;_id&quot;:2&#125;,</span><br><span class=\"line\">    &#123;&quot;_id&quot;:3&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<ol>\n<li>注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好，这也算是一个规则。 </li>\n<li>数据插入选用批量插入性能远远大于循环插入。<h3 id=\"五、-update修改器\"><a href=\"#五、-update修改器\" class=\"headerlink\" title=\"五、 update修改器\"></a>五、 update修改器</h3></li>\n<li>修改非嵌入文档<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbd .workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;sex:2,age:21&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>修改嵌入文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;skill.skillThree&quot;:&apos;word&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$unset用于将key删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$unset:&#123;&quot;age&quot;:&apos;&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$inc对数字进行计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:-2&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>multi选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>只改变了第一个数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）</p>\n<ol>\n<li>upsert选项<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;age:20&#125;&#125;,&#123;upsert:true&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>upsert是在找不到值的情况下，直接插入这条数据。upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)。</p>\n<h3 id=\"六-update数组修改器\"><a href=\"#六-update数组修改器\" class=\"headerlink\" title=\"六. update数组修改器\"></a>六. update数组修改器</h3><ol>\n<li>$push追加数组/内嵌文档值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$push:&#123;interest:&apos;draw&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>$push的功能是追加数组中的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;MinJie&apos;&#125;,&#123;$push:&#123;&quot;skill.skillFour&quot;:&apos;draw&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>$push修饰符内嵌文档增加值</p>\n<ol>\n<li>$ne查找是否存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;,&quot;interest&quot;:&#123;$ne:&apos;playGame&apos;&#125;&#125;,&#123;$push:&#123;interest:&apos;Game&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果xiaoWang的爱好（interest）里没有palyGame这个值，我们就加入Game这个爱好。总结：没有则修改，有则不修改。</p>\n<ol>\n<li>\\$addToSet 升级版的\\$ne<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&quot;readBook&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们现在要查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.</p>\n<ol>\n<li>$each 批量追加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newInterset=[&quot;Sing&quot;,&quot;Dance&quot;,&quot;Code&quot;];</span><br><span class=\"line\">db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&#123;$each:newInterset&#125;&#125;&#125;)</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>它可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作.</p>\n<ol>\n<li>$pop 删除数组值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$pop:&#123;interest:1&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>$pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。</p>\n<p>1：从数组末端进行删除,<br>-1：从数组开端进行删除</p>\n<ol>\n<li>数组定位修改<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;&quot;interest.2&quot;:&quot;Code&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"七、修改：状态返回与安全\"><a href=\"#七、修改：状态返回与安全\" class=\"headerlink\" title=\"七、修改：状态返回与安全\"></a>七、修改：状态返回与安全</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、-基础Shell命令。\"><a href=\"#一、-基础Shell命令。\" class=\"headerlink\" title=\"一、 基础Shell命令。\"></a>一、 基础Shell命令。</h3><ul>\n<li>show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。</li>\n<li>use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。9（如果当前数据库名字不存在则建立该名字的数据库，但是在没有集合前，它还是默认为空。）</li>\n<li>show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。</li>\n<li><p>db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。</p>\n<h3 id=\"二、-数据操作基础命令：\"><a href=\"#二、-数据操作基础命令：\" class=\"headerlink\" title=\"二、 数据操作基础命令：\"></a>二、 数据操作基础命令：</h3></li>\n<li><p>use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。</p>\n</li>\n<li>db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”})</li>\n<li>db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find()</li>\n<li>db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。</li>\n<li><p>db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.jspang.update(&#123;&quot;name&quot;:&quot;jspang&quot;&#125;,&#123;&quot;name&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;32&quot;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”})</p>\n</li>\n<li>db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。</li>\n<li>db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。<h3 id=\"三、在操作数据库时要注意两个能力：\"><a href=\"#三、在操作数据库时要注意两个能力：\" class=\"headerlink\" title=\"三、在操作数据库时要注意两个能力：\"></a>三、在操作数据库时要注意两个能力：</h3></li>\n</ul>\n<ol>\n<li>第一个是快速存储能力。</li>\n<li>第二个是方便迅速查询能力。<h3 id=\"四、-批量插入\"><a href=\"#四、-批量插入\" class=\"headerlink\" title=\"四、 批量插入\"></a>四、 批量插入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.test.insert([</span><br><span class=\"line\">    &#123;&quot;_id&quot;:1&#125;,</span><br><span class=\"line\">    &#123;&quot;_id&quot;:2&#125;,</span><br><span class=\"line\">    &#123;&quot;_id&quot;:3&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<ol>\n<li>注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好，这也算是一个规则。 </li>\n<li>数据插入选用批量插入性能远远大于循环插入。<h3 id=\"五、-update修改器\"><a href=\"#五、-update修改器\" class=\"headerlink\" title=\"五、 update修改器\"></a>五、 update修改器</h3></li>\n<li>修改非嵌入文档<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbd .workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;sex:2,age:21&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>修改嵌入文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;skill.skillThree&quot;:&apos;word&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$unset用于将key删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$unset:&#123;&quot;age&quot;:&apos;&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$inc对数字进行计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:-2&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>multi选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>只改变了第一个数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）</p>\n<ol>\n<li>upsert选项<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;age:20&#125;&#125;,&#123;upsert:true&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>upsert是在找不到值的情况下，直接插入这条数据。upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)。</p>\n<h3 id=\"六-update数组修改器\"><a href=\"#六-update数组修改器\" class=\"headerlink\" title=\"六. update数组修改器\"></a>六. update数组修改器</h3><ol>\n<li>$push追加数组/内嵌文档值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$push:&#123;interest:&apos;draw&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>$push的功能是追加数组中的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;MinJie&apos;&#125;,&#123;$push:&#123;&quot;skill.skillFour&quot;:&apos;draw&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>$push修饰符内嵌文档增加值</p>\n<ol>\n<li>$ne查找是否存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;,&quot;interest&quot;:&#123;$ne:&apos;playGame&apos;&#125;&#125;,&#123;$push:&#123;interest:&apos;Game&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果xiaoWang的爱好（interest）里没有palyGame这个值，我们就加入Game这个爱好。总结：没有则修改，有则不修改。</p>\n<ol>\n<li>\\$addToSet 升级版的\\$ne<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&quot;readBook&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们现在要查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.</p>\n<ol>\n<li>$each 批量追加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newInterset=[&quot;Sing&quot;,&quot;Dance&quot;,&quot;Code&quot;];</span><br><span class=\"line\">db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&#123;$each:newInterset&#125;&#125;&#125;)</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>它可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作.</p>\n<ol>\n<li>$pop 删除数组值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$pop:&#123;interest:1&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>$pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。</p>\n<p>1：从数组末端进行删除,<br>-1：从数组开端进行删除</p>\n<ol>\n<li>数组定位修改<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;&quot;interest.2&quot;:&quot;Code&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"七、修改：状态返回与安全\"><a href=\"#七、修改：状态返回与安全\" class=\"headerlink\" title=\"七、修改：状态返回与安全\"></a>七、修改：状态返回与安全</h3>"},{"title":"Vuex","_content":"## 1.mapState 获取state值\n---\n    定义方式\n    import {mapState} from ‘vuex’\n    使用方式\n    对象\n    ```\n    computed: mapState({\n        count: state=>state.count\n    })\n    ```\n    数组\n    ```\n    computed: mapState([count])\n    ```\n## 2.getter 获取state的值（过滤）\n---\n    定义方式\n    写在vuex里面\n    ```\n    getters: {\n        state => {\n            return state.todos.filter(todo => todo.done) 过滤数据\n        }\n    }\n    ```\n    方法有两个参数（state,getters）getters（可以认为是 store 的计算属性）state是状态值\n\n    getter也可以返回一个函数 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n    ```\n    getTodoById: (state) => (id) => {\n        return state.todos.find(todo => todo.id === id)\n    }\n    store.getters.getTodoById(2) \n    ```\n    使用方式\n    import { mapGetters } from 'vuex'\n\n    数组     使用对象展开运算符将 getter 混入 computed 对象中\n    ```\n    computed: {\n        ...mapGetters([\n        'doneTodosCount',\n        'anotherGetter'\n        ])\n    }\n    ```\n    对象 （对象的好处是getter 属性另取一个名字)\n    把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n    ```\n    mapGetters({\n        doneCount: 'doneTodosCount'\n    })\n    ```\n## 3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）\n    定义\n    // mutation-types.js\n    export const SOME_MUTATION = 'SOME_MUTATION' \n    // store.js\n    import Vuex from 'vuex'\n    import { SOME_MUTATION } from './mutation-types'\n    ```\n    const store = new Vuex.Store({\n        state: { ... },\n        mutations: {\n            // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n            [SOME_MUTATION] (state,params) {\n            // mutate state\n            }\n        }\n    })\n    ```\n    使用\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    ```\n    methods: {\n        数组\n        ...mapMutations([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n            // `mapMutations` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n            ]),\n        对象\n        ...mapMutations({\n            add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n        })\n    }\n    ```\n## 4.Action 类似于 mutation，不同在于：\n\n    Action 提交的是 mutation，而不是直接变更状态。\n    Action 可以包含任意异步操作。\n    定义\n    ```\n    actions: {\n        increment (context) {\n            context.commit('increment')\n        }\n    }\n    ```\n    Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n    ```\n    actions: {\n        increment ({commit}) {\n            commit('increment')\n        }\n    }\n    ```\n    使用\n    // 以载荷形式分发\n    ```\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n\n    // 以对象形式分发\n    store.dispatch({\n        type: 'incrementAsync',\n        amount: 10\n    })\n    actions: {\n        checkout ({ commit, state }, products) {\n            // 把当前购物车的物品备份起来\n            const savedCartItems = [...state.cart.added]\n            // 发出结账请求，然后乐观地清空购物车\n            commit(types.CHECKOUT_REQUEST)\n            // 购物 API 接受一个成功回调和一个失败回调\n            shop.buyProducts(\n            products,\n            // 成功操作\n            () => commit(types.CHECKOUT_SUCCESS),\n            // 失败操作\n            () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n            )\n        }\n    }\n    ```\n    使用\n    ```\n    import { mapActions } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n        ...mapActions([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n            // `mapActions` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n        ]),\n        ...mapActions({\n            add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n        })\n    }\n    ```\n    定义\n    actions结束后触发函数\n    ```\n    actions: {\n        actionA ({ commit }) {\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    commit('someMutation')\n                    resolve()\n                }, 1000)\n            })\n        }\n    }\n    ```\n    使用\n    ```\n    store.dispatch('actionA').then(() => {\n    // ...\n    })\n    ```\n    在另外一个 action 中也可以：\n    ```\n    actions: {\n    // ...\n    actionB ({ dispatch, commit }) {\n            return dispatch('actionA').then(() => {\n                commit('someOtherMutation')\n            })\n        }\n    }\n    ```\n    最后，如果我们利用 async / await，我们可以如下组合 action：\n\n    // 假设 getData() 和 getOtherData() 返回的是 Promise\n    ```\n    actions: {\n        async actionA ({ commit }) {\n            commit('gotData', await getData())\n        },\n        async actionB ({ dispatch, commit }) {\n            await dispatch('actionA') // 等待 actionA 完成\n            commit('gotOtherData', await getOtherData())\n        }\n    }\n    ```\n\n## 5.模块\n    ```\n    const moduleA = {\n        state: { ... },\n        mutations: { ... },\n        actions: { ... },\n        getters: { ... }\n    }\n\n    const moduleB = {\n        state: { ... },\n        mutations: { ... },\n        actions: { ... }\n    }\n\n    const store = new Vuex.Store({\n    modules: {\n        a: moduleA,\n        b: moduleB\n    }\n    })\n\n    store.state.a // -> moduleA 的状态\n    store.state.b // -> moduleB 的状态\n    ```\n\n\n\n\n\n\n\n\n","source":"_posts/Vue/vuex.md","raw":"---\ntitle: Vuex\ncategories: ['前端']\ntags: ['Vuex'] \n---\n## 1.mapState 获取state值\n---\n    定义方式\n    import {mapState} from ‘vuex’\n    使用方式\n    对象\n    ```\n    computed: mapState({\n        count: state=>state.count\n    })\n    ```\n    数组\n    ```\n    computed: mapState([count])\n    ```\n## 2.getter 获取state的值（过滤）\n---\n    定义方式\n    写在vuex里面\n    ```\n    getters: {\n        state => {\n            return state.todos.filter(todo => todo.done) 过滤数据\n        }\n    }\n    ```\n    方法有两个参数（state,getters）getters（可以认为是 store 的计算属性）state是状态值\n\n    getter也可以返回一个函数 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n    ```\n    getTodoById: (state) => (id) => {\n        return state.todos.find(todo => todo.id === id)\n    }\n    store.getters.getTodoById(2) \n    ```\n    使用方式\n    import { mapGetters } from 'vuex'\n\n    数组     使用对象展开运算符将 getter 混入 computed 对象中\n    ```\n    computed: {\n        ...mapGetters([\n        'doneTodosCount',\n        'anotherGetter'\n        ])\n    }\n    ```\n    对象 （对象的好处是getter 属性另取一个名字)\n    把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n    ```\n    mapGetters({\n        doneCount: 'doneTodosCount'\n    })\n    ```\n## 3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）\n    定义\n    // mutation-types.js\n    export const SOME_MUTATION = 'SOME_MUTATION' \n    // store.js\n    import Vuex from 'vuex'\n    import { SOME_MUTATION } from './mutation-types'\n    ```\n    const store = new Vuex.Store({\n        state: { ... },\n        mutations: {\n            // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n            [SOME_MUTATION] (state,params) {\n            // mutate state\n            }\n        }\n    })\n    ```\n    使用\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    ```\n    methods: {\n        数组\n        ...mapMutations([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n            // `mapMutations` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n            ]),\n        对象\n        ...mapMutations({\n            add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n        })\n    }\n    ```\n## 4.Action 类似于 mutation，不同在于：\n\n    Action 提交的是 mutation，而不是直接变更状态。\n    Action 可以包含任意异步操作。\n    定义\n    ```\n    actions: {\n        increment (context) {\n            context.commit('increment')\n        }\n    }\n    ```\n    Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n    ```\n    actions: {\n        increment ({commit}) {\n            commit('increment')\n        }\n    }\n    ```\n    使用\n    // 以载荷形式分发\n    ```\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n\n    // 以对象形式分发\n    store.dispatch({\n        type: 'incrementAsync',\n        amount: 10\n    })\n    actions: {\n        checkout ({ commit, state }, products) {\n            // 把当前购物车的物品备份起来\n            const savedCartItems = [...state.cart.added]\n            // 发出结账请求，然后乐观地清空购物车\n            commit(types.CHECKOUT_REQUEST)\n            // 购物 API 接受一个成功回调和一个失败回调\n            shop.buyProducts(\n            products,\n            // 成功操作\n            () => commit(types.CHECKOUT_SUCCESS),\n            // 失败操作\n            () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n            )\n        }\n    }\n    ```\n    使用\n    ```\n    import { mapActions } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n        ...mapActions([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n            // `mapActions` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n        ]),\n        ...mapActions({\n            add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n        })\n    }\n    ```\n    定义\n    actions结束后触发函数\n    ```\n    actions: {\n        actionA ({ commit }) {\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    commit('someMutation')\n                    resolve()\n                }, 1000)\n            })\n        }\n    }\n    ```\n    使用\n    ```\n    store.dispatch('actionA').then(() => {\n    // ...\n    })\n    ```\n    在另外一个 action 中也可以：\n    ```\n    actions: {\n    // ...\n    actionB ({ dispatch, commit }) {\n            return dispatch('actionA').then(() => {\n                commit('someOtherMutation')\n            })\n        }\n    }\n    ```\n    最后，如果我们利用 async / await，我们可以如下组合 action：\n\n    // 假设 getData() 和 getOtherData() 返回的是 Promise\n    ```\n    actions: {\n        async actionA ({ commit }) {\n            commit('gotData', await getData())\n        },\n        async actionB ({ dispatch, commit }) {\n            await dispatch('actionA') // 等待 actionA 完成\n            commit('gotOtherData', await getOtherData())\n        }\n    }\n    ```\n\n## 5.模块\n    ```\n    const moduleA = {\n        state: { ... },\n        mutations: { ... },\n        actions: { ... },\n        getters: { ... }\n    }\n\n    const moduleB = {\n        state: { ... },\n        mutations: { ... },\n        actions: { ... }\n    }\n\n    const store = new Vuex.Store({\n    modules: {\n        a: moduleA,\n        b: moduleB\n    }\n    })\n\n    store.state.a // -> moduleA 的状态\n    store.state.b // -> moduleB 的状态\n    ```\n\n\n\n\n\n\n\n\n","slug":"Vue/vuex","published":1,"date":"2019-06-06T09:35:49.000Z","updated":"2019-06-06T10:00:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ig001z7xuq9x12s5og","content":"<h2 id=\"1-mapState-获取state值\"><a href=\"#1-mapState-获取state值\" class=\"headerlink\" title=\"1.mapState 获取state值\"></a>1.mapState 获取state值</h2><hr>\n<pre><code>定义方式\nimport {mapState} from ‘vuex’\n使用方式\n对象\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState(&#123;</span><br><span class=\"line\">    count: state=&gt;state.count</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n数组\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([count])</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"2-getter-获取state的值（过滤）\"><a href=\"#2-getter-获取state的值（过滤）\" class=\"headerlink\" title=\"2.getter 获取state的值（过滤）\"></a>2.getter 获取state的值（过滤）</h2><hr>\n<pre><code>定义方式\n写在vuex里面\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    state =&gt; &#123;</span><br><span class=\"line\">        return state.todos.filter(todo =&gt; todo.done) 过滤数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n方法有两个参数（state,getters）getters（可以认为是 store 的计算属性）state是状态值\n\ngetter也可以返回一个函数 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(2)</span><br></pre></td></tr></table></figure>\n\n使用方式\nimport { mapGetters } from &apos;vuex&apos;\n\n数组     使用对象展开运算符将 getter 混入 computed 对象中\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">    &apos;doneTodosCount&apos;,</span><br><span class=\"line\">    &apos;anotherGetter&apos;</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n对象 （对象的好处是getter 属性另取一个名字)\n把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">    doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"3-Mutation（更改-Vuex-的-store-中的状态的唯一方法是提交-mutation。同步）\"><a href=\"#3-Mutation（更改-Vuex-的-store-中的状态的唯一方法是提交-mutation。同步）\" class=\"headerlink\" title=\"3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）\"></a>3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）</h2><pre><code>定义\n// mutation-types.js\nexport const SOME_MUTATION = &apos;SOME_MUTATION&apos; \n// store.js\nimport Vuex from &apos;vuex&apos;\nimport { SOME_MUTATION } from &apos;./mutation-types&apos;\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class=\"line\">        [SOME_MUTATION] (state,params) &#123;</span><br><span class=\"line\">        // mutate state</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n使用\nimport { mapMutations } from &apos;vuex&apos;\n\nexport default {\n// ...\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    数组</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">        &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">        // `mapMutations` 也支持载荷：</span><br><span class=\"line\">        &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">    对象</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">        add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"4-Action-类似于-mutation，不同在于：\"><a href=\"#4-Action-类似于-mutation，不同在于：\" class=\"headerlink\" title=\"4.Action 类似于 mutation，不同在于：\"></a>4.Action 类似于 mutation，不同在于：</h2><pre><code>Action 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n定义\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">        context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (&#123;commit&#125;) &#123;</span><br><span class=\"line\">        commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n// 以载荷形式分发\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&apos;incrementAsync&apos;, &#123;</span><br><span class=\"line\">    amount: 10</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 以对象形式分发</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">    type: &apos;incrementAsync&apos;,</span><br><span class=\"line\">    amount: 10</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">        // 把当前购物车的物品备份起来</span><br><span class=\"line\">        const savedCartItems = [...state.cart.added]</span><br><span class=\"line\">        // 发出结账请求，然后乐观地清空购物车</span><br><span class=\"line\">        commit(types.CHECKOUT_REQUEST)</span><br><span class=\"line\">        // 购物 API 接受一个成功回调和一个失败回调</span><br><span class=\"line\">        shop.buyProducts(</span><br><span class=\"line\">        products,</span><br><span class=\"line\">        // 成功操作</span><br><span class=\"line\">        () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class=\"line\">        // 失败操作</span><br><span class=\"line\">        () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">        &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">        // `mapActions` 也支持载荷：</span><br><span class=\"line\">        &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">        add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n定义\nactions结束后触发函数\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">            setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                commit(&apos;someMutation&apos;)</span><br><span class=\"line\">                resolve()</span><br><span class=\"line\">            &#125;, 1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n在另外一个 action 中也可以：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">        return dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">            commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n最后，如果我们利用 async / await，我们可以如下组合 action：\n\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    async actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(&apos;gotData&apos;, await getData())</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">        await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class=\"line\">        commit(&apos;gotOtherData&apos;, await getOtherData())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"5-模块\"><a href=\"#5-模块\" class=\"headerlink\" title=\"5.模块\"></a>5.模块</h2><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123; ... &#125;,</span><br><span class=\"line\">    actions: &#123; ... &#125;,</span><br><span class=\"line\">    getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123; ... &#125;,</span><br><span class=\"line\">    actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-mapState-获取state值\"><a href=\"#1-mapState-获取state值\" class=\"headerlink\" title=\"1.mapState 获取state值\"></a>1.mapState 获取state值</h2><hr>\n<pre><code>定义方式\nimport {mapState} from ‘vuex’\n使用方式\n对象\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState(&#123;</span><br><span class=\"line\">    count: state=&gt;state.count</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n数组\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([count])</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"2-getter-获取state的值（过滤）\"><a href=\"#2-getter-获取state的值（过滤）\" class=\"headerlink\" title=\"2.getter 获取state的值（过滤）\"></a>2.getter 获取state的值（过滤）</h2><hr>\n<pre><code>定义方式\n写在vuex里面\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    state =&gt; &#123;</span><br><span class=\"line\">        return state.todos.filter(todo =&gt; todo.done) 过滤数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n方法有两个参数（state,getters）getters（可以认为是 store 的计算属性）state是状态值\n\ngetter也可以返回一个函数 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(2)</span><br></pre></td></tr></table></figure>\n\n使用方式\nimport { mapGetters } from &apos;vuex&apos;\n\n数组     使用对象展开运算符将 getter 混入 computed 对象中\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">    &apos;doneTodosCount&apos;,</span><br><span class=\"line\">    &apos;anotherGetter&apos;</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n对象 （对象的好处是getter 属性另取一个名字)\n把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">    doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"3-Mutation（更改-Vuex-的-store-中的状态的唯一方法是提交-mutation。同步）\"><a href=\"#3-Mutation（更改-Vuex-的-store-中的状态的唯一方法是提交-mutation。同步）\" class=\"headerlink\" title=\"3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）\"></a>3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）</h2><pre><code>定义\n// mutation-types.js\nexport const SOME_MUTATION = &apos;SOME_MUTATION&apos; \n// store.js\nimport Vuex from &apos;vuex&apos;\nimport { SOME_MUTATION } from &apos;./mutation-types&apos;\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">        // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class=\"line\">        [SOME_MUTATION] (state,params) &#123;</span><br><span class=\"line\">        // mutate state</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n使用\nimport { mapMutations } from &apos;vuex&apos;\n\nexport default {\n// ...\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    数组</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">        &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">        // `mapMutations` 也支持载荷：</span><br><span class=\"line\">        &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">    对象</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">        add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"4-Action-类似于-mutation，不同在于：\"><a href=\"#4-Action-类似于-mutation，不同在于：\" class=\"headerlink\" title=\"4.Action 类似于 mutation，不同在于：\"></a>4.Action 类似于 mutation，不同在于：</h2><pre><code>Action 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n定义\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">        context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (&#123;commit&#125;) &#123;</span><br><span class=\"line\">        commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n// 以载荷形式分发\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&apos;incrementAsync&apos;, &#123;</span><br><span class=\"line\">    amount: 10</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 以对象形式分发</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">    type: &apos;incrementAsync&apos;,</span><br><span class=\"line\">    amount: 10</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">        // 把当前购物车的物品备份起来</span><br><span class=\"line\">        const savedCartItems = [...state.cart.added]</span><br><span class=\"line\">        // 发出结账请求，然后乐观地清空购物车</span><br><span class=\"line\">        commit(types.CHECKOUT_REQUEST)</span><br><span class=\"line\">        // 购物 API 接受一个成功回调和一个失败回调</span><br><span class=\"line\">        shop.buyProducts(</span><br><span class=\"line\">        products,</span><br><span class=\"line\">        // 成功操作</span><br><span class=\"line\">        () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class=\"line\">        // 失败操作</span><br><span class=\"line\">        () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">        &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">        // `mapActions` 也支持载荷：</span><br><span class=\"line\">        &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">        add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n定义\nactions结束后触发函数\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">            setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                commit(&apos;someMutation&apos;)</span><br><span class=\"line\">                resolve()</span><br><span class=\"line\">            &#125;, 1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n使用\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n在另外一个 action 中也可以：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">        return dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">            commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n最后，如果我们利用 async / await，我们可以如下组合 action：\n\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    async actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(&apos;gotData&apos;, await getData())</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">        await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class=\"line\">        commit(&apos;gotOtherData&apos;, await getOtherData())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h2 id=\"5-模块\"><a href=\"#5-模块\" class=\"headerlink\" title=\"5.模块\"></a>5.模块</h2><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123; ... &#125;,</span><br><span class=\"line\">    actions: &#123; ... &#125;,</span><br><span class=\"line\">    getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">    state: &#123; ... &#125;,</span><br><span class=\"line\">    mutations: &#123; ... &#125;,</span><br><span class=\"line\">    actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>\n</code></pre>"},{"title":"JavaScript双端队列(Queue)","_content":"### 一、概念\n- 是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n```\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n\n  addFront(element) {\n    if (this.isEmpty()) {\n      this.addBack(element);\n    } else if (this.lowestCount > 0) {\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) {\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.items[0] = element;\n    }\n  }\n\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return result;\n  }\n\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n\n  size() {\n    return this.count - this.lowestCount;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n\n```","source":"_posts/DataStructure/JavaScript双端队列(Queue).md","raw":"---\ntitle: JavaScript双端队列(Queue)\ncategories: ['数据结构']\ntags: ['JavaScript'] \n---\n### 一、概念\n- 是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n```\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n\n  addFront(element) {\n    if (this.isEmpty()) {\n      this.addBack(element);\n    } else if (this.lowestCount > 0) {\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) {\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.items[0] = element;\n    }\n  }\n\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return result;\n  }\n\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n\n  size() {\n    return this.count - this.lowestCount;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n\n```","slug":"DataStructure/JavaScript双端队列(Queue)","published":1,"date":"2019-06-14T08:23:14.000Z","updated":"2019-06-14T08:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ih00207xuqq5wgh6s8","content":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>是一种允许我们同时从前端和后端添加和移除元素的特殊队列</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Deque &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addFront(element) &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      this.addBack(element);</span><br><span class=\"line\">    &#125; else if (this.lowestCount &gt; 0) &#123;</span><br><span class=\"line\">      this.lowestCount--;</span><br><span class=\"line\">      this.items[this.lowestCount] = element;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      for (let i = this.count; i &gt; 0; i--) &#123;</span><br><span class=\"line\">        this.items[i] = this.items[i - 1];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.count++;</span><br><span class=\"line\">      this.items[0] = element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addBack(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeFront() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const result = this.items[this.lowestCount];</span><br><span class=\"line\">    delete this.items[this.lowestCount];</span><br><span class=\"line\">    this.lowestCount++;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeBack() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.count--;</span><br><span class=\"line\">    const result = this.items[this.count];</span><br><span class=\"line\">    delete this.items[this.count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peekFront() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peekBack() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count - this.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[this.lowestCount]&#125;`;</span><br><span class=\"line\">    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>是一种允许我们同时从前端和后端添加和移除元素的特殊队列</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Deque &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addFront(element) &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      this.addBack(element);</span><br><span class=\"line\">    &#125; else if (this.lowestCount &gt; 0) &#123;</span><br><span class=\"line\">      this.lowestCount--;</span><br><span class=\"line\">      this.items[this.lowestCount] = element;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      for (let i = this.count; i &gt; 0; i--) &#123;</span><br><span class=\"line\">        this.items[i] = this.items[i - 1];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.count++;</span><br><span class=\"line\">      this.items[0] = element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addBack(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeFront() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const result = this.items[this.lowestCount];</span><br><span class=\"line\">    delete this.items[this.lowestCount];</span><br><span class=\"line\">    this.lowestCount++;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeBack() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.count--;</span><br><span class=\"line\">    const result = this.items[this.count];</span><br><span class=\"line\">    delete this.items[this.count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peekFront() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peekBack() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.lowestCount = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count - this.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[this.lowestCount]&#125;`;</span><br><span class=\"line\">    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"排序算法","_content":"\n### 一、冒泡排序\n```\n\n写法一\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        //相邻元素两两对比\n                var temp = arr[j+1];        //元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\n写法二\nconst Compare = {\n  LESS_THAN: -1,\n  BIGGER_THAN: 1,\n  EQUALS: 0\n};\nfunction defaultCompare(a, b) {\n  if (a === b) {\n    return Compare.EQUALS;\n  }\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction swap(array, a, b) {\n  /* const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp; */\n  [array[a], array[b]] = [array[b], array[a]];\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1; j++) {\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n```\n\n{% asset_img bubbleSort.gif bubbleSort %}\n### 二、选择排序\n\n```\n方法一\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        if(i !== minIndex) {\n            temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n        \n    }\n    return arr;\n}\n\n写法二\nconst Compare = {\n  LESS_THAN: -1,\n  BIGGER_THAN: 1,\n  EQUALS: 0\n};\nfunction defaultCompare(a, b) {\n  if (a === b) {\n    return Compare.EQUALS;\n  }\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction swap(array, a, b) {\n  /* const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp; */\n  [array[a], array[b]] = [array[b], array[a]];\n}\nfunction selectionSort = (array, compareFn = defaultCompare) => {\n  const { length } = array;\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    indexMin = i;\n    for (let j = i; j < length; j++) {\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        indexMin = j;\n      }\n    }\n    if (i !== indexMin) {\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n};\n\n```\n### 三、插入排序\n```\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex+1] = current;\n    }\n    return arr;\n}\n```\n### 四、归并排序\n```\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n```\n","source":"_posts/排序算法和搜索算法/排序算法.md","raw":"---\ntitle: 排序算法\ncategories: ['算法']\ntags: ['排序算法'] \n---\n\n### 一、冒泡排序\n```\n\n写法一\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        //相邻元素两两对比\n                var temp = arr[j+1];        //元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\n写法二\nconst Compare = {\n  LESS_THAN: -1,\n  BIGGER_THAN: 1,\n  EQUALS: 0\n};\nfunction defaultCompare(a, b) {\n  if (a === b) {\n    return Compare.EQUALS;\n  }\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction swap(array, a, b) {\n  /* const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp; */\n  [array[a], array[b]] = [array[b], array[a]];\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1; j++) {\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n```\n\n{% asset_img bubbleSort.gif bubbleSort %}\n### 二、选择排序\n\n```\n方法一\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        if(i !== minIndex) {\n            temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n        \n    }\n    return arr;\n}\n\n写法二\nconst Compare = {\n  LESS_THAN: -1,\n  BIGGER_THAN: 1,\n  EQUALS: 0\n};\nfunction defaultCompare(a, b) {\n  if (a === b) {\n    return Compare.EQUALS;\n  }\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction swap(array, a, b) {\n  /* const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp; */\n  [array[a], array[b]] = [array[b], array[a]];\n}\nfunction selectionSort = (array, compareFn = defaultCompare) => {\n  const { length } = array;\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    indexMin = i;\n    for (let j = i; j < length; j++) {\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        indexMin = j;\n      }\n    }\n    if (i !== indexMin) {\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n};\n\n```\n### 三、插入排序\n```\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex+1] = current;\n    }\n    return arr;\n}\n```\n### 四、归并排序\n```\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\n\n```\n","slug":"排序算法和搜索算法/排序算法","published":1,"date":"2019-06-21T02:14:57.000Z","updated":"2019-06-28T03:11:10.000Z","_id":"cjxe9u0ij00247xuqbxxl3uyd","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、冒泡排序\"><a href=\"#一、冒泡排序\" class=\"headerlink\" title=\"一、冒泡排序\"></a>一、冒泡排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">写法一</span><br><span class=\"line\">function bubbleSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class=\"line\">            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比</span><br><span class=\"line\">                var temp = arr[j+1];        //元素交换</span><br><span class=\"line\">                arr[j+1] = arr[j];</span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">const Compare = &#123;</span><br><span class=\"line\">  LESS_THAN: -1,</span><br><span class=\"line\">  BIGGER_THAN: 1,</span><br><span class=\"line\">  EQUALS: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function defaultCompare(a, b) &#123;</span><br><span class=\"line\">  if (a === b) &#123;</span><br><span class=\"line\">    return Compare.EQUALS;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function swap(array, a, b) &#123;</span><br><span class=\"line\">  /* const temp = array[a];</span><br><span class=\"line\">  array[a] = array[b];</span><br><span class=\"line\">  array[b] = temp; */</span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bubbleSort(array, compareFn = defaultCompare) &#123;</span><br><span class=\"line\">  const &#123; length &#125; = array;</span><br><span class=\"line\">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    for (let j = 0; j &lt; length - 1; j++) &#123;</span><br><span class=\"line\">      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、选择排序\"><a href=\"#二、选择排序\" class=\"headerlink\" title=\"二、选择排序\"></a>二、选择排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一</span><br><span class=\"line\">function selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(i !== minIndex) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            arr[i] = arr[minIndex];</span><br><span class=\"line\">            arr[minIndex] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">const Compare = &#123;</span><br><span class=\"line\">  LESS_THAN: -1,</span><br><span class=\"line\">  BIGGER_THAN: 1,</span><br><span class=\"line\">  EQUALS: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function defaultCompare(a, b) &#123;</span><br><span class=\"line\">  if (a === b) &#123;</span><br><span class=\"line\">    return Compare.EQUALS;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function swap(array, a, b) &#123;</span><br><span class=\"line\">  /* const temp = array[a];</span><br><span class=\"line\">  array[a] = array[b];</span><br><span class=\"line\">  array[b] = temp; */</span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function selectionSort = (array, compareFn = defaultCompare) =&gt; &#123;</span><br><span class=\"line\">  const &#123; length &#125; = array;</span><br><span class=\"line\">  let indexMin;</span><br><span class=\"line\">  for (let i = 0; i &lt; length - 1; i++) &#123;</span><br><span class=\"line\">    indexMin = i;</span><br><span class=\"line\">    for (let j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        indexMin = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (i !== indexMin) &#123;</span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return array;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、插入排序\"><a href=\"#三、插入排序\" class=\"headerlink\" title=\"三、插入排序\"></a>三、插入排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function insertionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var preIndex, current;</span><br><span class=\"line\">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class=\"line\">        preIndex = i - 1;</span><br><span class=\"line\">        current = arr[i];</span><br><span class=\"line\">        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">            arr[preIndex+1] = arr[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[preIndex+1] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、归并排序\"><a href=\"#四、归并排序\" class=\"headerlink\" title=\"四、归并排序\"></a>四、归并排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    if(len &lt; 2) &#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    return merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        if (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    while (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、冒泡排序\"><a href=\"#一、冒泡排序\" class=\"headerlink\" title=\"一、冒泡排序\"></a>一、冒泡排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">写法一</span><br><span class=\"line\">function bubbleSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class=\"line\">            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比</span><br><span class=\"line\">                var temp = arr[j+1];        //元素交换</span><br><span class=\"line\">                arr[j+1] = arr[j];</span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">const Compare = &#123;</span><br><span class=\"line\">  LESS_THAN: -1,</span><br><span class=\"line\">  BIGGER_THAN: 1,</span><br><span class=\"line\">  EQUALS: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function defaultCompare(a, b) &#123;</span><br><span class=\"line\">  if (a === b) &#123;</span><br><span class=\"line\">    return Compare.EQUALS;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function swap(array, a, b) &#123;</span><br><span class=\"line\">  /* const temp = array[a];</span><br><span class=\"line\">  array[a] = array[b];</span><br><span class=\"line\">  array[b] = temp; */</span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bubbleSort(array, compareFn = defaultCompare) &#123;</span><br><span class=\"line\">  const &#123; length &#125; = array;</span><br><span class=\"line\">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    for (let j = 0; j &lt; length - 1; j++) &#123;</span><br><span class=\"line\">      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、选择排序\"><a href=\"#二、选择排序\" class=\"headerlink\" title=\"二、选择排序\"></a>二、选择排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一</span><br><span class=\"line\">function selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(i !== minIndex) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            arr[i] = arr[minIndex];</span><br><span class=\"line\">            arr[minIndex] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">const Compare = &#123;</span><br><span class=\"line\">  LESS_THAN: -1,</span><br><span class=\"line\">  BIGGER_THAN: 1,</span><br><span class=\"line\">  EQUALS: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function defaultCompare(a, b) &#123;</span><br><span class=\"line\">  if (a === b) &#123;</span><br><span class=\"line\">    return Compare.EQUALS;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function swap(array, a, b) &#123;</span><br><span class=\"line\">  /* const temp = array[a];</span><br><span class=\"line\">  array[a] = array[b];</span><br><span class=\"line\">  array[b] = temp; */</span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function selectionSort = (array, compareFn = defaultCompare) =&gt; &#123;</span><br><span class=\"line\">  const &#123; length &#125; = array;</span><br><span class=\"line\">  let indexMin;</span><br><span class=\"line\">  for (let i = 0; i &lt; length - 1; i++) &#123;</span><br><span class=\"line\">    indexMin = i;</span><br><span class=\"line\">    for (let j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        indexMin = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (i !== indexMin) &#123;</span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return array;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、插入排序\"><a href=\"#三、插入排序\" class=\"headerlink\" title=\"三、插入排序\"></a>三、插入排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function insertionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var preIndex, current;</span><br><span class=\"line\">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class=\"line\">        preIndex = i - 1;</span><br><span class=\"line\">        current = arr[i];</span><br><span class=\"line\">        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">            arr[preIndex+1] = arr[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[preIndex+1] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、归并排序\"><a href=\"#四、归并排序\" class=\"headerlink\" title=\"四、归并排序\"></a>四、归并排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    if(len &lt; 2) &#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    return merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function merge(left, right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        if (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    while (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"JavaScript集合(Set)","_content":"\n### 一、概念\n- 集合：集合是由一组无序且唯一的项组成的。\n\n### 二、知识碎点\n- in运算符 验证给定的元素是否在对象上的属性。(原型链上有都会返回true)\n- Object.prototype.hasOwnProperty.call(Obj,element)。 (只是当前对象，不含原型链上的属性和方法)\n\n### 三、具体实现\n```\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element;\n      return true;\n    }\n    return false;\n  }\n\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element];\n      return true;\n    }\n    return false;\n  }\n\n  has(element) {\n    return Object.prototype.hasOwnProperty.call(this.items, element);\n  }\n\n  values() {\n    return Object.values(this.items);\n  }\n\n  并集\n  union(otherSet) {\n    const unionSet = new Set();\n    this.values().forEach(value => unionSet.add(value));\n    otherSet.values().forEach(value => unionSet.add(value));\n    return unionSet;\n  }\n  交集\n  intersection(otherSet) {\n    const intersectionSet = new Set();\n    const values = this.values();\n    const otherValues = otherSet.values();\n    let biggerSet = values;\n    let smallerSet = otherValues;\n    if (otherValues.length - values.length > 0) {\n      biggerSet = otherValues;\n      smallerSet = values;\n    }\n    smallerSet.forEach(value => {\n      if (biggerSet.includes(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  差集\n  difference(otherSet) {\n    const differenceSet = new Set();\n    this.values().forEach(value => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  子集\n  isSubsetOf(otherSet) {\n    if (this.size() > otherSet.size()) {\n      return false;\n    }\n    let isSubset = true;\n    this.values().every(value => {\n      if (!otherSet.has(value)) {\n        isSubset = false;\n        return false;\n      }\n      return true;\n    });\n    return isSubset;\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const values = this.values();\n    let objString = `${values[0]}`;\n    for (let i = 1; i < values.length; i++) {\n      objString = `${objString},${values[i].toString()}`;\n    }\n    return objString;\n  }\n}\n\n```","source":"_posts/DataStructure/JavaScript集合(Set).md","raw":"---\ntitle: JavaScript集合(Set)\ncategories: ['数据结构']\ntags: ['JavaScript'] \n---\n\n### 一、概念\n- 集合：集合是由一组无序且唯一的项组成的。\n\n### 二、知识碎点\n- in运算符 验证给定的元素是否在对象上的属性。(原型链上有都会返回true)\n- Object.prototype.hasOwnProperty.call(Obj,element)。 (只是当前对象，不含原型链上的属性和方法)\n\n### 三、具体实现\n```\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element;\n      return true;\n    }\n    return false;\n  }\n\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element];\n      return true;\n    }\n    return false;\n  }\n\n  has(element) {\n    return Object.prototype.hasOwnProperty.call(this.items, element);\n  }\n\n  values() {\n    return Object.values(this.items);\n  }\n\n  并集\n  union(otherSet) {\n    const unionSet = new Set();\n    this.values().forEach(value => unionSet.add(value));\n    otherSet.values().forEach(value => unionSet.add(value));\n    return unionSet;\n  }\n  交集\n  intersection(otherSet) {\n    const intersectionSet = new Set();\n    const values = this.values();\n    const otherValues = otherSet.values();\n    let biggerSet = values;\n    let smallerSet = otherValues;\n    if (otherValues.length - values.length > 0) {\n      biggerSet = otherValues;\n      smallerSet = values;\n    }\n    smallerSet.forEach(value => {\n      if (biggerSet.includes(value)) {\n        intersectionSet.add(value);\n      }\n    });\n    return intersectionSet;\n  }\n  差集\n  difference(otherSet) {\n    const differenceSet = new Set();\n    this.values().forEach(value => {\n      if (!otherSet.has(value)) {\n        differenceSet.add(value);\n      }\n    });\n    return differenceSet;\n  }\n  子集\n  isSubsetOf(otherSet) {\n    if (this.size() > otherSet.size()) {\n      return false;\n    }\n    let isSubset = true;\n    this.values().every(value => {\n      if (!otherSet.has(value)) {\n        isSubset = false;\n        return false;\n      }\n      return true;\n    });\n    return isSubset;\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const values = this.values();\n    let objString = `${values[0]}`;\n    for (let i = 1; i < values.length; i++) {\n      objString = `${objString},${values[i].toString()}`;\n    }\n    return objString;\n  }\n}\n\n```","slug":"DataStructure/JavaScript集合(Set)","published":1,"date":"2019-06-18T09:14:52.000Z","updated":"2019-06-18T09:48:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ik00267xuqbbpt01r5","content":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>集合：集合是由一组无序且唯一的项组成的。</li>\n</ul>\n<h3 id=\"二、知识碎点\"><a href=\"#二、知识碎点\" class=\"headerlink\" title=\"二、知识碎点\"></a>二、知识碎点</h3><ul>\n<li>in运算符 验证给定的元素是否在对象上的属性。(原型链上有都会返回true)</li>\n<li>Object.prototype.hasOwnProperty.call(Obj,element)。 (只是当前对象，不含原型链上的属性和方法)</li>\n</ul>\n<h3 id=\"三、具体实现\"><a href=\"#三、具体实现\" class=\"headerlink\" title=\"三、具体实现\"></a>三、具体实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Set &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add(element) &#123;</span><br><span class=\"line\">    if (!this.has(element)) &#123;</span><br><span class=\"line\">      this.items[element] = element;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  delete(element) &#123;</span><br><span class=\"line\">    if (this.has(element)) &#123;</span><br><span class=\"line\">      delete this.items[element];</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  has(element) &#123;</span><br><span class=\"line\">    return Object.prototype.hasOwnProperty.call(this.items, element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values() &#123;</span><br><span class=\"line\">    return Object.values(this.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  并集</span><br><span class=\"line\">  union(otherSet) &#123;</span><br><span class=\"line\">    const unionSet = new Set();</span><br><span class=\"line\">    this.values().forEach(value =&gt; unionSet.add(value));</span><br><span class=\"line\">    otherSet.values().forEach(value =&gt; unionSet.add(value));</span><br><span class=\"line\">    return unionSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  交集</span><br><span class=\"line\">  intersection(otherSet) &#123;</span><br><span class=\"line\">    const intersectionSet = new Set();</span><br><span class=\"line\">    const values = this.values();</span><br><span class=\"line\">    const otherValues = otherSet.values();</span><br><span class=\"line\">    let biggerSet = values;</span><br><span class=\"line\">    let smallerSet = otherValues;</span><br><span class=\"line\">    if (otherValues.length - values.length &gt; 0) &#123;</span><br><span class=\"line\">      biggerSet = otherValues;</span><br><span class=\"line\">      smallerSet = values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    smallerSet.forEach(value =&gt; &#123;</span><br><span class=\"line\">      if (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">        intersectionSet.add(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return intersectionSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  差集</span><br><span class=\"line\">  difference(otherSet) &#123;</span><br><span class=\"line\">    const differenceSet = new Set();</span><br><span class=\"line\">    this.values().forEach(value =&gt; &#123;</span><br><span class=\"line\">      if (!otherSet.has(value)) &#123;</span><br><span class=\"line\">        differenceSet.add(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return differenceSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  子集</span><br><span class=\"line\">  isSubsetOf(otherSet) &#123;</span><br><span class=\"line\">    if (this.size() &gt; otherSet.size()) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let isSubset = true;</span><br><span class=\"line\">    this.values().every(value =&gt; &#123;</span><br><span class=\"line\">      if (!otherSet.has(value)) &#123;</span><br><span class=\"line\">        isSubset = false;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return isSubset;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return Object.keys(this.items).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const values = this.values();</span><br><span class=\"line\">    let objString = `$&#123;values[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;values[i].toString()&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>集合：集合是由一组无序且唯一的项组成的。</li>\n</ul>\n<h3 id=\"二、知识碎点\"><a href=\"#二、知识碎点\" class=\"headerlink\" title=\"二、知识碎点\"></a>二、知识碎点</h3><ul>\n<li>in运算符 验证给定的元素是否在对象上的属性。(原型链上有都会返回true)</li>\n<li>Object.prototype.hasOwnProperty.call(Obj,element)。 (只是当前对象，不含原型链上的属性和方法)</li>\n</ul>\n<h3 id=\"三、具体实现\"><a href=\"#三、具体实现\" class=\"headerlink\" title=\"三、具体实现\"></a>三、具体实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Set &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add(element) &#123;</span><br><span class=\"line\">    if (!this.has(element)) &#123;</span><br><span class=\"line\">      this.items[element] = element;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  delete(element) &#123;</span><br><span class=\"line\">    if (this.has(element)) &#123;</span><br><span class=\"line\">      delete this.items[element];</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  has(element) &#123;</span><br><span class=\"line\">    return Object.prototype.hasOwnProperty.call(this.items, element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values() &#123;</span><br><span class=\"line\">    return Object.values(this.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  并集</span><br><span class=\"line\">  union(otherSet) &#123;</span><br><span class=\"line\">    const unionSet = new Set();</span><br><span class=\"line\">    this.values().forEach(value =&gt; unionSet.add(value));</span><br><span class=\"line\">    otherSet.values().forEach(value =&gt; unionSet.add(value));</span><br><span class=\"line\">    return unionSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  交集</span><br><span class=\"line\">  intersection(otherSet) &#123;</span><br><span class=\"line\">    const intersectionSet = new Set();</span><br><span class=\"line\">    const values = this.values();</span><br><span class=\"line\">    const otherValues = otherSet.values();</span><br><span class=\"line\">    let biggerSet = values;</span><br><span class=\"line\">    let smallerSet = otherValues;</span><br><span class=\"line\">    if (otherValues.length - values.length &gt; 0) &#123;</span><br><span class=\"line\">      biggerSet = otherValues;</span><br><span class=\"line\">      smallerSet = values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    smallerSet.forEach(value =&gt; &#123;</span><br><span class=\"line\">      if (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">        intersectionSet.add(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return intersectionSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  差集</span><br><span class=\"line\">  difference(otherSet) &#123;</span><br><span class=\"line\">    const differenceSet = new Set();</span><br><span class=\"line\">    this.values().forEach(value =&gt; &#123;</span><br><span class=\"line\">      if (!otherSet.has(value)) &#123;</span><br><span class=\"line\">        differenceSet.add(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return differenceSet;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  子集</span><br><span class=\"line\">  isSubsetOf(otherSet) &#123;</span><br><span class=\"line\">    if (this.size() &gt; otherSet.size()) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let isSubset = true;</span><br><span class=\"line\">    this.values().every(value =&gt; &#123;</span><br><span class=\"line\">      if (!otherSet.has(value)) &#123;</span><br><span class=\"line\">        isSubset = false;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return isSubset;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.size() === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return Object.keys(this.items).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const values = this.values();</span><br><span class=\"line\">    let objString = `$&#123;values[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;values[i].toString()&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"javascript 面向对象：3","_content":"1. 复习\n\t-> 继承\n\t\t原型式继承\n\t\t\tfunction Person() {}\n\t\t\tPerson.prototype = 父对象;\n\t\t\tvar p = new Person();\n\t\t\tp 继承自 父对象\n\t\t混入 ( mix, extend )\n\t\t\tfunction extend( o1, o2 ) {\n\t\t\t\tfor ( var k in o2 ) {\n\t\t\t\t\to1[ k ] = o2[ k ];\n\t\t\t\t}\n\t\t\t}\n\t\t注意命名规则: \n\t\t\t1> 一般 将一个对象混入另一个对象, 使用 mix\n\t\t\t2> 如果是当前对象的方法. 是将另一个对象混入当前对象一般使用 extend\n\n2. 对象的原型链\n\t-> 凡是对象都有原型\n\t-> 构造函数 Person 创建的对象 p 有原型 Person.prototype\n\n\t-> Person.prototype 是对象. 它有原型吗?\n\t-> 问题: \n\t\t1) 原型是什么?\n\t\t2) 原型既然是对象, 那么如何是个头?\t\n\n\t-> 结论\n\t\t1) Person.prototype 是 实例 p 的原型对象, 使用 __proto__ 可以访问对象的原型对象\n\t\t2) Person.prototype 的 原型对象是 Person.prototype.__proto__\n\t\t3) Person.prototype.__proto__ 里的 constructor 是 Object. 所以\n\t\t\tPerson.prototype.__proto__ 就是 Object.prototype\n\t\t4) Object.prototype.__proto__ 是 null. 因此表明 Object.prototype 就是顶级.\n\n\t-> 链式\n\t\tp --> Person.prototype( p.__proto__ ) --> Object.prototype --> null\n\n\t-> 系统内置的原型链\n\t\t[] --> Array.prototype --> Object.prototype --> null\n\t\t/./ --> RegExp.prototype --> Object.prototype --> null \n\t\t... ...\n\n3. 绘制数组的原型结构\n\tvar arr = [];\n\t// 等价\n\tvar arr = new Array();\n\n\tarr --> Array.prototype --> Object.prototype --> null\n\n4. 练习:\n\t根据下面代码绘制对象的原型链结构\n\t1) \tfunction Person( name, age, gender ) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tthis.gender = gender;\n\t\t}\n\t\tfunction Student () {}\n\n\t\tStudent.prototype = new Person( '张三', 19, '男' );\n\n\t\tvar stu = new Student();\n\n\t2)  function Person() {}\n\t\tvar p1 = new Person();\n\t\tvar p2 = new Person();\n\n5. {} 对象的原型链结构\n\t在 js 中 对象 一般都有字面量\n\t\t123, '123'\n\t数组: []\n\t正则表达式对象: /./\n\t函数: function () {}\n\t...\n\n\t对象也有字面量: {}\n\t{} --> Object.prototype --> null\n\n\t注意: {} 与 new Object() 含义相同\n\n\n6. 动态函数 Function\n\t-> 动态函数就是在运行的过程中, 将一段字符串作为代码运行. \n\t\t由于字符串可以随意的拼接. 因此得到动态的执行.\n\t-> 定义动态函数, 并执行\n\t\t-> 使用 Function 构造函数, 创建函数.\n\t\t\tFunction 是一个构造函数. new Function 得到 一个函数\n\t\t-> 语法\n\t\t\tnew Function( arg0, arg1, ..., argN, body )\n\n\t\t\tFunction 的所有的参数, 除了最后一个以外, 都是生成的函数的参数\n\t\t\t最后一个参数是 函数体\n\n7. 函数的相关的一些参数\n\targuments 凡是函数调用, 都会默认含有一个 arguments 对象. 可以将其看做为 \"数组\". 里面存储着调用时\n\t\t传入的所有参数. 可以使用数组的索引访问这些参数.\n\t\t例如: 写一个函数, 在参数中写任意个参数, 最后求其和\n\t\t\tfunction sum () {\n\t\t\t\t// 所有的参数都会存储到 arguments 中\n\t\t\t\tvar sum = 0;\n\t\t\t\tfor ( var i = 0; i < arguments.length; i++ ) {\n\t\t\t\t\tsum += arguments[ i ];\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t案例: \textend( o )  => 将 o 混入到当前对象 this 中\n\t\t\t\textend( o1, o2 ) => 将 o2 混入到 o1 中\n\n\t函数名.length, 即函数的 length 属性. 表示 定义函数时, 参数的个数\n\n\t如果定义函数的时候, 定义了参数. 但是调用的时候又没有传递该参数. 那么该参数在函数内就是 undefined\n\n\t函数.name 返回的是函数名\n\n8. 函数的引用 callee 与 caller\n\tjs 中函数也是一个对象\n\t-> callee 在函数的内部, 它表示 当前函数 的引用\n\t一般在函数内部, 实现函数递归的时候, 我们一般使用 callee 表示函数的引用\n\tfunction fn() {\n\t\targuments.callee();  // 使用 callee 来递归\n\t}\n\tfn();\n\t-> caller 表示调用函数的函数 //caller 就是在被调用函数中, 获得调用函数的引用\n\tfunction f2 () {\n\t\tconsole.log( f2.caller );\n\t}\n\n\tfunction itcast() {\n\t\tf2();\t\n\t}\n\n\titcast();\n\n9. eval 函数\n\teval 函数与 Function 功能类似. eval 可以直接将字符串作为代码来执行.\n\t语法:\n\t\teval( 语句字符串 )\n\t注意, 它好像与当前代码处于同一个作用域\n\teval 直接调用即执行。\n\tFunction 生成了一个函数function 需要调用才执行\n\n10. 使用 ajax 获得 json 格式的字符串后, 转换成对象\n\tvar data = '[ { \"name\": \"张三\", \"age\": 19, \"gender\": \"男\"}, { \"name\": \"李四\", \"age\": 18, \"gender\": \"女\"} ]';\n\t  json 格式( 严格的国际通用数据表示协议, 结构 )\n\t  在 js 中使用的 json 对象, 相对较松散\n\t  json 格式 有两种结构\n\t\t1: {}\n\t\t2: []\n\t\t注意: json 格式中, 键名也必须使用双引号括起来.\n\t\n\t\t 将字符串变成对象, 有三种做法\n\t\t 1. eval 做法\n\tvar o1 = eval( \"(\" + data + \")\" );   // 注意一个习惯. 就是数据两端一般加上圆括号为好\n\n\t\t2. Function 做法\n\tvar o2 = (new Function( 'return ' + data ))();\n\n\t\t3. 使用 ES5 中引入的标准处理 JSON 的语法\n\t\tJSON.parse(  )\n\t\t注意: 字符串必须是严格是 json 格式\n\tvar o3 = JSON.parse( data );\n\n\n\n\n\t\n11. 在 js 中 函数 是 Function 的实例\n\n\tfunction Person() {}\n\tvar p = new Person();\n\tp 是 构造函数 Person 的实例\n\n\t在 该角度去看, 函数就是对象, Function 就是构造函数\n\n\t得到 构造-实例-原型 三角形\n\n\tfunction Person() {} 为例\n\n12. 给定一个任意的对象, 将其原型链包括对象和函数的结构完整的分析处理\n\n13. instanceof 运算符\n\t-> a of b -> b 的 a\n\t-> instance of ?\n\t-> 错觉: 判断某一个对象是否为某一个构造函数所创建出来的\n\n\n14. 通过原型链的学习, 可以重新定义 js 的继承\n\n\tjs 的继承: 就是利用对象的动态特性添加成员, 或直接替换对象的方式修改原型链\n\t\t\t\t结构. 使得当前对象的原型链上的对象具有某些成员. 那么我的当前对象\n\t\t\t\t就可以使用这些成员了.\n\n\tp -> Person.prototype -> Object.prototype -> null\n\tp -> Person.prototype -> {} -> Object.prototype -> null\n\n\t过多的依赖原型链继承, 会损耗 性能\n\t如果必须使用原型链继承, 最好提供一些快速访问的方法\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象/面向对象第三天.md","raw":"---\ntitle: javascript 面向对象：3\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1. 复习\n\t-> 继承\n\t\t原型式继承\n\t\t\tfunction Person() {}\n\t\t\tPerson.prototype = 父对象;\n\t\t\tvar p = new Person();\n\t\t\tp 继承自 父对象\n\t\t混入 ( mix, extend )\n\t\t\tfunction extend( o1, o2 ) {\n\t\t\t\tfor ( var k in o2 ) {\n\t\t\t\t\to1[ k ] = o2[ k ];\n\t\t\t\t}\n\t\t\t}\n\t\t注意命名规则: \n\t\t\t1> 一般 将一个对象混入另一个对象, 使用 mix\n\t\t\t2> 如果是当前对象的方法. 是将另一个对象混入当前对象一般使用 extend\n\n2. 对象的原型链\n\t-> 凡是对象都有原型\n\t-> 构造函数 Person 创建的对象 p 有原型 Person.prototype\n\n\t-> Person.prototype 是对象. 它有原型吗?\n\t-> 问题: \n\t\t1) 原型是什么?\n\t\t2) 原型既然是对象, 那么如何是个头?\t\n\n\t-> 结论\n\t\t1) Person.prototype 是 实例 p 的原型对象, 使用 __proto__ 可以访问对象的原型对象\n\t\t2) Person.prototype 的 原型对象是 Person.prototype.__proto__\n\t\t3) Person.prototype.__proto__ 里的 constructor 是 Object. 所以\n\t\t\tPerson.prototype.__proto__ 就是 Object.prototype\n\t\t4) Object.prototype.__proto__ 是 null. 因此表明 Object.prototype 就是顶级.\n\n\t-> 链式\n\t\tp --> Person.prototype( p.__proto__ ) --> Object.prototype --> null\n\n\t-> 系统内置的原型链\n\t\t[] --> Array.prototype --> Object.prototype --> null\n\t\t/./ --> RegExp.prototype --> Object.prototype --> null \n\t\t... ...\n\n3. 绘制数组的原型结构\n\tvar arr = [];\n\t// 等价\n\tvar arr = new Array();\n\n\tarr --> Array.prototype --> Object.prototype --> null\n\n4. 练习:\n\t根据下面代码绘制对象的原型链结构\n\t1) \tfunction Person( name, age, gender ) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tthis.gender = gender;\n\t\t}\n\t\tfunction Student () {}\n\n\t\tStudent.prototype = new Person( '张三', 19, '男' );\n\n\t\tvar stu = new Student();\n\n\t2)  function Person() {}\n\t\tvar p1 = new Person();\n\t\tvar p2 = new Person();\n\n5. {} 对象的原型链结构\n\t在 js 中 对象 一般都有字面量\n\t\t123, '123'\n\t数组: []\n\t正则表达式对象: /./\n\t函数: function () {}\n\t...\n\n\t对象也有字面量: {}\n\t{} --> Object.prototype --> null\n\n\t注意: {} 与 new Object() 含义相同\n\n\n6. 动态函数 Function\n\t-> 动态函数就是在运行的过程中, 将一段字符串作为代码运行. \n\t\t由于字符串可以随意的拼接. 因此得到动态的执行.\n\t-> 定义动态函数, 并执行\n\t\t-> 使用 Function 构造函数, 创建函数.\n\t\t\tFunction 是一个构造函数. new Function 得到 一个函数\n\t\t-> 语法\n\t\t\tnew Function( arg0, arg1, ..., argN, body )\n\n\t\t\tFunction 的所有的参数, 除了最后一个以外, 都是生成的函数的参数\n\t\t\t最后一个参数是 函数体\n\n7. 函数的相关的一些参数\n\targuments 凡是函数调用, 都会默认含有一个 arguments 对象. 可以将其看做为 \"数组\". 里面存储着调用时\n\t\t传入的所有参数. 可以使用数组的索引访问这些参数.\n\t\t例如: 写一个函数, 在参数中写任意个参数, 最后求其和\n\t\t\tfunction sum () {\n\t\t\t\t// 所有的参数都会存储到 arguments 中\n\t\t\t\tvar sum = 0;\n\t\t\t\tfor ( var i = 0; i < arguments.length; i++ ) {\n\t\t\t\t\tsum += arguments[ i ];\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t案例: \textend( o )  => 将 o 混入到当前对象 this 中\n\t\t\t\textend( o1, o2 ) => 将 o2 混入到 o1 中\n\n\t函数名.length, 即函数的 length 属性. 表示 定义函数时, 参数的个数\n\n\t如果定义函数的时候, 定义了参数. 但是调用的时候又没有传递该参数. 那么该参数在函数内就是 undefined\n\n\t函数.name 返回的是函数名\n\n8. 函数的引用 callee 与 caller\n\tjs 中函数也是一个对象\n\t-> callee 在函数的内部, 它表示 当前函数 的引用\n\t一般在函数内部, 实现函数递归的时候, 我们一般使用 callee 表示函数的引用\n\tfunction fn() {\n\t\targuments.callee();  // 使用 callee 来递归\n\t}\n\tfn();\n\t-> caller 表示调用函数的函数 //caller 就是在被调用函数中, 获得调用函数的引用\n\tfunction f2 () {\n\t\tconsole.log( f2.caller );\n\t}\n\n\tfunction itcast() {\n\t\tf2();\t\n\t}\n\n\titcast();\n\n9. eval 函数\n\teval 函数与 Function 功能类似. eval 可以直接将字符串作为代码来执行.\n\t语法:\n\t\teval( 语句字符串 )\n\t注意, 它好像与当前代码处于同一个作用域\n\teval 直接调用即执行。\n\tFunction 生成了一个函数function 需要调用才执行\n\n10. 使用 ajax 获得 json 格式的字符串后, 转换成对象\n\tvar data = '[ { \"name\": \"张三\", \"age\": 19, \"gender\": \"男\"}, { \"name\": \"李四\", \"age\": 18, \"gender\": \"女\"} ]';\n\t  json 格式( 严格的国际通用数据表示协议, 结构 )\n\t  在 js 中使用的 json 对象, 相对较松散\n\t  json 格式 有两种结构\n\t\t1: {}\n\t\t2: []\n\t\t注意: json 格式中, 键名也必须使用双引号括起来.\n\t\n\t\t 将字符串变成对象, 有三种做法\n\t\t 1. eval 做法\n\tvar o1 = eval( \"(\" + data + \")\" );   // 注意一个习惯. 就是数据两端一般加上圆括号为好\n\n\t\t2. Function 做法\n\tvar o2 = (new Function( 'return ' + data ))();\n\n\t\t3. 使用 ES5 中引入的标准处理 JSON 的语法\n\t\tJSON.parse(  )\n\t\t注意: 字符串必须是严格是 json 格式\n\tvar o3 = JSON.parse( data );\n\n\n\n\n\t\n11. 在 js 中 函数 是 Function 的实例\n\n\tfunction Person() {}\n\tvar p = new Person();\n\tp 是 构造函数 Person 的实例\n\n\t在 该角度去看, 函数就是对象, Function 就是构造函数\n\n\t得到 构造-实例-原型 三角形\n\n\tfunction Person() {} 为例\n\n12. 给定一个任意的对象, 将其原型链包括对象和函数的结构完整的分析处理\n\n13. instanceof 运算符\n\t-> a of b -> b 的 a\n\t-> instance of ?\n\t-> 错觉: 判断某一个对象是否为某一个构造函数所创建出来的\n\n\n14. 通过原型链的学习, 可以重新定义 js 的继承\n\n\tjs 的继承: 就是利用对象的动态特性添加成员, 或直接替换对象的方式修改原型链\n\t\t\t\t结构. 使得当前对象的原型链上的对象具有某些成员. 那么我的当前对象\n\t\t\t\t就可以使用这些成员了.\n\n\tp -> Person.prototype -> Object.prototype -> null\n\tp -> Person.prototype -> {} -> Object.prototype -> null\n\n\t过多的依赖原型链继承, 会损耗 性能\n\t如果必须使用原型链继承, 最好提供一些快速访问的方法\n\n\n\n\n\n\n\n\n\n","slug":"面向对象/面向对象第三天","published":1,"date":"2016-12-21T00:30:10.000Z","updated":"2019-04-26T06:38:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0im002b7xuq4wevfoso","content":"<ol>\n<li><p>复习<br> -&gt; 继承</p>\n<pre><code>原型式继承\n    function Person() {}\n    Person.prototype = 父对象;\n    var p = new Person();\n    p 继承自 父对象\n混入 ( mix, extend )\n    function extend( o1, o2 ) {\n        for ( var k in o2 ) {\n            o1[ k ] = o2[ k ];\n        }\n    }\n注意命名规则: \n    1&gt; 一般 将一个对象混入另一个对象, 使用 mix\n    2&gt; 如果是当前对象的方法. 是将另一个对象混入当前对象一般使用 extend\n</code></pre></li>\n<li><p>对象的原型链<br> -&gt; 凡是对象都有原型<br> -&gt; 构造函数 Person 创建的对象 p 有原型 Person.prototype</p>\n<p> -&gt; Person.prototype 是对象. 它有原型吗?<br> -&gt; 问题: </p>\n<pre><code>1) 原型是什么?\n2) 原型既然是对象, 那么如何是个头?    \n</code></pre><p> -&gt; 结论</p>\n<pre><code>1) Person.prototype 是 实例 p 的原型对象, 使用 __proto__ 可以访问对象的原型对象\n2) Person.prototype 的 原型对象是 Person.prototype.__proto__\n3) Person.prototype.__proto__ 里的 constructor 是 Object. 所以\n    Person.prototype.__proto__ 就是 Object.prototype\n4) Object.prototype.__proto__ 是 null. 因此表明 Object.prototype 就是顶级.\n</code></pre><p> -&gt; 链式</p>\n<pre><code>p --&gt; Person.prototype( p.__proto__ ) --&gt; Object.prototype --&gt; null\n</code></pre><p> -&gt; 系统内置的原型链</p>\n<pre><code>[] --&gt; Array.prototype --&gt; Object.prototype --&gt; null\n/./ --&gt; RegExp.prototype --&gt; Object.prototype --&gt; null \n... ...\n</code></pre></li>\n<li><p>绘制数组的原型结构<br> var arr = [];<br> // 等价<br> var arr = new Array();</p>\n<p> arr –&gt; Array.prototype –&gt; Object.prototype –&gt; null</p>\n</li>\n<li><p>练习:<br> 根据下面代码绘制对象的原型链结构<br> 1)     function Person( name, age, gender ) {</p>\n<pre><code>    this.name = name;\n    this.age = age;\n    this.gender = gender;\n}\nfunction Student () {}\n\nStudent.prototype = new Person( &apos;张三&apos;, 19, &apos;男&apos; );\n\nvar stu = new Student();\n</code></pre><p> 2)  function Person() {}</p>\n<pre><code>var p1 = new Person();\nvar p2 = new Person();\n</code></pre></li>\n<li><p>{} 对象的原型链结构<br> 在 js 中 对象 一般都有字面量</p>\n<pre><code>123, &apos;123&apos;\n</code></pre><p> 数组: []<br> 正则表达式对象: /./<br> 函数: function () {}<br> …</p>\n<p> 对象也有字面量: {}<br> {} –&gt; Object.prototype –&gt; null</p>\n<p> 注意: {} 与 new Object() 含义相同</p>\n</li>\n</ol>\n<ol>\n<li><p>动态函数 Function<br> -&gt; 动态函数就是在运行的过程中, 将一段字符串作为代码运行. </p>\n<pre><code>由于字符串可以随意的拼接. 因此得到动态的执行.\n</code></pre><p> -&gt; 定义动态函数, 并执行</p>\n<pre><code>-&gt; 使用 Function 构造函数, 创建函数.\n    Function 是一个构造函数. new Function 得到 一个函数\n-&gt; 语法\n    new Function( arg0, arg1, ..., argN, body )\n\n    Function 的所有的参数, 除了最后一个以外, 都是生成的函数的参数\n    最后一个参数是 函数体\n</code></pre></li>\n<li><p>函数的相关的一些参数<br> arguments 凡是函数调用, 都会默认含有一个 arguments 对象. 可以将其看做为 “数组”. 里面存储着调用时</p>\n<pre><code>传入的所有参数. 可以使用数组的索引访问这些参数.\n例如: 写一个函数, 在参数中写任意个参数, 最后求其和\n    function sum () {\n        // 所有的参数都会存储到 arguments 中\n        var sum = 0;\n        for ( var i = 0; i &lt; arguments.length; i++ ) {\n            sum += arguments[ i ];\n        }\n        return sum;\n    }\n\n案例:     extend( o )  =&gt; 将 o 混入到当前对象 this 中\n        extend( o1, o2 ) =&gt; 将 o2 混入到 o1 中\n</code></pre><p> 函数名.length, 即函数的 length 属性. 表示 定义函数时, 参数的个数</p>\n<p> 如果定义函数的时候, 定义了参数. 但是调用的时候又没有传递该参数. 那么该参数在函数内就是 undefined</p>\n<p> 函数.name 返回的是函数名</p>\n</li>\n<li><p>函数的引用 callee 与 caller<br> js 中函数也是一个对象<br> -&gt; callee 在函数的内部, 它表示 当前函数 的引用<br> 一般在函数内部, 实现函数递归的时候, 我们一般使用 callee 表示函数的引用<br> function fn() {</p>\n<pre><code>arguments.callee();  // 使用 callee 来递归\n</code></pre><p> }<br> fn();<br> -&gt; caller 表示调用函数的函数 //caller 就是在被调用函数中, 获得调用函数的引用<br> function f2 () {</p>\n<pre><code>console.log( f2.caller );\n</code></pre><p> }</p>\n<p> function itcast() {</p>\n<pre><code>f2();    \n</code></pre><p> }</p>\n<p> itcast();</p>\n</li>\n<li><p>eval 函数<br> eval 函数与 Function 功能类似. eval 可以直接将字符串作为代码来执行.<br> 语法:</p>\n<pre><code>eval( 语句字符串 )\n</code></pre><p> 注意, 它好像与当前代码处于同一个作用域<br> eval 直接调用即执行。<br> Function 生成了一个函数function 需要调用才执行</p>\n</li>\n<li><p>使用 ajax 获得 json 格式的字符串后, 转换成对象<br>var data = ‘[ { “name”: “张三”, “age”: 19, “gender”: “男”}, { “name”: “李四”, “age”: 18, “gender”: “女”} ]’;<br>  json 格式( 严格的国际通用数据表示协议, 结构 )<br>  在 js 中使用的 json 对象, 相对较松散<br>  json 格式 有两种结构</p>\n<pre><code>1: {}\n2: []\n注意: json 格式中, 键名也必须使用双引号括起来.\n\n 将字符串变成对象, 有三种做法\n 1. eval 做法\n</code></pre><p>var o1 = eval( “(“ + data + “)” );   // 注意一个习惯. 就是数据两端一般加上圆括号为好</p>\n<pre><code>2. Function 做法\n</code></pre><p>var o2 = (new Function( ‘return ‘ + data ))();</p>\n<pre><code>3. 使用 ES5 中引入的标准处理 JSON 的语法\nJSON.parse(  )\n注意: 字符串必须是严格是 json 格式\n</code></pre><p>var o3 = JSON.parse( data );</p>\n</li>\n</ol>\n<ol>\n<li><p>在 js 中 函数 是 Function 的实例</p>\n<p>function Person() {}<br>var p = new Person();<br>p 是 构造函数 Person 的实例</p>\n<p>在 该角度去看, 函数就是对象, Function 就是构造函数</p>\n<p>得到 构造-实例-原型 三角形</p>\n<p>function Person() {} 为例</p>\n</li>\n<li><p>给定一个任意的对象, 将其原型链包括对象和函数的结构完整的分析处理</p>\n</li>\n<li><p>instanceof 运算符<br>-&gt; a of b -&gt; b 的 a<br>-&gt; instance of ?<br>-&gt; 错觉: 判断某一个对象是否为某一个构造函数所创建出来的</p>\n</li>\n</ol>\n<ol>\n<li><p>通过原型链的学习, 可以重新定义 js 的继承</p>\n<p>js 的继承: 就是利用对象的动态特性添加成员, 或直接替换对象的方式修改原型链</p>\n<pre><code>结构. 使得当前对象的原型链上的对象具有某些成员. 那么我的当前对象\n就可以使用这些成员了.\n</code></pre><p>p -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br>p -&gt; Person.prototype -&gt; {} -&gt; Object.prototype -&gt; null</p>\n<p>过多的依赖原型链继承, 会损耗 性能<br>如果必须使用原型链继承, 最好提供一些快速访问的方法</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>复习<br> -&gt; 继承</p>\n<pre><code>原型式继承\n    function Person() {}\n    Person.prototype = 父对象;\n    var p = new Person();\n    p 继承自 父对象\n混入 ( mix, extend )\n    function extend( o1, o2 ) {\n        for ( var k in o2 ) {\n            o1[ k ] = o2[ k ];\n        }\n    }\n注意命名规则: \n    1&gt; 一般 将一个对象混入另一个对象, 使用 mix\n    2&gt; 如果是当前对象的方法. 是将另一个对象混入当前对象一般使用 extend\n</code></pre></li>\n<li><p>对象的原型链<br> -&gt; 凡是对象都有原型<br> -&gt; 构造函数 Person 创建的对象 p 有原型 Person.prototype</p>\n<p> -&gt; Person.prototype 是对象. 它有原型吗?<br> -&gt; 问题: </p>\n<pre><code>1) 原型是什么?\n2) 原型既然是对象, 那么如何是个头?    \n</code></pre><p> -&gt; 结论</p>\n<pre><code>1) Person.prototype 是 实例 p 的原型对象, 使用 __proto__ 可以访问对象的原型对象\n2) Person.prototype 的 原型对象是 Person.prototype.__proto__\n3) Person.prototype.__proto__ 里的 constructor 是 Object. 所以\n    Person.prototype.__proto__ 就是 Object.prototype\n4) Object.prototype.__proto__ 是 null. 因此表明 Object.prototype 就是顶级.\n</code></pre><p> -&gt; 链式</p>\n<pre><code>p --&gt; Person.prototype( p.__proto__ ) --&gt; Object.prototype --&gt; null\n</code></pre><p> -&gt; 系统内置的原型链</p>\n<pre><code>[] --&gt; Array.prototype --&gt; Object.prototype --&gt; null\n/./ --&gt; RegExp.prototype --&gt; Object.prototype --&gt; null \n... ...\n</code></pre></li>\n<li><p>绘制数组的原型结构<br> var arr = [];<br> // 等价<br> var arr = new Array();</p>\n<p> arr –&gt; Array.prototype –&gt; Object.prototype –&gt; null</p>\n</li>\n<li><p>练习:<br> 根据下面代码绘制对象的原型链结构<br> 1)     function Person( name, age, gender ) {</p>\n<pre><code>    this.name = name;\n    this.age = age;\n    this.gender = gender;\n}\nfunction Student () {}\n\nStudent.prototype = new Person( &apos;张三&apos;, 19, &apos;男&apos; );\n\nvar stu = new Student();\n</code></pre><p> 2)  function Person() {}</p>\n<pre><code>var p1 = new Person();\nvar p2 = new Person();\n</code></pre></li>\n<li><p>{} 对象的原型链结构<br> 在 js 中 对象 一般都有字面量</p>\n<pre><code>123, &apos;123&apos;\n</code></pre><p> 数组: []<br> 正则表达式对象: /./<br> 函数: function () {}<br> …</p>\n<p> 对象也有字面量: {}<br> {} –&gt; Object.prototype –&gt; null</p>\n<p> 注意: {} 与 new Object() 含义相同</p>\n</li>\n</ol>\n<ol>\n<li><p>动态函数 Function<br> -&gt; 动态函数就是在运行的过程中, 将一段字符串作为代码运行. </p>\n<pre><code>由于字符串可以随意的拼接. 因此得到动态的执行.\n</code></pre><p> -&gt; 定义动态函数, 并执行</p>\n<pre><code>-&gt; 使用 Function 构造函数, 创建函数.\n    Function 是一个构造函数. new Function 得到 一个函数\n-&gt; 语法\n    new Function( arg0, arg1, ..., argN, body )\n\n    Function 的所有的参数, 除了最后一个以外, 都是生成的函数的参数\n    最后一个参数是 函数体\n</code></pre></li>\n<li><p>函数的相关的一些参数<br> arguments 凡是函数调用, 都会默认含有一个 arguments 对象. 可以将其看做为 “数组”. 里面存储着调用时</p>\n<pre><code>传入的所有参数. 可以使用数组的索引访问这些参数.\n例如: 写一个函数, 在参数中写任意个参数, 最后求其和\n    function sum () {\n        // 所有的参数都会存储到 arguments 中\n        var sum = 0;\n        for ( var i = 0; i &lt; arguments.length; i++ ) {\n            sum += arguments[ i ];\n        }\n        return sum;\n    }\n\n案例:     extend( o )  =&gt; 将 o 混入到当前对象 this 中\n        extend( o1, o2 ) =&gt; 将 o2 混入到 o1 中\n</code></pre><p> 函数名.length, 即函数的 length 属性. 表示 定义函数时, 参数的个数</p>\n<p> 如果定义函数的时候, 定义了参数. 但是调用的时候又没有传递该参数. 那么该参数在函数内就是 undefined</p>\n<p> 函数.name 返回的是函数名</p>\n</li>\n<li><p>函数的引用 callee 与 caller<br> js 中函数也是一个对象<br> -&gt; callee 在函数的内部, 它表示 当前函数 的引用<br> 一般在函数内部, 实现函数递归的时候, 我们一般使用 callee 表示函数的引用<br> function fn() {</p>\n<pre><code>arguments.callee();  // 使用 callee 来递归\n</code></pre><p> }<br> fn();<br> -&gt; caller 表示调用函数的函数 //caller 就是在被调用函数中, 获得调用函数的引用<br> function f2 () {</p>\n<pre><code>console.log( f2.caller );\n</code></pre><p> }</p>\n<p> function itcast() {</p>\n<pre><code>f2();    \n</code></pre><p> }</p>\n<p> itcast();</p>\n</li>\n<li><p>eval 函数<br> eval 函数与 Function 功能类似. eval 可以直接将字符串作为代码来执行.<br> 语法:</p>\n<pre><code>eval( 语句字符串 )\n</code></pre><p> 注意, 它好像与当前代码处于同一个作用域<br> eval 直接调用即执行。<br> Function 生成了一个函数function 需要调用才执行</p>\n</li>\n<li><p>使用 ajax 获得 json 格式的字符串后, 转换成对象<br>var data = ‘[ { “name”: “张三”, “age”: 19, “gender”: “男”}, { “name”: “李四”, “age”: 18, “gender”: “女”} ]’;<br>  json 格式( 严格的国际通用数据表示协议, 结构 )<br>  在 js 中使用的 json 对象, 相对较松散<br>  json 格式 有两种结构</p>\n<pre><code>1: {}\n2: []\n注意: json 格式中, 键名也必须使用双引号括起来.\n\n 将字符串变成对象, 有三种做法\n 1. eval 做法\n</code></pre><p>var o1 = eval( “(“ + data + “)” );   // 注意一个习惯. 就是数据两端一般加上圆括号为好</p>\n<pre><code>2. Function 做法\n</code></pre><p>var o2 = (new Function( ‘return ‘ + data ))();</p>\n<pre><code>3. 使用 ES5 中引入的标准处理 JSON 的语法\nJSON.parse(  )\n注意: 字符串必须是严格是 json 格式\n</code></pre><p>var o3 = JSON.parse( data );</p>\n</li>\n</ol>\n<ol>\n<li><p>在 js 中 函数 是 Function 的实例</p>\n<p>function Person() {}<br>var p = new Person();<br>p 是 构造函数 Person 的实例</p>\n<p>在 该角度去看, 函数就是对象, Function 就是构造函数</p>\n<p>得到 构造-实例-原型 三角形</p>\n<p>function Person() {} 为例</p>\n</li>\n<li><p>给定一个任意的对象, 将其原型链包括对象和函数的结构完整的分析处理</p>\n</li>\n<li><p>instanceof 运算符<br>-&gt; a of b -&gt; b 的 a<br>-&gt; instance of ?<br>-&gt; 错觉: 判断某一个对象是否为某一个构造函数所创建出来的</p>\n</li>\n</ol>\n<ol>\n<li><p>通过原型链的学习, 可以重新定义 js 的继承</p>\n<p>js 的继承: 就是利用对象的动态特性添加成员, 或直接替换对象的方式修改原型链</p>\n<pre><code>结构. 使得当前对象的原型链上的对象具有某些成员. 那么我的当前对象\n就可以使用这些成员了.\n</code></pre><p>p -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br>p -&gt; Person.prototype -&gt; {} -&gt; Object.prototype -&gt; null</p>\n<p>过多的依赖原型链继承, 会损耗 性能<br>如果必须使用原型链继承, 最好提供一些快速访问的方法</p>\n</li>\n</ol>\n"},{"title":"javascript 面向对象：5","_content":"1. 复习\n\tvar num = 123;\n\tfunction num () {\n\t\tconsole.log( \"Hello\" );\n\t}\n\tconsole.log( num );\n\n2. 递归的概念\n\t-> 递归就是直接或间接的调用自己\n\t\t-> 直接调用\n\t\t\tfunction func() {\n\t\t\t\t// ...\n\t\t\t\tconsole.log( 123 );\n\t\t\t\t\n\t\t\t\tfunc(); // 递归了\n\t\t\t\t// ...\n\t\t\t}\n\t\t-> 间接调用\n\t\t\tfunction func1 () {\n\t\t\t\tfunc2();\n\t\t\t}\n\t\t\tfunction func2 () {\n\t\t\t\tfunc1();\n\t\t\t}\n\t-> 就以直接调用为例. 分析特点.\n\t\t将函数调用想象成做一件事儿. 函数调用, 就是在做事儿. \n\t\t递归, 就是函数在调用的时候, 转而去调用自己.\n\n\t\t就是要完成 xxx1, 就完成 xxx2\n\t\t\t  完成 xxx2, 就完成 xxx3\n\t\t\t  完成 xxx3, 就完成 xxx4\n\t\t\t  ... ...\n\n\t\t其实就是将要做某件事儿, 转换成已经解决的问题. 然后根据逻辑关系找到临界条件( 已经解决的问题 )\n\n\t-> 求 n 的阶乘\n\t\tn 的阶乘 记为 n!, 表示 从 1 一直累乘到 n. 比如 3! == 1 * 2 * 3, 5! == 1 * 2 * 3 * 4 * 5\n\n3. 利用递归实现深拷贝\n\t-> 深拷贝\n\t\t-> 拷贝: 复制\n\t\t\tvar o = { name: 'itcast' };\n\t\t\tvar o1 = o;\n\t\t\t// 拷贝\n\t\t\tvar o2 = {};\n\t\t\to2.name = o.name;\n\n\t\t\tclone: for-in 遍历对象, 然后将一个对象成员加到 {} 上, 返回\n\t\t-> 代码\n\t\t\tfunction clone ( obj ) {\n\t\t\t\t// 将 目标对象 拷贝一份\n\t\t\t\tvar src = {},\n\t\t\t\t\tk;\n\t\t\t\tfor ( k in obj ) {\n\t\t\t\t\tsrc[ k ] = obj[ k ];\n\t\t\t\t}\n\t\t\t\treturn src;\n\t\t\t}\n\n4. document.getElementsByClassName \n\t使用递归实现该方法\n\n\tget*By*Name( '*' )\n\n\t父子节点的关系去完成\n\n\tbody下找所有的子元素, 凡是有 className 等于 给定值 的就取出来\n\t但是 标签还有子标签, 利用递归处理子标签\n\n\n5. 闭包应用\n\t-> 闭包的概念\n\t-> 闭包代码的基本结构\n\t\tfunction foo () {\n\t\t\tvar num = 123;\n\t\t\treturn function () {\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}\n\t-> 如果函数中定义了两个变量, 外界如何访问\n\t\tfunction foo () {\n\t\t\tvar num1 = 123, \n\t\t\t\tnum2 = 456;\n\t\t\t// 怎样让外界既可以访问 num1 又可以访问 num2\n\t\t\treturn [\n\t\t\t\tfunction () {\n\t\t\t\t\treturn num1;\n\t\t\t\t},\n\t\t\t\tfunction () {\n\t\t\t\t\treturn num2;\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t-> 闭包实现各种特性, 其根本的核心内容只有两个\n\t\t1> 带有私有数据的函数\n\t\t\tfunction foo () {\n\t\t\t\tvar num = 123;\n\t\t\t\treturn function () {\n\t\t\t\t\t// 可以访问 num\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar func = foo();\n\t\t\t// 称 func 是一个 带有私有数据的 函数\n\t\t\t// 称 func 带有缓存\n\t\t2> 带有私有数据的 对象\n\n6. 闭包的应用__沙箱模式\n\t沙箱就是一个隔离的执行环境\n\n\t在 js 中什么情况需要使用沙箱\n\n\tfunction Person () {  ... }\n\tvar p = Person. ...\n\tPerson.prototype = ....\n\t...\n\n\t定义变量越多, 会怎样? 出现冲突的可能性越大.\n\n\t(function () {} )();\n\n\tvar f = function () {};\n\tf();\n\n\t同理, 在 代码中 有时为了使得代码更加简洁, 会引入很多变量\n\n\t(function () {\n\t\t// 沙箱模式\n\n\t\t// 所有的代码写在这里\n\n\n\t})();\n\n\n7. 闭包的应用__简化递归函数的性能问题\n\n8. 闭包的应用__模拟 onload 事件的追加与移除\n\n\to.addEvent( function ... )\n\to.removeEvent( fn )\n\n\t系统 调用 load()  按照一定顺序执行\n\n\t所以, 我们需要有一个对象, 有两个方法, 用来追加移除事件, 需要一个私有数组存储函数\n\n\tvar itcastload = (function () {\n\n\t\t// 私有数据\n\n\t\treturn {\n\n\t\t};\n\t\t\n\t})();\n\n\n9. 利用闭包模拟一个缓存结构\n\tcache 对象, 可以使用 cache[ key ] = value 存储数据, cache[ key ] 获得数据\n\t当 cahche 里面的数据达到 1024 条, 将最早放进去的数据移除\n\n\tcache = {} 可以存取数据, 但是不能限定数据的长度\n\n\t如果需要限定数据, 就是在加入数据的时候 判读, 是否已超过尺寸. \n\t如果是, 则移除, 如果不是, 则什么也不做\n\n\t将 cache 做成函数, 添加数据使用 cache( key, value )\n\t而且函数本身也是对象\n\n\tfunction cache ( key, value ) {\n\n\t\t// 可以在这里加上限定长度的代码\n\n\t\tcache[ key ] = value;\n\t}\n\n\t由于需要记录键的数量. 并且需要记录添加数据的先后顺序. 所有首先考虑有序的数组.\n\t因此需要让 cache 函数带有缓存功能\n\n\tvar cache = (function () {\n\t\tvar data = [];\n\n\t\tfunction cache ( key, value ) {\n\n\t\t\t// 做判断, 如果超出范围, 则, 将最开始加入的 移除 \n\t\t\t// 将数组 第 0 项元素移除的 splice, shift\n\n\t\t\tcache[ key ] = value;\n\t\t}\n\t\treturn cache;\n\t})();\n\n10.函数是基本的对象类型，可以作为变量赋值，可以作为参数使用，也可以作为返回值使用。\n\n11. 闭包应用 带有事件（移除与追加）的对象\n\t \n11.1定义一个自调用函数 (function(){})()\n把所有方法放在 data = []\n 并在window.onload = function(){};加载完就执行。\n添加事件 return{addEvent:function(fn){\n\tdata.push(fn)\n},removeEvent:function(fn){\t\n\t// 倒过来循环\n\t\t\t\tfor ( var i = data.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tif ( data[ i ] === fn ) {\n\t\t\t\t\t\tdata.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n这里注意在   1，删除的遍历时要倒着遍历 因为数组的长度在发生改变\n\t\t\t2，在使用删除的时候需要把事件提出来 是一个变量储存 才可以实现删除\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象/面向对象第五天.md","raw":"---\ntitle: javascript 面向对象：5\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1. 复习\n\tvar num = 123;\n\tfunction num () {\n\t\tconsole.log( \"Hello\" );\n\t}\n\tconsole.log( num );\n\n2. 递归的概念\n\t-> 递归就是直接或间接的调用自己\n\t\t-> 直接调用\n\t\t\tfunction func() {\n\t\t\t\t// ...\n\t\t\t\tconsole.log( 123 );\n\t\t\t\t\n\t\t\t\tfunc(); // 递归了\n\t\t\t\t// ...\n\t\t\t}\n\t\t-> 间接调用\n\t\t\tfunction func1 () {\n\t\t\t\tfunc2();\n\t\t\t}\n\t\t\tfunction func2 () {\n\t\t\t\tfunc1();\n\t\t\t}\n\t-> 就以直接调用为例. 分析特点.\n\t\t将函数调用想象成做一件事儿. 函数调用, 就是在做事儿. \n\t\t递归, 就是函数在调用的时候, 转而去调用自己.\n\n\t\t就是要完成 xxx1, 就完成 xxx2\n\t\t\t  完成 xxx2, 就完成 xxx3\n\t\t\t  完成 xxx3, 就完成 xxx4\n\t\t\t  ... ...\n\n\t\t其实就是将要做某件事儿, 转换成已经解决的问题. 然后根据逻辑关系找到临界条件( 已经解决的问题 )\n\n\t-> 求 n 的阶乘\n\t\tn 的阶乘 记为 n!, 表示 从 1 一直累乘到 n. 比如 3! == 1 * 2 * 3, 5! == 1 * 2 * 3 * 4 * 5\n\n3. 利用递归实现深拷贝\n\t-> 深拷贝\n\t\t-> 拷贝: 复制\n\t\t\tvar o = { name: 'itcast' };\n\t\t\tvar o1 = o;\n\t\t\t// 拷贝\n\t\t\tvar o2 = {};\n\t\t\to2.name = o.name;\n\n\t\t\tclone: for-in 遍历对象, 然后将一个对象成员加到 {} 上, 返回\n\t\t-> 代码\n\t\t\tfunction clone ( obj ) {\n\t\t\t\t// 将 目标对象 拷贝一份\n\t\t\t\tvar src = {},\n\t\t\t\t\tk;\n\t\t\t\tfor ( k in obj ) {\n\t\t\t\t\tsrc[ k ] = obj[ k ];\n\t\t\t\t}\n\t\t\t\treturn src;\n\t\t\t}\n\n4. document.getElementsByClassName \n\t使用递归实现该方法\n\n\tget*By*Name( '*' )\n\n\t父子节点的关系去完成\n\n\tbody下找所有的子元素, 凡是有 className 等于 给定值 的就取出来\n\t但是 标签还有子标签, 利用递归处理子标签\n\n\n5. 闭包应用\n\t-> 闭包的概念\n\t-> 闭包代码的基本结构\n\t\tfunction foo () {\n\t\t\tvar num = 123;\n\t\t\treturn function () {\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}\n\t-> 如果函数中定义了两个变量, 外界如何访问\n\t\tfunction foo () {\n\t\t\tvar num1 = 123, \n\t\t\t\tnum2 = 456;\n\t\t\t// 怎样让外界既可以访问 num1 又可以访问 num2\n\t\t\treturn [\n\t\t\t\tfunction () {\n\t\t\t\t\treturn num1;\n\t\t\t\t},\n\t\t\t\tfunction () {\n\t\t\t\t\treturn num2;\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t-> 闭包实现各种特性, 其根本的核心内容只有两个\n\t\t1> 带有私有数据的函数\n\t\t\tfunction foo () {\n\t\t\t\tvar num = 123;\n\t\t\t\treturn function () {\n\t\t\t\t\t// 可以访问 num\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar func = foo();\n\t\t\t// 称 func 是一个 带有私有数据的 函数\n\t\t\t// 称 func 带有缓存\n\t\t2> 带有私有数据的 对象\n\n6. 闭包的应用__沙箱模式\n\t沙箱就是一个隔离的执行环境\n\n\t在 js 中什么情况需要使用沙箱\n\n\tfunction Person () {  ... }\n\tvar p = Person. ...\n\tPerson.prototype = ....\n\t...\n\n\t定义变量越多, 会怎样? 出现冲突的可能性越大.\n\n\t(function () {} )();\n\n\tvar f = function () {};\n\tf();\n\n\t同理, 在 代码中 有时为了使得代码更加简洁, 会引入很多变量\n\n\t(function () {\n\t\t// 沙箱模式\n\n\t\t// 所有的代码写在这里\n\n\n\t})();\n\n\n7. 闭包的应用__简化递归函数的性能问题\n\n8. 闭包的应用__模拟 onload 事件的追加与移除\n\n\to.addEvent( function ... )\n\to.removeEvent( fn )\n\n\t系统 调用 load()  按照一定顺序执行\n\n\t所以, 我们需要有一个对象, 有两个方法, 用来追加移除事件, 需要一个私有数组存储函数\n\n\tvar itcastload = (function () {\n\n\t\t// 私有数据\n\n\t\treturn {\n\n\t\t};\n\t\t\n\t})();\n\n\n9. 利用闭包模拟一个缓存结构\n\tcache 对象, 可以使用 cache[ key ] = value 存储数据, cache[ key ] 获得数据\n\t当 cahche 里面的数据达到 1024 条, 将最早放进去的数据移除\n\n\tcache = {} 可以存取数据, 但是不能限定数据的长度\n\n\t如果需要限定数据, 就是在加入数据的时候 判读, 是否已超过尺寸. \n\t如果是, 则移除, 如果不是, 则什么也不做\n\n\t将 cache 做成函数, 添加数据使用 cache( key, value )\n\t而且函数本身也是对象\n\n\tfunction cache ( key, value ) {\n\n\t\t// 可以在这里加上限定长度的代码\n\n\t\tcache[ key ] = value;\n\t}\n\n\t由于需要记录键的数量. 并且需要记录添加数据的先后顺序. 所有首先考虑有序的数组.\n\t因此需要让 cache 函数带有缓存功能\n\n\tvar cache = (function () {\n\t\tvar data = [];\n\n\t\tfunction cache ( key, value ) {\n\n\t\t\t// 做判断, 如果超出范围, 则, 将最开始加入的 移除 \n\t\t\t// 将数组 第 0 项元素移除的 splice, shift\n\n\t\t\tcache[ key ] = value;\n\t\t}\n\t\treturn cache;\n\t})();\n\n10.函数是基本的对象类型，可以作为变量赋值，可以作为参数使用，也可以作为返回值使用。\n\n11. 闭包应用 带有事件（移除与追加）的对象\n\t \n11.1定义一个自调用函数 (function(){})()\n把所有方法放在 data = []\n 并在window.onload = function(){};加载完就执行。\n添加事件 return{addEvent:function(fn){\n\tdata.push(fn)\n},removeEvent:function(fn){\t\n\t// 倒过来循环\n\t\t\t\tfor ( var i = data.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tif ( data[ i ] === fn ) {\n\t\t\t\t\t\tdata.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n这里注意在   1，删除的遍历时要倒着遍历 因为数组的长度在发生改变\n\t\t\t2，在使用删除的时候需要把事件提出来 是一个变量储存 才可以实现删除\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面向对象/面向对象第五天","published":1,"date":"2016-12-23T13:23:31.000Z","updated":"2019-04-26T06:38:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0io002e7xuqknjqy56n","content":"<ol>\n<li><p>复习<br> var num = 123;<br> function num () {</p>\n<pre><code>console.log( &quot;Hello&quot; );\n</code></pre><p> }<br> console.log( num );</p>\n</li>\n<li><p>递归的概念<br> -&gt; 递归就是直接或间接的调用自己</p>\n<pre><code>-&gt; 直接调用\n    function func() {\n        // ...\n        console.log( 123 );\n\n        func(); // 递归了\n        // ...\n    }\n-&gt; 间接调用\n    function func1 () {\n        func2();\n    }\n    function func2 () {\n        func1();\n    }\n</code></pre><p> -&gt; 就以直接调用为例. 分析特点.</p>\n<pre><code>将函数调用想象成做一件事儿. 函数调用, 就是在做事儿. \n递归, 就是函数在调用的时候, 转而去调用自己.\n\n就是要完成 xxx1, 就完成 xxx2\n      完成 xxx2, 就完成 xxx3\n      完成 xxx3, 就完成 xxx4\n      ... ...\n\n其实就是将要做某件事儿, 转换成已经解决的问题. 然后根据逻辑关系找到临界条件( 已经解决的问题 )\n</code></pre><p> -&gt; 求 n 的阶乘</p>\n<pre><code>n 的阶乘 记为 n!, 表示 从 1 一直累乘到 n. 比如 3! == 1 * 2 * 3, 5! == 1 * 2 * 3 * 4 * 5\n</code></pre></li>\n<li><p>利用递归实现深拷贝<br> -&gt; 深拷贝</p>\n<pre><code>-&gt; 拷贝: 复制\n    var o = { name: &apos;itcast&apos; };\n    var o1 = o;\n    // 拷贝\n    var o2 = {};\n    o2.name = o.name;\n\n    clone: for-in 遍历对象, 然后将一个对象成员加到 {} 上, 返回\n-&gt; 代码\n    function clone ( obj ) {\n        // 将 目标对象 拷贝一份\n        var src = {},\n            k;\n        for ( k in obj ) {\n            src[ k ] = obj[ k ];\n        }\n        return src;\n    }\n</code></pre></li>\n<li><p>document.getElementsByClassName<br> 使用递归实现该方法</p>\n<p> get<em>By</em>Name( ‘*’ )</p>\n<p> 父子节点的关系去完成</p>\n<p> body下找所有的子元素, 凡是有 className 等于 给定值 的就取出来<br> 但是 标签还有子标签, 利用递归处理子标签</p>\n</li>\n</ol>\n<ol>\n<li><p>闭包应用<br> -&gt; 闭包的概念<br> -&gt; 闭包代码的基本结构</p>\n<pre><code>function foo () {\n    var num = 123;\n    return function () {\n        return num;\n    }\n}\n</code></pre><p> -&gt; 如果函数中定义了两个变量, 外界如何访问</p>\n<pre><code>function foo () {\n    var num1 = 123, \n        num2 = 456;\n    // 怎样让外界既可以访问 num1 又可以访问 num2\n    return [\n        function () {\n            return num1;\n        },\n        function () {\n            return num2;\n        }\n    ];\n}\n</code></pre><p> -&gt; 闭包实现各种特性, 其根本的核心内容只有两个</p>\n<pre><code>1&gt; 带有私有数据的函数\n    function foo () {\n        var num = 123;\n        return function () {\n            // 可以访问 num\n        }\n    }\n    var func = foo();\n    // 称 func 是一个 带有私有数据的 函数\n    // 称 func 带有缓存\n2&gt; 带有私有数据的 对象\n</code></pre></li>\n<li><p>闭包的应用__沙箱模式<br> 沙箱就是一个隔离的执行环境</p>\n<p> 在 js 中什么情况需要使用沙箱</p>\n<p> function Person () {  … }<br> var p = Person. …<br> Person.prototype = ….<br> …</p>\n<p> 定义变量越多, 会怎样? 出现冲突的可能性越大.</p>\n<p> (function () {} )();</p>\n<p> var f = function () {};<br> f();</p>\n<p> 同理, 在 代码中 有时为了使得代码更加简洁, 会引入很多变量</p>\n<p> (function () {</p>\n<pre><code>// 沙箱模式\n\n// 所有的代码写在这里\n</code></pre></li>\n</ol>\n<pre><code>})();\n</code></pre><ol>\n<li><p>闭包的应用__简化递归函数的性能问题</p>\n</li>\n<li><p>闭包的应用__模拟 onload 事件的追加与移除</p>\n<p> o.addEvent( function … )<br> o.removeEvent( fn )</p>\n<p> 系统 调用 load()  按照一定顺序执行</p>\n<p> 所以, 我们需要有一个对象, 有两个方法, 用来追加移除事件, 需要一个私有数组存储函数</p>\n<p> var itcastload = (function () {</p>\n<pre><code>// 私有数据\n\nreturn {\n\n};\n</code></pre><p> })();</p>\n</li>\n</ol>\n<ol>\n<li><p>利用闭包模拟一个缓存结构<br> cache 对象, 可以使用 cache[ key ] = value 存储数据, cache[ key ] 获得数据<br> 当 cahche 里面的数据达到 1024 条, 将最早放进去的数据移除</p>\n<p> cache = {} 可以存取数据, 但是不能限定数据的长度</p>\n<p> 如果需要限定数据, 就是在加入数据的时候 判读, 是否已超过尺寸.<br> 如果是, 则移除, 如果不是, 则什么也不做</p>\n<p> 将 cache 做成函数, 添加数据使用 cache( key, value )<br> 而且函数本身也是对象</p>\n<p> function cache ( key, value ) {</p>\n<pre><code>// 可以在这里加上限定长度的代码\n\ncache[ key ] = value;\n</code></pre><p> }</p>\n<p> 由于需要记录键的数量. 并且需要记录添加数据的先后顺序. 所有首先考虑有序的数组.<br> 因此需要让 cache 函数带有缓存功能</p>\n<p> var cache = (function () {</p>\n<pre><code>var data = [];\n\nfunction cache ( key, value ) {\n\n    // 做判断, 如果超出范围, 则, 将最开始加入的 移除 \n    // 将数组 第 0 项元素移除的 splice, shift\n\n    cache[ key ] = value;\n}\nreturn cache;\n</code></pre><p> })();</p>\n</li>\n</ol>\n<p>10.函数是基本的对象类型，可以作为变量赋值，可以作为参数使用，也可以作为返回值使用。</p>\n<ol>\n<li>闭包应用 带有事件（移除与追加）的对象</li>\n</ol>\n<p>11.1定义一个自调用函数 (function(){})()<br>把所有方法放在 data = []<br> 并在window.onload = function(){};加载完就执行。<br>添加事件 return{addEvent:function(fn){<br>    data.push(fn)<br>},removeEvent:function(fn){<br>    // 倒过来循环<br>                for ( var i = data.length - 1; i &gt;= 0; i– ) {<br>                    if ( data[ i ] === fn ) {<br>                        data.splice( i, 1 );<br>                    }<br>                }<br>            }<br>        }<br>这里注意在   1，删除的遍历时要倒着遍历 因为数组的长度在发生改变<br>            2，在使用删除的时候需要把事件提出来 是一个变量储存 才可以实现删除</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>复习<br> var num = 123;<br> function num () {</p>\n<pre><code>console.log( &quot;Hello&quot; );\n</code></pre><p> }<br> console.log( num );</p>\n</li>\n<li><p>递归的概念<br> -&gt; 递归就是直接或间接的调用自己</p>\n<pre><code>-&gt; 直接调用\n    function func() {\n        // ...\n        console.log( 123 );\n\n        func(); // 递归了\n        // ...\n    }\n-&gt; 间接调用\n    function func1 () {\n        func2();\n    }\n    function func2 () {\n        func1();\n    }\n</code></pre><p> -&gt; 就以直接调用为例. 分析特点.</p>\n<pre><code>将函数调用想象成做一件事儿. 函数调用, 就是在做事儿. \n递归, 就是函数在调用的时候, 转而去调用自己.\n\n就是要完成 xxx1, 就完成 xxx2\n      完成 xxx2, 就完成 xxx3\n      完成 xxx3, 就完成 xxx4\n      ... ...\n\n其实就是将要做某件事儿, 转换成已经解决的问题. 然后根据逻辑关系找到临界条件( 已经解决的问题 )\n</code></pre><p> -&gt; 求 n 的阶乘</p>\n<pre><code>n 的阶乘 记为 n!, 表示 从 1 一直累乘到 n. 比如 3! == 1 * 2 * 3, 5! == 1 * 2 * 3 * 4 * 5\n</code></pre></li>\n<li><p>利用递归实现深拷贝<br> -&gt; 深拷贝</p>\n<pre><code>-&gt; 拷贝: 复制\n    var o = { name: &apos;itcast&apos; };\n    var o1 = o;\n    // 拷贝\n    var o2 = {};\n    o2.name = o.name;\n\n    clone: for-in 遍历对象, 然后将一个对象成员加到 {} 上, 返回\n-&gt; 代码\n    function clone ( obj ) {\n        // 将 目标对象 拷贝一份\n        var src = {},\n            k;\n        for ( k in obj ) {\n            src[ k ] = obj[ k ];\n        }\n        return src;\n    }\n</code></pre></li>\n<li><p>document.getElementsByClassName<br> 使用递归实现该方法</p>\n<p> get<em>By</em>Name( ‘*’ )</p>\n<p> 父子节点的关系去完成</p>\n<p> body下找所有的子元素, 凡是有 className 等于 给定值 的就取出来<br> 但是 标签还有子标签, 利用递归处理子标签</p>\n</li>\n</ol>\n<ol>\n<li><p>闭包应用<br> -&gt; 闭包的概念<br> -&gt; 闭包代码的基本结构</p>\n<pre><code>function foo () {\n    var num = 123;\n    return function () {\n        return num;\n    }\n}\n</code></pre><p> -&gt; 如果函数中定义了两个变量, 外界如何访问</p>\n<pre><code>function foo () {\n    var num1 = 123, \n        num2 = 456;\n    // 怎样让外界既可以访问 num1 又可以访问 num2\n    return [\n        function () {\n            return num1;\n        },\n        function () {\n            return num2;\n        }\n    ];\n}\n</code></pre><p> -&gt; 闭包实现各种特性, 其根本的核心内容只有两个</p>\n<pre><code>1&gt; 带有私有数据的函数\n    function foo () {\n        var num = 123;\n        return function () {\n            // 可以访问 num\n        }\n    }\n    var func = foo();\n    // 称 func 是一个 带有私有数据的 函数\n    // 称 func 带有缓存\n2&gt; 带有私有数据的 对象\n</code></pre></li>\n<li><p>闭包的应用__沙箱模式<br> 沙箱就是一个隔离的执行环境</p>\n<p> 在 js 中什么情况需要使用沙箱</p>\n<p> function Person () {  … }<br> var p = Person. …<br> Person.prototype = ….<br> …</p>\n<p> 定义变量越多, 会怎样? 出现冲突的可能性越大.</p>\n<p> (function () {} )();</p>\n<p> var f = function () {};<br> f();</p>\n<p> 同理, 在 代码中 有时为了使得代码更加简洁, 会引入很多变量</p>\n<p> (function () {</p>\n<pre><code>// 沙箱模式\n\n// 所有的代码写在这里\n</code></pre></li>\n</ol>\n<pre><code>})();\n</code></pre><ol>\n<li><p>闭包的应用__简化递归函数的性能问题</p>\n</li>\n<li><p>闭包的应用__模拟 onload 事件的追加与移除</p>\n<p> o.addEvent( function … )<br> o.removeEvent( fn )</p>\n<p> 系统 调用 load()  按照一定顺序执行</p>\n<p> 所以, 我们需要有一个对象, 有两个方法, 用来追加移除事件, 需要一个私有数组存储函数</p>\n<p> var itcastload = (function () {</p>\n<pre><code>// 私有数据\n\nreturn {\n\n};\n</code></pre><p> })();</p>\n</li>\n</ol>\n<ol>\n<li><p>利用闭包模拟一个缓存结构<br> cache 对象, 可以使用 cache[ key ] = value 存储数据, cache[ key ] 获得数据<br> 当 cahche 里面的数据达到 1024 条, 将最早放进去的数据移除</p>\n<p> cache = {} 可以存取数据, 但是不能限定数据的长度</p>\n<p> 如果需要限定数据, 就是在加入数据的时候 判读, 是否已超过尺寸.<br> 如果是, 则移除, 如果不是, 则什么也不做</p>\n<p> 将 cache 做成函数, 添加数据使用 cache( key, value )<br> 而且函数本身也是对象</p>\n<p> function cache ( key, value ) {</p>\n<pre><code>// 可以在这里加上限定长度的代码\n\ncache[ key ] = value;\n</code></pre><p> }</p>\n<p> 由于需要记录键的数量. 并且需要记录添加数据的先后顺序. 所有首先考虑有序的数组.<br> 因此需要让 cache 函数带有缓存功能</p>\n<p> var cache = (function () {</p>\n<pre><code>var data = [];\n\nfunction cache ( key, value ) {\n\n    // 做判断, 如果超出范围, 则, 将最开始加入的 移除 \n    // 将数组 第 0 项元素移除的 splice, shift\n\n    cache[ key ] = value;\n}\nreturn cache;\n</code></pre><p> })();</p>\n</li>\n</ol>\n<p>10.函数是基本的对象类型，可以作为变量赋值，可以作为参数使用，也可以作为返回值使用。</p>\n<ol>\n<li>闭包应用 带有事件（移除与追加）的对象</li>\n</ol>\n<p>11.1定义一个自调用函数 (function(){})()<br>把所有方法放在 data = []<br> 并在window.onload = function(){};加载完就执行。<br>添加事件 return{addEvent:function(fn){<br>    data.push(fn)<br>},removeEvent:function(fn){<br>    // 倒过来循环<br>                for ( var i = data.length - 1; i &gt;= 0; i– ) {<br>                    if ( data[ i ] === fn ) {<br>                        data.splice( i, 1 );<br>                    }<br>                }<br>            }<br>        }<br>这里注意在   1，删除的遍历时要倒着遍历 因为数组的长度在发生改变<br>            2，在使用删除的时候需要把事件提出来 是一个变量储存 才可以实现删除</p>\n"},{"title":"javascript 面向对象：6","_content":"1 forEach\n\tvar arr = [ 'hello', ' js', {  }, function () {} ];\n\t// 遍历 数组\n\tarr.forEach( function ( v, i ) {\n\t\tconsole.log( i + '=====' + v );\n\t});\n\n\n\t2 map 映射\n\t语法: \t\t数组.map( fn )\n\t返回一个数组, 数组的每一个元素就是 map 函数中的 fn 的返回值\n\tvar arr = [ 1, 2, 3, 4 ];\n\n\t数学中: x -> x * x\n\tvar a = arr.map(function ( v, i ) {\n\t\treturn v * v;\n\t});\n\n\n\t3 filter 就是筛选\n\t语法:     数组.filter( function ( v, i ) { return true/false })\n\tvar arr = [ 1, 2, 3, 4, 5, 6 ];\n\tvar a = arr.filter( function ( v ) { return v % 2 === 1; });\n\n\n\t4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false\n\tvar arr = [ '123', {}, function () {}, '123' ];\n\t判断数组中至少有一个数数字\n\tvar isTrue = arr.some( function ( v ) { return typeof v === 'number'; } );\n\n\t5 every 必须满足所有元素都复合要求才会返回 true\n\tvar arr = [ 1, 2, 3, 4, 5, '6' ];\n\tvar isTrue = arr.every( function ( v ) { return typeof v === 'number'; } );\n\n\n\t6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1\n\tvar arr = [ 1, 2, 3, 4, 5 ];\n\tvar res = arr.indexOf( 4 );\n\tconsole.log( res );\n\n\tvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\n\tvar res = arr.indexOf( 4, 4 );\n\tconsole.log( res );\n\n\t7 lastIndexOf 从右往左找\n\tvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\n\tvar res = arr.lastIndexOf( 4 );\n\tconsole.log( res );\n\n1. 函数的四种调用模式\n\t-> 函数有下列调用模式\n\t\t1> 函数模式\n\t\t2> 方法模式\n\t\t3> 构造器模式\n\t\t4> 上下文模式\n\n2. 函数调用 模式\n\t-> 函数的定义方式\n\t\t1> 声明式\n\t\t2> 表达式式\n\t\t3> Function\n\t-> 单独独立调用的就是函数\n\t\t函数名( 参数 )\n\t-> this 表示全局对象\n\t-> 任何自调用函数都是函数模式\n\n3. 方法调用 模式   method\n\t-> 区分\n\t\t方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.\n\n\t\t对象.方法( 参数 )\n\t-> this 表示引导方法的对象\n\n4. 面试题\n\tvar length = 10;\n\tfunction fn() {\n\t\tconsole.log( this.length );\n\t}\n\tvar obj = {\n\t\tlength: 5,\n\t\tmethod: function ( fn ) {\n\t\t\tfn();\n\t\t\targuments[ 0 ]();\n\t\t}\n\t};\n\tobj.method( fn, 1 );\n\n5. 构造器模式(构造函数模式, 构造方法模式)\n\tconstructor\n\t-> 区分\n\t\t使用 new 关键字引导\n\t-> 执行步骤\n\t\tvar p = new Person();\n\t\tnew 是一个运算符, 专门用来申请创建对象, 创建出来的对象传递给构造函数的 this\n\t\t利用构造函数对其初始化\n\n\t\tfunction Person () {\n\t\t\tthis.name = 'jim',\n\t\t\tthis.age = 19;\n\t\t\tthis.gender = 'male';\n\t\t}\n\t-> 返回值\n\t\t如果不写 return 语句, 那么 构造函数 默认返回 this\n\t\t如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. \n\t\t如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this\n\n\t-> 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的\n\n\n6. 关于构造函数结核性的一个小结\n\t1> 如果构造函数没有参数, 可以省略 圆括号\n\t\tvar p = new Person;\n\t2> 如果希望创建对象并直接调用其方法\n\t\t( new Person () ).sayHello()\n\t\t-> 可以省略调整结核性的圆括号\n\t\t\tnew Person().sayHello()\n\t\t-> 如果想要省略构造函数的圆括号, 就必须添加结核性的圆括号\n\t\t\t(new Person).sayHello()\n\n7. 上下文调用模式\n\t就是 环境调用模式 => 在不同环境下的不同调用模式\n\t简单说就是统一一种格式, 可以实现 函数模式与方法模式\n\n\t-> 语法(区分)\n\t\t1> call 形式\n\t\t\t函数名.call( ... )\n\t\t2> apply 形式\n\t\t\t函数名.apply( ... )\n\t\t这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式\n\n\t-> 用法\n\t\t存在上下文调用的目的就是为了实现借用方法\n\n\t\tfunction foo () {\n\t\t\tconsole.log( this );\n\t\t}\n\n\t\tvar o = { name: 'jim' };\n\n\t\tfoo();\n\n\t\to.func = foo;\n\t\to.func();\n\n\t\t// 如果需要让函数以函数的形式调用, 可以使用\n\t\tfoo.apply( null ) 或 foo.apply()\n\t\t\n\t\t// 如果希望他是方法调用模式, 注意需要提供一个宿主对象\n\t\tfoo.apply( o )\n\n\t-> 带有参数的函数如何实现上下文调用\n\t\tfunction foo ( num1, num2 ) {\n\t\t\tconsole.log( this );\n\t\t\treturn num1 + num2;\n\t\t} \n\n\t\t// 函数调用模式\n\t\tvar res1 = foo( 123, 567 );\n\n\t\t// 方法调用\n\t\tvar o = { name: 'jim' };\n\t\to.func = foo;\n\n\t\tvar res2 = o.func( 123, 567 );\n\t\n\t\t使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象\n\t\t如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个\n\t\t数组参数, 将函数的参数依次放在数组中.\t\n\n\t\t例如: 函数模式 \t\tfoo( 123, 567 );\n\t\t\t  apply    \t\tfoo.apply( null, [ 123, 567 ] )\n\n\t\t如果有一个函数调用: func( '张三', 19, '男' ), 将其修改成 apply 模式\n\t\tfunc.apply( null, [ '张三', 19, '男'] )\n\n\t\t方法模式:\t\t\to.func( 123, 567 )\n\t\tapply\t\t\t\tfoo.apply( o, [ 123, 567 ] )\n\n\n8. call 调用\n\t在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂\n\t所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组\n\n\tfoo( 123, 567 );\n\n\tfoo.apply( null, [ 123, 567 ] );\n\n\tfoo.call( null, 123, 567 );\n\n\n9. 借用构造方法实现继承\n\tfunction Person ( name, age, gender ) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.gender = gender;\n\t}\n\n\tfunction Student ( name, age, gender, course ) {\n\n\t\tPerson.call( this, name, age, gender );\n\n\t\tthis.course = course;\n\t}\n\n\tvar p = new Student ( 'jim', 19, 'male', '前端' );\n\n\n10. 函数的 bind 方法\n\tbind 就是 绑定\n\n\n11. Object.prototype 的成员\n\t1) constructor\n\t2) hasOwnProperty 判断该属性是否为自己提供\n\t3) propertyIsEnumerable 判断属性是否可以枚举\n\t4) isPrototypeOf\t判断是否为原型对象\n\t5) toString, toLocaleString, valueOf\n\n12. 包装对象\n\t字符串 string 是基本类型, 理论上讲不应该包含方法\n\tcharAt, substr, slice, ...\n\n\t在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型\n\n\tNumber\n\tString\n\tBoolean\n\n\t在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候\n\t自动的将基本类型转换成对象类型.\n\n\t\"abc\".charAt( 1 )\n\n\t\"abc\" -> new String( \"abc\" )\n\ts.charAt( 1 ) 返回结果\n\ts 就被销毁\n\n\t当\t基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法. \n\t方法执行结束后, 这个对象就被立刻回收\n\n\t在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字\n\t就会自动转换成对应的包装类型\n\n13. getter 与 setter 的语法糖\n\n\t语法糖: 为了方便开发而给出的语法结构\n\n\tvar o = (function () {\n\t\tvar num = 123;\n\t\treturn {\n\t\t\tget_num: function () {\n\t\t\t\treturn num;\n\t\t\t},\n\t\t\tset_num: function ( v ) {\n\t\t\t\tnum = v;\n\t\t\t}\n\t\t};\n\t})();\n\n\t// 获得数据\n\to.get_num();\t\t\t=> o.num 形式\n\n\t// 设置\n\to.set_num( 456 );\t\t=> o.num = 456 形式\n\n\tvar o = (function () {\n\t\tvar num = 123;\n\t\treturn {\n\t\t\t\t\n\t\t\t// get 名字 () { 逻辑体 }\n\t\t\tget num () {\n\t\t\t\treturn num;\n\t\t\t}\n\n\t\t\t// set 名字 ( v ) { 逻辑体 }\n\t\t\tset num ( v ) {\n\t\t\t\tnum = v;\n\t\t\t}\n\t\t};\n\t})();\n\n14. ES5 中引入的部分数组方法\n\t1> forEach\n\t2> map\n\t3> filter\n\t4> some\n\t5> every\n\t6> indexOf\n\t7> lastIndexOf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象/面向对象第六天.md","raw":"---\ntitle: javascript 面向对象：6\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1 forEach\n\tvar arr = [ 'hello', ' js', {  }, function () {} ];\n\t// 遍历 数组\n\tarr.forEach( function ( v, i ) {\n\t\tconsole.log( i + '=====' + v );\n\t});\n\n\n\t2 map 映射\n\t语法: \t\t数组.map( fn )\n\t返回一个数组, 数组的每一个元素就是 map 函数中的 fn 的返回值\n\tvar arr = [ 1, 2, 3, 4 ];\n\n\t数学中: x -> x * x\n\tvar a = arr.map(function ( v, i ) {\n\t\treturn v * v;\n\t});\n\n\n\t3 filter 就是筛选\n\t语法:     数组.filter( function ( v, i ) { return true/false })\n\tvar arr = [ 1, 2, 3, 4, 5, 6 ];\n\tvar a = arr.filter( function ( v ) { return v % 2 === 1; });\n\n\n\t4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false\n\tvar arr = [ '123', {}, function () {}, '123' ];\n\t判断数组中至少有一个数数字\n\tvar isTrue = arr.some( function ( v ) { return typeof v === 'number'; } );\n\n\t5 every 必须满足所有元素都复合要求才会返回 true\n\tvar arr = [ 1, 2, 3, 4, 5, '6' ];\n\tvar isTrue = arr.every( function ( v ) { return typeof v === 'number'; } );\n\n\n\t6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1\n\tvar arr = [ 1, 2, 3, 4, 5 ];\n\tvar res = arr.indexOf( 4 );\n\tconsole.log( res );\n\n\tvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\n\tvar res = arr.indexOf( 4, 4 );\n\tconsole.log( res );\n\n\t7 lastIndexOf 从右往左找\n\tvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\n\tvar res = arr.lastIndexOf( 4 );\n\tconsole.log( res );\n\n1. 函数的四种调用模式\n\t-> 函数有下列调用模式\n\t\t1> 函数模式\n\t\t2> 方法模式\n\t\t3> 构造器模式\n\t\t4> 上下文模式\n\n2. 函数调用 模式\n\t-> 函数的定义方式\n\t\t1> 声明式\n\t\t2> 表达式式\n\t\t3> Function\n\t-> 单独独立调用的就是函数\n\t\t函数名( 参数 )\n\t-> this 表示全局对象\n\t-> 任何自调用函数都是函数模式\n\n3. 方法调用 模式   method\n\t-> 区分\n\t\t方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.\n\n\t\t对象.方法( 参数 )\n\t-> this 表示引导方法的对象\n\n4. 面试题\n\tvar length = 10;\n\tfunction fn() {\n\t\tconsole.log( this.length );\n\t}\n\tvar obj = {\n\t\tlength: 5,\n\t\tmethod: function ( fn ) {\n\t\t\tfn();\n\t\t\targuments[ 0 ]();\n\t\t}\n\t};\n\tobj.method( fn, 1 );\n\n5. 构造器模式(构造函数模式, 构造方法模式)\n\tconstructor\n\t-> 区分\n\t\t使用 new 关键字引导\n\t-> 执行步骤\n\t\tvar p = new Person();\n\t\tnew 是一个运算符, 专门用来申请创建对象, 创建出来的对象传递给构造函数的 this\n\t\t利用构造函数对其初始化\n\n\t\tfunction Person () {\n\t\t\tthis.name = 'jim',\n\t\t\tthis.age = 19;\n\t\t\tthis.gender = 'male';\n\t\t}\n\t-> 返回值\n\t\t如果不写 return 语句, 那么 构造函数 默认返回 this\n\t\t如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. \n\t\t如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this\n\n\t-> 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的\n\n\n6. 关于构造函数结核性的一个小结\n\t1> 如果构造函数没有参数, 可以省略 圆括号\n\t\tvar p = new Person;\n\t2> 如果希望创建对象并直接调用其方法\n\t\t( new Person () ).sayHello()\n\t\t-> 可以省略调整结核性的圆括号\n\t\t\tnew Person().sayHello()\n\t\t-> 如果想要省略构造函数的圆括号, 就必须添加结核性的圆括号\n\t\t\t(new Person).sayHello()\n\n7. 上下文调用模式\n\t就是 环境调用模式 => 在不同环境下的不同调用模式\n\t简单说就是统一一种格式, 可以实现 函数模式与方法模式\n\n\t-> 语法(区分)\n\t\t1> call 形式\n\t\t\t函数名.call( ... )\n\t\t2> apply 形式\n\t\t\t函数名.apply( ... )\n\t\t这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式\n\n\t-> 用法\n\t\t存在上下文调用的目的就是为了实现借用方法\n\n\t\tfunction foo () {\n\t\t\tconsole.log( this );\n\t\t}\n\n\t\tvar o = { name: 'jim' };\n\n\t\tfoo();\n\n\t\to.func = foo;\n\t\to.func();\n\n\t\t// 如果需要让函数以函数的形式调用, 可以使用\n\t\tfoo.apply( null ) 或 foo.apply()\n\t\t\n\t\t// 如果希望他是方法调用模式, 注意需要提供一个宿主对象\n\t\tfoo.apply( o )\n\n\t-> 带有参数的函数如何实现上下文调用\n\t\tfunction foo ( num1, num2 ) {\n\t\t\tconsole.log( this );\n\t\t\treturn num1 + num2;\n\t\t} \n\n\t\t// 函数调用模式\n\t\tvar res1 = foo( 123, 567 );\n\n\t\t// 方法调用\n\t\tvar o = { name: 'jim' };\n\t\to.func = foo;\n\n\t\tvar res2 = o.func( 123, 567 );\n\t\n\t\t使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象\n\t\t如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个\n\t\t数组参数, 将函数的参数依次放在数组中.\t\n\n\t\t例如: 函数模式 \t\tfoo( 123, 567 );\n\t\t\t  apply    \t\tfoo.apply( null, [ 123, 567 ] )\n\n\t\t如果有一个函数调用: func( '张三', 19, '男' ), 将其修改成 apply 模式\n\t\tfunc.apply( null, [ '张三', 19, '男'] )\n\n\t\t方法模式:\t\t\to.func( 123, 567 )\n\t\tapply\t\t\t\tfoo.apply( o, [ 123, 567 ] )\n\n\n8. call 调用\n\t在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂\n\t所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组\n\n\tfoo( 123, 567 );\n\n\tfoo.apply( null, [ 123, 567 ] );\n\n\tfoo.call( null, 123, 567 );\n\n\n9. 借用构造方法实现继承\n\tfunction Person ( name, age, gender ) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.gender = gender;\n\t}\n\n\tfunction Student ( name, age, gender, course ) {\n\n\t\tPerson.call( this, name, age, gender );\n\n\t\tthis.course = course;\n\t}\n\n\tvar p = new Student ( 'jim', 19, 'male', '前端' );\n\n\n10. 函数的 bind 方法\n\tbind 就是 绑定\n\n\n11. Object.prototype 的成员\n\t1) constructor\n\t2) hasOwnProperty 判断该属性是否为自己提供\n\t3) propertyIsEnumerable 判断属性是否可以枚举\n\t4) isPrototypeOf\t判断是否为原型对象\n\t5) toString, toLocaleString, valueOf\n\n12. 包装对象\n\t字符串 string 是基本类型, 理论上讲不应该包含方法\n\tcharAt, substr, slice, ...\n\n\t在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型\n\n\tNumber\n\tString\n\tBoolean\n\n\t在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候\n\t自动的将基本类型转换成对象类型.\n\n\t\"abc\".charAt( 1 )\n\n\t\"abc\" -> new String( \"abc\" )\n\ts.charAt( 1 ) 返回结果\n\ts 就被销毁\n\n\t当\t基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法. \n\t方法执行结束后, 这个对象就被立刻回收\n\n\t在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字\n\t就会自动转换成对应的包装类型\n\n13. getter 与 setter 的语法糖\n\n\t语法糖: 为了方便开发而给出的语法结构\n\n\tvar o = (function () {\n\t\tvar num = 123;\n\t\treturn {\n\t\t\tget_num: function () {\n\t\t\t\treturn num;\n\t\t\t},\n\t\t\tset_num: function ( v ) {\n\t\t\t\tnum = v;\n\t\t\t}\n\t\t};\n\t})();\n\n\t// 获得数据\n\to.get_num();\t\t\t=> o.num 形式\n\n\t// 设置\n\to.set_num( 456 );\t\t=> o.num = 456 形式\n\n\tvar o = (function () {\n\t\tvar num = 123;\n\t\treturn {\n\t\t\t\t\n\t\t\t// get 名字 () { 逻辑体 }\n\t\t\tget num () {\n\t\t\t\treturn num;\n\t\t\t}\n\n\t\t\t// set 名字 ( v ) { 逻辑体 }\n\t\t\tset num ( v ) {\n\t\t\t\tnum = v;\n\t\t\t}\n\t\t};\n\t})();\n\n14. ES5 中引入的部分数组方法\n\t1> forEach\n\t2> map\n\t3> filter\n\t4> some\n\t5> every\n\t6> indexOf\n\t7> lastIndexOf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面向对象/面向对象第六天","published":1,"date":"2016-12-24T12:16:07.000Z","updated":"2019-04-26T06:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ip002i7xuq8xizslvl","content":"<p>1 forEach<br>    var arr = [ ‘hello’, ‘ js’, {  }, function () {} ];<br>    // 遍历 数组<br>    arr.forEach( function ( v, i ) {<br>        console.log( i + ‘=====’ + v );<br>    });</p>\n<pre><code>2 map 映射\n语法:         数组.map( fn )\n返回一个数组, 数组的每一个元素就是 map 函数中的 fn 的返回值\nvar arr = [ 1, 2, 3, 4 ];\n\n数学中: x -&gt; x * x\nvar a = arr.map(function ( v, i ) {\n    return v * v;\n});\n\n\n3 filter 就是筛选\n语法:     数组.filter( function ( v, i ) { return true/false })\nvar arr = [ 1, 2, 3, 4, 5, 6 ];\nvar a = arr.filter( function ( v ) { return v % 2 === 1; });\n\n\n4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false\nvar arr = [ &apos;123&apos;, {}, function () {}, &apos;123&apos; ];\n判断数组中至少有一个数数字\nvar isTrue = arr.some( function ( v ) { return typeof v === &apos;number&apos;; } );\n\n5 every 必须满足所有元素都复合要求才会返回 true\nvar arr = [ 1, 2, 3, 4, 5, &apos;6&apos; ];\nvar isTrue = arr.every( function ( v ) { return typeof v === &apos;number&apos;; } );\n\n\n6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1\nvar arr = [ 1, 2, 3, 4, 5 ];\nvar res = arr.indexOf( 4 );\nconsole.log( res );\n\nvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\nvar res = arr.indexOf( 4, 4 );\nconsole.log( res );\n\n7 lastIndexOf 从右往左找\nvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\nvar res = arr.lastIndexOf( 4 );\nconsole.log( res );\n</code></pre><ol>\n<li><p>函数的四种调用模式<br> -&gt; 函数有下列调用模式</p>\n<pre><code>1&gt; 函数模式\n2&gt; 方法模式\n3&gt; 构造器模式\n4&gt; 上下文模式\n</code></pre></li>\n<li><p>函数调用 模式<br> -&gt; 函数的定义方式</p>\n<pre><code>1&gt; 声明式\n2&gt; 表达式式\n3&gt; Function\n</code></pre><p> -&gt; 单独独立调用的就是函数</p>\n<pre><code>函数名( 参数 )\n</code></pre><p> -&gt; this 表示全局对象<br> -&gt; 任何自调用函数都是函数模式</p>\n</li>\n<li><p>方法调用 模式   method<br> -&gt; 区分</p>\n<pre><code>方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.\n\n对象.方法( 参数 )\n</code></pre><p> -&gt; this 表示引导方法的对象</p>\n</li>\n<li><p>面试题<br> var length = 10;<br> function fn() {</p>\n<pre><code>console.log( this.length );\n</code></pre><p> }<br> var obj = {</p>\n<pre><code>length: 5,\nmethod: function ( fn ) {\n    fn();\n    arguments[ 0 ]();\n}\n</code></pre><p> };<br> obj.method( fn, 1 );</p>\n</li>\n<li><p>构造器模式(构造函数模式, 构造方法模式)<br> constructor<br> -&gt; 区分</p>\n<pre><code>使用 new 关键字引导\n</code></pre><p> -&gt; 执行步骤</p>\n<pre><code>var p = new Person();\nnew 是一个运算符, 专门用来申请创建对象, 创建出来的对象传递给构造函数的 this\n利用构造函数对其初始化\n\nfunction Person () {\n    this.name = &apos;jim&apos;,\n    this.age = 19;\n    this.gender = &apos;male&apos;;\n}\n</code></pre><p> -&gt; 返回值</p>\n<pre><code>如果不写 return 语句, 那么 构造函数 默认返回 this\n如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. \n如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this\n</code></pre><p> -&gt; 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的</p>\n</li>\n</ol>\n<ol>\n<li><p>关于构造函数结核性的一个小结<br> 1&gt; 如果构造函数没有参数, 可以省略 圆括号</p>\n<pre><code>var p = new Person;\n</code></pre><p> 2&gt; 如果希望创建对象并直接调用其方法</p>\n<pre><code>( new Person () ).sayHello()\n-&gt; 可以省略调整结核性的圆括号\n    new Person().sayHello()\n-&gt; 如果想要省略构造函数的圆括号, 就必须添加结核性的圆括号\n    (new Person).sayHello()\n</code></pre></li>\n<li><p>上下文调用模式<br> 就是 环境调用模式 =&gt; 在不同环境下的不同调用模式<br> 简单说就是统一一种格式, 可以实现 函数模式与方法模式</p>\n<p> -&gt; 语法(区分)</p>\n<pre><code>1&gt; call 形式\n    函数名.call( ... )\n2&gt; apply 形式\n    函数名.apply( ... )\n这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式\n</code></pre><p> -&gt; 用法</p>\n<pre><code>存在上下文调用的目的就是为了实现借用方法\n\nfunction foo () {\n    console.log( this );\n}\n\nvar o = { name: &apos;jim&apos; };\n\nfoo();\n\no.func = foo;\no.func();\n\n// 如果需要让函数以函数的形式调用, 可以使用\nfoo.apply( null ) 或 foo.apply()\n\n// 如果希望他是方法调用模式, 注意需要提供一个宿主对象\nfoo.apply( o )\n</code></pre><p> -&gt; 带有参数的函数如何实现上下文调用</p>\n<pre><code>function foo ( num1, num2 ) {\n    console.log( this );\n    return num1 + num2;\n} \n\n// 函数调用模式\nvar res1 = foo( 123, 567 );\n\n// 方法调用\nvar o = { name: &apos;jim&apos; };\no.func = foo;\n\nvar res2 = o.func( 123, 567 );\n\n使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象\n如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个\n数组参数, 将函数的参数依次放在数组中.    \n\n例如: 函数模式         foo( 123, 567 );\n      apply            foo.apply( null, [ 123, 567 ] )\n\n如果有一个函数调用: func( &apos;张三&apos;, 19, &apos;男&apos; ), 将其修改成 apply 模式\nfunc.apply( null, [ &apos;张三&apos;, 19, &apos;男&apos;] )\n\n方法模式:            o.func( 123, 567 )\napply                foo.apply( o, [ 123, 567 ] )\n</code></pre></li>\n</ol>\n<ol>\n<li><p>call 调用<br> 在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂<br> 所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组</p>\n<p> foo( 123, 567 );</p>\n<p> foo.apply( null, [ 123, 567 ] );</p>\n<p> foo.call( null, 123, 567 );</p>\n</li>\n</ol>\n<ol>\n<li><p>借用构造方法实现继承<br> function Person ( name, age, gender ) {</p>\n<pre><code>this.name = name;\nthis.age = age;\nthis.gender = gender;\n</code></pre><p> }</p>\n<p> function Student ( name, age, gender, course ) {</p>\n<pre><code>Person.call( this, name, age, gender );\n\nthis.course = course;\n</code></pre><p> }</p>\n<p> var p = new Student ( ‘jim’, 19, ‘male’, ‘前端’ );</p>\n</li>\n</ol>\n<ol>\n<li>函数的 bind 方法<br>bind 就是 绑定</li>\n</ol>\n<ol>\n<li><p>Object.prototype 的成员<br>1) constructor<br>2) hasOwnProperty 判断该属性是否为自己提供<br>3) propertyIsEnumerable 判断属性是否可以枚举<br>4) isPrototypeOf    判断是否为原型对象<br>5) toString, toLocaleString, valueOf</p>\n</li>\n<li><p>包装对象<br>字符串 string 是基本类型, 理论上讲不应该包含方法<br>charAt, substr, slice, …</p>\n<p>在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型</p>\n<p>Number<br>String<br>Boolean</p>\n<p>在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候<br>自动的将基本类型转换成对象类型.</p>\n<p>“abc”.charAt( 1 )</p>\n<p>“abc” -&gt; new String( “abc” )<br>s.charAt( 1 ) 返回结果<br>s 就被销毁</p>\n<p>当    基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法.<br>方法执行结束后, 这个对象就被立刻回收</p>\n<p>在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字<br>就会自动转换成对应的包装类型</p>\n</li>\n<li><p>getter 与 setter 的语法糖</p>\n<p>语法糖: 为了方便开发而给出的语法结构</p>\n<p>var o = (function () {</p>\n<pre><code>var num = 123;\nreturn {\n    get_num: function () {\n        return num;\n    },\n    set_num: function ( v ) {\n        num = v;\n    }\n};\n</code></pre><p>})();</p>\n<p>// 获得数据<br>o.get_num();            =&gt; o.num 形式</p>\n<p>// 设置<br>o.set_num( 456 );        =&gt; o.num = 456 形式</p>\n<p>var o = (function () {</p>\n<pre><code>var num = 123;\nreturn {\n\n    // get 名字 () { 逻辑体 }\n    get num () {\n        return num;\n    }\n\n    // set 名字 ( v ) { 逻辑体 }\n    set num ( v ) {\n        num = v;\n    }\n};\n</code></pre><p>})();</p>\n</li>\n<li><p>ES5 中引入的部分数组方法<br>1&gt; forEach<br>2&gt; map<br>3&gt; filter<br>4&gt; some<br>5&gt; every<br>6&gt; indexOf<br>7&gt; lastIndexOf</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>1 forEach<br>    var arr = [ ‘hello’, ‘ js’, {  }, function () {} ];<br>    // 遍历 数组<br>    arr.forEach( function ( v, i ) {<br>        console.log( i + ‘=====’ + v );<br>    });</p>\n<pre><code>2 map 映射\n语法:         数组.map( fn )\n返回一个数组, 数组的每一个元素就是 map 函数中的 fn 的返回值\nvar arr = [ 1, 2, 3, 4 ];\n\n数学中: x -&gt; x * x\nvar a = arr.map(function ( v, i ) {\n    return v * v;\n});\n\n\n3 filter 就是筛选\n语法:     数组.filter( function ( v, i ) { return true/false })\nvar arr = [ 1, 2, 3, 4, 5, 6 ];\nvar a = arr.filter( function ( v ) { return v % 2 === 1; });\n\n\n4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false\nvar arr = [ &apos;123&apos;, {}, function () {}, &apos;123&apos; ];\n判断数组中至少有一个数数字\nvar isTrue = arr.some( function ( v ) { return typeof v === &apos;number&apos;; } );\n\n5 every 必须满足所有元素都复合要求才会返回 true\nvar arr = [ 1, 2, 3, 4, 5, &apos;6&apos; ];\nvar isTrue = arr.every( function ( v ) { return typeof v === &apos;number&apos;; } );\n\n\n6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1\nvar arr = [ 1, 2, 3, 4, 5 ];\nvar res = arr.indexOf( 4 );\nconsole.log( res );\n\nvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\nvar res = arr.indexOf( 4, 4 );\nconsole.log( res );\n\n7 lastIndexOf 从右往左找\nvar arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];\nvar res = arr.lastIndexOf( 4 );\nconsole.log( res );\n</code></pre><ol>\n<li><p>函数的四种调用模式<br> -&gt; 函数有下列调用模式</p>\n<pre><code>1&gt; 函数模式\n2&gt; 方法模式\n3&gt; 构造器模式\n4&gt; 上下文模式\n</code></pre></li>\n<li><p>函数调用 模式<br> -&gt; 函数的定义方式</p>\n<pre><code>1&gt; 声明式\n2&gt; 表达式式\n3&gt; Function\n</code></pre><p> -&gt; 单独独立调用的就是函数</p>\n<pre><code>函数名( 参数 )\n</code></pre><p> -&gt; this 表示全局对象<br> -&gt; 任何自调用函数都是函数模式</p>\n</li>\n<li><p>方法调用 模式   method<br> -&gt; 区分</p>\n<pre><code>方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.\n\n对象.方法( 参数 )\n</code></pre><p> -&gt; this 表示引导方法的对象</p>\n</li>\n<li><p>面试题<br> var length = 10;<br> function fn() {</p>\n<pre><code>console.log( this.length );\n</code></pre><p> }<br> var obj = {</p>\n<pre><code>length: 5,\nmethod: function ( fn ) {\n    fn();\n    arguments[ 0 ]();\n}\n</code></pre><p> };<br> obj.method( fn, 1 );</p>\n</li>\n<li><p>构造器模式(构造函数模式, 构造方法模式)<br> constructor<br> -&gt; 区分</p>\n<pre><code>使用 new 关键字引导\n</code></pre><p> -&gt; 执行步骤</p>\n<pre><code>var p = new Person();\nnew 是一个运算符, 专门用来申请创建对象, 创建出来的对象传递给构造函数的 this\n利用构造函数对其初始化\n\nfunction Person () {\n    this.name = &apos;jim&apos;,\n    this.age = 19;\n    this.gender = &apos;male&apos;;\n}\n</code></pre><p> -&gt; 返回值</p>\n<pre><code>如果不写 return 语句, 那么 构造函数 默认返回 this\n如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. \n如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this\n</code></pre><p> -&gt; 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的</p>\n</li>\n</ol>\n<ol>\n<li><p>关于构造函数结核性的一个小结<br> 1&gt; 如果构造函数没有参数, 可以省略 圆括号</p>\n<pre><code>var p = new Person;\n</code></pre><p> 2&gt; 如果希望创建对象并直接调用其方法</p>\n<pre><code>( new Person () ).sayHello()\n-&gt; 可以省略调整结核性的圆括号\n    new Person().sayHello()\n-&gt; 如果想要省略构造函数的圆括号, 就必须添加结核性的圆括号\n    (new Person).sayHello()\n</code></pre></li>\n<li><p>上下文调用模式<br> 就是 环境调用模式 =&gt; 在不同环境下的不同调用模式<br> 简单说就是统一一种格式, 可以实现 函数模式与方法模式</p>\n<p> -&gt; 语法(区分)</p>\n<pre><code>1&gt; call 形式\n    函数名.call( ... )\n2&gt; apply 形式\n    函数名.apply( ... )\n这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式\n</code></pre><p> -&gt; 用法</p>\n<pre><code>存在上下文调用的目的就是为了实现借用方法\n\nfunction foo () {\n    console.log( this );\n}\n\nvar o = { name: &apos;jim&apos; };\n\nfoo();\n\no.func = foo;\no.func();\n\n// 如果需要让函数以函数的形式调用, 可以使用\nfoo.apply( null ) 或 foo.apply()\n\n// 如果希望他是方法调用模式, 注意需要提供一个宿主对象\nfoo.apply( o )\n</code></pre><p> -&gt; 带有参数的函数如何实现上下文调用</p>\n<pre><code>function foo ( num1, num2 ) {\n    console.log( this );\n    return num1 + num2;\n} \n\n// 函数调用模式\nvar res1 = foo( 123, 567 );\n\n// 方法调用\nvar o = { name: &apos;jim&apos; };\no.func = foo;\n\nvar res2 = o.func( 123, 567 );\n\n使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象\n如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个\n数组参数, 将函数的参数依次放在数组中.    \n\n例如: 函数模式         foo( 123, 567 );\n      apply            foo.apply( null, [ 123, 567 ] )\n\n如果有一个函数调用: func( &apos;张三&apos;, 19, &apos;男&apos; ), 将其修改成 apply 模式\nfunc.apply( null, [ &apos;张三&apos;, 19, &apos;男&apos;] )\n\n方法模式:            o.func( 123, 567 )\napply                foo.apply( o, [ 123, 567 ] )\n</code></pre></li>\n</ol>\n<ol>\n<li><p>call 调用<br> 在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂<br> 所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组</p>\n<p> foo( 123, 567 );</p>\n<p> foo.apply( null, [ 123, 567 ] );</p>\n<p> foo.call( null, 123, 567 );</p>\n</li>\n</ol>\n<ol>\n<li><p>借用构造方法实现继承<br> function Person ( name, age, gender ) {</p>\n<pre><code>this.name = name;\nthis.age = age;\nthis.gender = gender;\n</code></pre><p> }</p>\n<p> function Student ( name, age, gender, course ) {</p>\n<pre><code>Person.call( this, name, age, gender );\n\nthis.course = course;\n</code></pre><p> }</p>\n<p> var p = new Student ( ‘jim’, 19, ‘male’, ‘前端’ );</p>\n</li>\n</ol>\n<ol>\n<li>函数的 bind 方法<br>bind 就是 绑定</li>\n</ol>\n<ol>\n<li><p>Object.prototype 的成员<br>1) constructor<br>2) hasOwnProperty 判断该属性是否为自己提供<br>3) propertyIsEnumerable 判断属性是否可以枚举<br>4) isPrototypeOf    判断是否为原型对象<br>5) toString, toLocaleString, valueOf</p>\n</li>\n<li><p>包装对象<br>字符串 string 是基本类型, 理论上讲不应该包含方法<br>charAt, substr, slice, …</p>\n<p>在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型</p>\n<p>Number<br>String<br>Boolean</p>\n<p>在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候<br>自动的将基本类型转换成对象类型.</p>\n<p>“abc”.charAt( 1 )</p>\n<p>“abc” -&gt; new String( “abc” )<br>s.charAt( 1 ) 返回结果<br>s 就被销毁</p>\n<p>当    基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法.<br>方法执行结束后, 这个对象就被立刻回收</p>\n<p>在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字<br>就会自动转换成对应的包装类型</p>\n</li>\n<li><p>getter 与 setter 的语法糖</p>\n<p>语法糖: 为了方便开发而给出的语法结构</p>\n<p>var o = (function () {</p>\n<pre><code>var num = 123;\nreturn {\n    get_num: function () {\n        return num;\n    },\n    set_num: function ( v ) {\n        num = v;\n    }\n};\n</code></pre><p>})();</p>\n<p>// 获得数据<br>o.get_num();            =&gt; o.num 形式</p>\n<p>// 设置<br>o.set_num( 456 );        =&gt; o.num = 456 形式</p>\n<p>var o = (function () {</p>\n<pre><code>var num = 123;\nreturn {\n\n    // get 名字 () { 逻辑体 }\n    get num () {\n        return num;\n    }\n\n    // set 名字 ( v ) { 逻辑体 }\n    set num ( v ) {\n        num = v;\n    }\n};\n</code></pre><p>})();</p>\n</li>\n<li><p>ES5 中引入的部分数组方法<br>1&gt; forEach<br>2&gt; map<br>3&gt; filter<br>4&gt; some<br>5&gt; every<br>6&gt; indexOf<br>7&gt; lastIndexOf</p>\n</li>\n</ol>\n"},{"title":"css3 知识汇总","_content":"### 如何使用手册\n#### 学会使用工具，可以让我们事半功倍。\n1. []表示全部可选项\n2. ||表示或者\n3. |表示多选一\n4. ？表示0个或者1个\n5. *表示0个或者多个\n6. {}表示范围\n### 一、选择器\n  1. 属性选择器：\n    --ele[attr]  选取包含这个属性的元素\n    --ele[attr=value]  选取这个attr属性有且只有value这一个值的元素\n    --ele[attr^=value]  选取这个attr属性中以value字符开头的元素\n    --ele[attr$=value]  选取这个attr属性中以value字符结尾的元素\n    --ele[attr*=value]  选取这个attr属性中以包含value字符的元素\n    --ele[attr~=value]  选取这个attr属性中有value这个属性值的元素\n  2. 伪类选择器：\n    --ele:first-child  选取当前元素的父级下的第一个子元素\n    --ele:last-child  选取当前元素的父级下的最后一个子元素\n    --ele:nth-child(xn+y)  选取当前元素的父级下的第xn+y个子元素\n    --ele:nth-last-child(xn+y)  选取当前元素的父级下的倒数第xn+y个子元素\n    --ele:empty  选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数）\n    --ele:not(.class)  选取的是除了这个元素之外的元素\n    --ele:target  处在锚点状态下的元素（也就是当前元素被锚点状态）\n    --ele:checked  选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框）\n    --ele:enabled  选取的是当前处在enabled状态下的元素（用于按钮）\n    --ele:disabled  选取的是当前处在disabled状态下的元素（用于按钮）\n  3. 伪元素选择器：\n    --ele:before/ele::before  在当前元素下添加一个before伪元素处在当前元素下最开始的位置\n    --ele:after/ele::after  在当前元素下添加一个after伪元素处在当前元素下最末尾的位置\n\t\telement::before/element::after {\n\t\t\tcontent:''; 这里可以填内容  通常为空(如果设置文本内容,则会在该伪元素上显示文本内容)\n\t\t\tdisplay:block;  新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素)\n\t\t\twidth:;\n\t\t\theight:;\n\t\t\t...\n\t\t}\n\n\n    --ele::first-letter  当前文本的首字母（也可以是第一个字）\n    --ele::first-line  当前文本的第一行（是相对的）\n    --ele::selection  设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小)\n    --input::-webkit-input-placeholder{}选中input里的placeholder并设置样式\n\t注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个.\n\t4. 小技巧\n\t-webkit-user-select:none;当前元素下的文字不可选中\n\n### 二、颜色\n  1. color属性可以赋什么值\n    -- red  直接写代表颜色的英文单词\n    -- #CCCCCC  16进制表示方法\n    -- rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255\n    -- rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承\n    -- hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100%\n    -- hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒\n\n子继承\n\t\n    -- transparent 完全透明的意思，不可以调节透明度\n  2. opacity  表示透明度的意思，取值为0-1之间的数字，会被子盒子继承\n\n### 三、文字阴影\n  1. text-shadow: 0px 0px 0px red  文字阴影\n    -- 第一个参数表示阴影左右移动的距离（正值向右，负值向左）\n    -- 第二个参数表示阴影上下移动的距离（正值向下，负值向上）\n    -- 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊\n    -- 第四个参数表示阴影颜色\n   (后面可以在用逗号,在添加一个文字阴影.)\n### 四、边框\n  1. border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px  边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后\n\n面的值可以省略不写）\n    -- 0 0 0 0 / 0 0 0 0;  标准写法  分别表示1、2、3、4 位置的X/Y轴半径\n    -- 0 0 0 / 0 0 0; 简写  分别表示 1、2/4、3 位置的X/Y轴半径\n    -- 0 0 / 0 0; 简写  分别表示 1/3、2/4 位置的X/Y轴半径\n    -- 0 / 0; 简写  表示四个位置的X/Y轴半径\n  2. box-shadow: 0px 0px 0px red  盒子阴影\n    -- 第一个参数表示阴影左右移动的距离（正值向右，负值向左）\n    -- 第二个参数表示阴影上下移动的距离（正值向下，负值向上）\n    -- 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊\n    -- 第四个参数表示阴影颜色\n  3. border-image: url(\"\") 27 stretch repeat  边框背景图片（复合属性，也可以拆开写）\n    -- 第一个参数表示边框背景图片的引入地址\n    -- 第二个参数表示引入的图片中以什么样的尺寸来分割成九份\n    -- 第三个参数表示X轴方向的填充方式（round，repeat，stretch）\n    -- 第四个参数表示Y轴方向的填充方式（round，repeat，stretch）\n    -- border-image-source: url(\"\");\n    -- border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白）\n    -- border-image-repeat: stretch repeat round;\n    -- border-image-width: 20px;\n    -- border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素.\n    说明:  stretch拉伸  repeat平铺(两边会被裁剪)   round显示全部浏览器自动调整\n\n### 五、盒模型\n  1. box-sizing:border-box （以边框方式计算盒子的大小）\n    -- border-box  设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border\n    -- content-box  设置为border-box以后，我们设置的盒子（width/height）即为content（默认）\n    说明:  默认的box-sizing:content-box;优先保证内容的大小  对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.\n### 六、背景\n  1. background-size: 10px 10px  背景图片的尺寸大小（也可以设置为contain、cover）\n    --contain  图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白）\n    --cover  图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子）\n  2. background-position: 10px 10px/top left  背景图片定位\n  3. background-origin:  背景图片的开始位置\n    --border-box  让图片背景在border开始的位置开始显示\n    --padding-box  让图片背景在padding开始的位置开始显示（默认）\n    --content-box  让图片背景在content开始的位置开始显示\n  4. background-clip:\n    --content-box  内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）\n    --padding-box  padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）\n  5. background-image\n    --background-image:url(\"\"),url(\"\"),...,...;  多张背景图片以逗号分隔可以引入多张背景图片\n    --background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的.\n\n### 七、渐变\n  1. linear-gradient()  线性渐变\n    --第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg）\n    --第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）\n    --第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色）\n    --第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）\n    --......\n  2. radial-gradient()  径向渐变\n    --第一个参数表示径向渐变的范围（为半径值）\n    --第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值）\n    --第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）\n    --第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色）\n    --第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）\n    --......\n  3. http://www.colorzilla.com/gradient-editor/  自动生成全兼容渐变代码\n 具体说明:  \n   #### 渐变\n   1. 线性渐变\n       background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色\n       方向还可以用度数但是要带单位deg 0deg向上 90deg向右\n       background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于       整个盒子)background:linear-\n\ngradient(90deg,yellow 25%,green 50%);\n       还可以个多个值:例如  background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%); \n       方向 颜色 范围\n   1. 径向渐变\n       有原点(圆心) 两种颜色\n       background-image:radial=gradient(120px at center center,yellow,green);\n       第一个参数是半径  后面两个是坐标 左后是颜色\n       background-image:radial=gradient(120px 80px at center center,yellow,green);\n       写了两个半径就是椭圆  后面坐标可以用单词 给百分比 和具体的数值\n       background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样\n   总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;\n### 八、过渡动画\n  1. transition: all 1s 1s ease  过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变）\n    --后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间\n    --一般大家默认写成（属性、过渡时间、延迟时间、线性）\n    --第一个参数为transition-property  是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all）\n    --第二个参数为transition-duration  是完成本次过渡动画的总时间\n    --第三个参数为transition-delay  是本次动画开始是的延迟时间\n    --第四个参数为transition-timing-function  是本次动画的动画线性（默认为ease）\n  2. http://cubic-bezier.com/#.17,.67,.83,.67  生成过渡线性（贝塞尔曲线）\n  说明:动画线性的其他值\n     linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) \n     ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) \n     ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) \n     ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) \n     ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) \n    这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画   加在element的时候会执行两次动画\n\n### 九、2D转换\n  所有2D转换都是transform属性，只不过后面的值不一样\n  1. transform: translate  2D转换中的位移\n    --translateX(20px) 向X轴正方向移动20px\n    --translateY(20px) 向Y轴正方向移动20px\n  2. transform: scale  2D转换中的缩放\n    --scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）\n    --scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）\n  3. transform: rotate  2D转换中的旋转\n    --rotate(360deg)  旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值)\n  4. transform: skew  2D转换中的倾斜（扭曲）\n    --skewX(360deg)  顺着X轴进行倾斜（不常用）\n    --skewY(360deg)  顺着Y轴进行倾斜（不常用）\n   注意:transform:translatex(x);\n          transform:translatex(y);\n         上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y);\n\n### 十、3D转换\n  1. transform: translate 3D转换中的位移\n    --translateX(20px) 向X轴正方向移动20px\n    --translateY(20px) 向Y轴正方向移动20px\n    --translateZ(20px) 向Z轴正方向移动20px\n  2. transform: rotate  2D转换中的旋转\n    --rotateX(360deg)  旋转一定的角度（延X轴进行一定的角度旋转）\n    --rotateY(360deg)  旋转一定的角度（延Y轴进行一定的角度旋转）\n    --rotateZ(360deg)  旋转一定的角度 ( 延Z轴进行一定的角度旋转 )\n          注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转\n  3. transform-origin: left bottom  改变旋转轴的位置\n      第一个参数可以为 top bottom left right\n      第一个参数可以为 top bottom left right\n      这里的参数还可以设置像素值\n  4. transform-style: preserve-3d  设置在父级盒子上，让其子元素在3D效果下\n  5. perspective: 600px  进行600px距离的透视效果，距离越大效果越不明显\n\n     注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() ...等，其顺序会影转换的效果。\n            当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate();\n            那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示\n      具体例子\n\t如:.rocket {\n\t\t\theight: 190px;\n\t\t\twidth: 100px;\n\t\t\tposition: absolute;\n\t\t\tbottom: 0;\n\t\t\ttransform:  translate(0, 0) rotate(30deg)  ;\n\t\t\ttransition: transform 1s;\n\t\t}\n\t\tsection:hover .rocket{\n\t\t\ttransform:translate(1000px, -500px) rotate(900deg) ;\n\t\t}\n\n### 十一、帧动画\n  1. @keyframes 名字{}  是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子\n    --{\n       from{\n       \t\tfrom中如果不设置,默认使用的是,初始状态\n       \t}\n       to{\n       \t\tto中设置的是结束时的状态\n       \t}\n     }\n    --{\n       0%{\n           \t0%中如果不设置,默认使用的是,初始状态\n        }\n       50%{\n            50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致\n        }\n       100%{\n           \t100%中设置的是结束时的状态\n        }\n     }\n  2. animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画\n  3. animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成\n  4. animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始\n  5. animation-iteration-count: infinite;  执行次数，是指本次动画执行多少次，infinite为无限\n  6. animation-timing-function: linear;  是指动画执行的线性(step(5)分布执行)\n  7. animation-fill-mode: forwards;  是指动画结束时的状态\n    --backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态\n    --forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态\n    --both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态\n  8. animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置\n    --normal 是指每次动画都是正向执行\n    --reverse 是指每次动画都是反向执行\n    --alternate 是指多次动画时以正向开始，并以（正、反、正...）的顺序执行下去\n    --alternate-reverse 是指多次动画时以反向开始，并以（反、正、反...）的顺序执行下去\n  9. animation-play-state: running; 是指动画的暂停与播放\n    --running 是指动画播放\n    --paused 是指动画暂停\n     (用js暂停动画dom.style.animationPlayState='paused';)\n  10. 连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停\n     连写注意:    复合写法\n              1属性的顺序是可以随意调换的\n\t          2第一次出现的时间是动画持续时间\n\t          3第二个出现的时间是延迟时间\n\t          4如果只设置一个时间 默认就是动画持续事件\n### 十二、flex弹性盒子\n  1. display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下\n  2. justify-content: flex-start;  设置在父级盒子上，表示主轴方向上的分布排列\n    --flex-start 这是默认值，是从开始位向结束位依次排列\n    --flex-end 是从结束位向开始位依次排列\n    --center 是居中显示\n    --space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等\n    --space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍\n   说明:space-between  左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值\n          space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧\n  3. align-items: stretch;  设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用\n    --stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突\n    --flex-start 排在开始位\n    --flex-end 排在结束位\n    --center 是居中显示\n  4. align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效)\n    --flex-start 是从开始位向结束位依次排列\n    --flex-end 是从结束位向开始位依次排列\n    --center 是居中显示\n    --space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等\n    --space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍\n  5. flex-direction: row;  改变主轴的方向\n    --row 是默认值，是主轴从左到右的方向排列,开始位在最左侧\n    --column 是主轴从上到下的方向排列，开始位是最上方\n    --row-reverse 是主轴从右到左的方向排列,开始位在最右侧\n    --column-reverse 是主轴从下到上的方向排列，开始位是最下方\n  6. flex-wrap:nowrap; 是否允许换行\n    --nowrap 是不允许换行，是默认值\n    --wrap 是允许换行\n  7. align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置\n    --flex-start 排在开始位\n    --flex-end 排在结束位\n    --center 是居中显示\n  8. order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1\n  9. flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重\n\n\n### 零碎知识点:\n1. -webkit-user-select:none;设置某元素的文字不能被选中.\n2. 实现自定义三角形\n.box {\n     height: 0;\n    width: 0;\n    border: 50px solid;\n    border-color: yellow transparent transparent transparent;\n    margin: 50px auto \n}\n3. position:absolute;\n   top:0;\n   left:0;\n   right:0;\n   bottom:0;\n相当于height:100%;width:100%;但是元素必须加绝对定位\n4. backface-visibility:hidden;后面隐藏\n\n","source":"_posts/css3.md","raw":"---\ntitle: css3 知识汇总\ncategories: ['前端']\ntags: ['css']\n---\n### 如何使用手册\n#### 学会使用工具，可以让我们事半功倍。\n1. []表示全部可选项\n2. ||表示或者\n3. |表示多选一\n4. ？表示0个或者1个\n5. *表示0个或者多个\n6. {}表示范围\n### 一、选择器\n  1. 属性选择器：\n    --ele[attr]  选取包含这个属性的元素\n    --ele[attr=value]  选取这个attr属性有且只有value这一个值的元素\n    --ele[attr^=value]  选取这个attr属性中以value字符开头的元素\n    --ele[attr$=value]  选取这个attr属性中以value字符结尾的元素\n    --ele[attr*=value]  选取这个attr属性中以包含value字符的元素\n    --ele[attr~=value]  选取这个attr属性中有value这个属性值的元素\n  2. 伪类选择器：\n    --ele:first-child  选取当前元素的父级下的第一个子元素\n    --ele:last-child  选取当前元素的父级下的最后一个子元素\n    --ele:nth-child(xn+y)  选取当前元素的父级下的第xn+y个子元素\n    --ele:nth-last-child(xn+y)  选取当前元素的父级下的倒数第xn+y个子元素\n    --ele:empty  选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数）\n    --ele:not(.class)  选取的是除了这个元素之外的元素\n    --ele:target  处在锚点状态下的元素（也就是当前元素被锚点状态）\n    --ele:checked  选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框）\n    --ele:enabled  选取的是当前处在enabled状态下的元素（用于按钮）\n    --ele:disabled  选取的是当前处在disabled状态下的元素（用于按钮）\n  3. 伪元素选择器：\n    --ele:before/ele::before  在当前元素下添加一个before伪元素处在当前元素下最开始的位置\n    --ele:after/ele::after  在当前元素下添加一个after伪元素处在当前元素下最末尾的位置\n\t\telement::before/element::after {\n\t\t\tcontent:''; 这里可以填内容  通常为空(如果设置文本内容,则会在该伪元素上显示文本内容)\n\t\t\tdisplay:block;  新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素)\n\t\t\twidth:;\n\t\t\theight:;\n\t\t\t...\n\t\t}\n\n\n    --ele::first-letter  当前文本的首字母（也可以是第一个字）\n    --ele::first-line  当前文本的第一行（是相对的）\n    --ele::selection  设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小)\n    --input::-webkit-input-placeholder{}选中input里的placeholder并设置样式\n\t注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个.\n\t4. 小技巧\n\t-webkit-user-select:none;当前元素下的文字不可选中\n\n### 二、颜色\n  1. color属性可以赋什么值\n    -- red  直接写代表颜色的英文单词\n    -- #CCCCCC  16进制表示方法\n    -- rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255\n    -- rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承\n    -- hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100%\n    -- hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒\n\n子继承\n\t\n    -- transparent 完全透明的意思，不可以调节透明度\n  2. opacity  表示透明度的意思，取值为0-1之间的数字，会被子盒子继承\n\n### 三、文字阴影\n  1. text-shadow: 0px 0px 0px red  文字阴影\n    -- 第一个参数表示阴影左右移动的距离（正值向右，负值向左）\n    -- 第二个参数表示阴影上下移动的距离（正值向下，负值向上）\n    -- 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊\n    -- 第四个参数表示阴影颜色\n   (后面可以在用逗号,在添加一个文字阴影.)\n### 四、边框\n  1. border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px  边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后\n\n面的值可以省略不写）\n    -- 0 0 0 0 / 0 0 0 0;  标准写法  分别表示1、2、3、4 位置的X/Y轴半径\n    -- 0 0 0 / 0 0 0; 简写  分别表示 1、2/4、3 位置的X/Y轴半径\n    -- 0 0 / 0 0; 简写  分别表示 1/3、2/4 位置的X/Y轴半径\n    -- 0 / 0; 简写  表示四个位置的X/Y轴半径\n  2. box-shadow: 0px 0px 0px red  盒子阴影\n    -- 第一个参数表示阴影左右移动的距离（正值向右，负值向左）\n    -- 第二个参数表示阴影上下移动的距离（正值向下，负值向上）\n    -- 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊\n    -- 第四个参数表示阴影颜色\n  3. border-image: url(\"\") 27 stretch repeat  边框背景图片（复合属性，也可以拆开写）\n    -- 第一个参数表示边框背景图片的引入地址\n    -- 第二个参数表示引入的图片中以什么样的尺寸来分割成九份\n    -- 第三个参数表示X轴方向的填充方式（round，repeat，stretch）\n    -- 第四个参数表示Y轴方向的填充方式（round，repeat，stretch）\n    -- border-image-source: url(\"\");\n    -- border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白）\n    -- border-image-repeat: stretch repeat round;\n    -- border-image-width: 20px;\n    -- border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素.\n    说明:  stretch拉伸  repeat平铺(两边会被裁剪)   round显示全部浏览器自动调整\n\n### 五、盒模型\n  1. box-sizing:border-box （以边框方式计算盒子的大小）\n    -- border-box  设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border\n    -- content-box  设置为border-box以后，我们设置的盒子（width/height）即为content（默认）\n    说明:  默认的box-sizing:content-box;优先保证内容的大小  对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.\n### 六、背景\n  1. background-size: 10px 10px  背景图片的尺寸大小（也可以设置为contain、cover）\n    --contain  图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白）\n    --cover  图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子）\n  2. background-position: 10px 10px/top left  背景图片定位\n  3. background-origin:  背景图片的开始位置\n    --border-box  让图片背景在border开始的位置开始显示\n    --padding-box  让图片背景在padding开始的位置开始显示（默认）\n    --content-box  让图片背景在content开始的位置开始显示\n  4. background-clip:\n    --content-box  内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）\n    --padding-box  padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）\n  5. background-image\n    --background-image:url(\"\"),url(\"\"),...,...;  多张背景图片以逗号分隔可以引入多张背景图片\n    --background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的.\n\n### 七、渐变\n  1. linear-gradient()  线性渐变\n    --第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg）\n    --第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）\n    --第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色）\n    --第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）\n    --......\n  2. radial-gradient()  径向渐变\n    --第一个参数表示径向渐变的范围（为半径值）\n    --第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值）\n    --第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）\n    --第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色）\n    --第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）\n    --......\n  3. http://www.colorzilla.com/gradient-editor/  自动生成全兼容渐变代码\n 具体说明:  \n   #### 渐变\n   1. 线性渐变\n       background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色\n       方向还可以用度数但是要带单位deg 0deg向上 90deg向右\n       background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于       整个盒子)background:linear-\n\ngradient(90deg,yellow 25%,green 50%);\n       还可以个多个值:例如  background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%); \n       方向 颜色 范围\n   1. 径向渐变\n       有原点(圆心) 两种颜色\n       background-image:radial=gradient(120px at center center,yellow,green);\n       第一个参数是半径  后面两个是坐标 左后是颜色\n       background-image:radial=gradient(120px 80px at center center,yellow,green);\n       写了两个半径就是椭圆  后面坐标可以用单词 给百分比 和具体的数值\n       background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样\n   总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;\n### 八、过渡动画\n  1. transition: all 1s 1s ease  过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变）\n    --后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间\n    --一般大家默认写成（属性、过渡时间、延迟时间、线性）\n    --第一个参数为transition-property  是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all）\n    --第二个参数为transition-duration  是完成本次过渡动画的总时间\n    --第三个参数为transition-delay  是本次动画开始是的延迟时间\n    --第四个参数为transition-timing-function  是本次动画的动画线性（默认为ease）\n  2. http://cubic-bezier.com/#.17,.67,.83,.67  生成过渡线性（贝塞尔曲线）\n  说明:动画线性的其他值\n     linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) \n     ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) \n     ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) \n     ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) \n     ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) \n    这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画   加在element的时候会执行两次动画\n\n### 九、2D转换\n  所有2D转换都是transform属性，只不过后面的值不一样\n  1. transform: translate  2D转换中的位移\n    --translateX(20px) 向X轴正方向移动20px\n    --translateY(20px) 向Y轴正方向移动20px\n  2. transform: scale  2D转换中的缩放\n    --scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）\n    --scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）\n  3. transform: rotate  2D转换中的旋转\n    --rotate(360deg)  旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值)\n  4. transform: skew  2D转换中的倾斜（扭曲）\n    --skewX(360deg)  顺着X轴进行倾斜（不常用）\n    --skewY(360deg)  顺着Y轴进行倾斜（不常用）\n   注意:transform:translatex(x);\n          transform:translatex(y);\n         上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y);\n\n### 十、3D转换\n  1. transform: translate 3D转换中的位移\n    --translateX(20px) 向X轴正方向移动20px\n    --translateY(20px) 向Y轴正方向移动20px\n    --translateZ(20px) 向Z轴正方向移动20px\n  2. transform: rotate  2D转换中的旋转\n    --rotateX(360deg)  旋转一定的角度（延X轴进行一定的角度旋转）\n    --rotateY(360deg)  旋转一定的角度（延Y轴进行一定的角度旋转）\n    --rotateZ(360deg)  旋转一定的角度 ( 延Z轴进行一定的角度旋转 )\n          注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转\n  3. transform-origin: left bottom  改变旋转轴的位置\n      第一个参数可以为 top bottom left right\n      第一个参数可以为 top bottom left right\n      这里的参数还可以设置像素值\n  4. transform-style: preserve-3d  设置在父级盒子上，让其子元素在3D效果下\n  5. perspective: 600px  进行600px距离的透视效果，距离越大效果越不明显\n\n     注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() ...等，其顺序会影转换的效果。\n            当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate();\n            那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示\n      具体例子\n\t如:.rocket {\n\t\t\theight: 190px;\n\t\t\twidth: 100px;\n\t\t\tposition: absolute;\n\t\t\tbottom: 0;\n\t\t\ttransform:  translate(0, 0) rotate(30deg)  ;\n\t\t\ttransition: transform 1s;\n\t\t}\n\t\tsection:hover .rocket{\n\t\t\ttransform:translate(1000px, -500px) rotate(900deg) ;\n\t\t}\n\n### 十一、帧动画\n  1. @keyframes 名字{}  是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子\n    --{\n       from{\n       \t\tfrom中如果不设置,默认使用的是,初始状态\n       \t}\n       to{\n       \t\tto中设置的是结束时的状态\n       \t}\n     }\n    --{\n       0%{\n           \t0%中如果不设置,默认使用的是,初始状态\n        }\n       50%{\n            50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致\n        }\n       100%{\n           \t100%中设置的是结束时的状态\n        }\n     }\n  2. animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画\n  3. animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成\n  4. animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始\n  5. animation-iteration-count: infinite;  执行次数，是指本次动画执行多少次，infinite为无限\n  6. animation-timing-function: linear;  是指动画执行的线性(step(5)分布执行)\n  7. animation-fill-mode: forwards;  是指动画结束时的状态\n    --backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态\n    --forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态\n    --both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态\n  8. animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置\n    --normal 是指每次动画都是正向执行\n    --reverse 是指每次动画都是反向执行\n    --alternate 是指多次动画时以正向开始，并以（正、反、正...）的顺序执行下去\n    --alternate-reverse 是指多次动画时以反向开始，并以（反、正、反...）的顺序执行下去\n  9. animation-play-state: running; 是指动画的暂停与播放\n    --running 是指动画播放\n    --paused 是指动画暂停\n     (用js暂停动画dom.style.animationPlayState='paused';)\n  10. 连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停\n     连写注意:    复合写法\n              1属性的顺序是可以随意调换的\n\t          2第一次出现的时间是动画持续时间\n\t          3第二个出现的时间是延迟时间\n\t          4如果只设置一个时间 默认就是动画持续事件\n### 十二、flex弹性盒子\n  1. display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下\n  2. justify-content: flex-start;  设置在父级盒子上，表示主轴方向上的分布排列\n    --flex-start 这是默认值，是从开始位向结束位依次排列\n    --flex-end 是从结束位向开始位依次排列\n    --center 是居中显示\n    --space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等\n    --space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍\n   说明:space-between  左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值\n          space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧\n  3. align-items: stretch;  设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用\n    --stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突\n    --flex-start 排在开始位\n    --flex-end 排在结束位\n    --center 是居中显示\n  4. align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效)\n    --flex-start 是从开始位向结束位依次排列\n    --flex-end 是从结束位向开始位依次排列\n    --center 是居中显示\n    --space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等\n    --space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍\n  5. flex-direction: row;  改变主轴的方向\n    --row 是默认值，是主轴从左到右的方向排列,开始位在最左侧\n    --column 是主轴从上到下的方向排列，开始位是最上方\n    --row-reverse 是主轴从右到左的方向排列,开始位在最右侧\n    --column-reverse 是主轴从下到上的方向排列，开始位是最下方\n  6. flex-wrap:nowrap; 是否允许换行\n    --nowrap 是不允许换行，是默认值\n    --wrap 是允许换行\n  7. align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置\n    --flex-start 排在开始位\n    --flex-end 排在结束位\n    --center 是居中显示\n  8. order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1\n  9. flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重\n\n\n### 零碎知识点:\n1. -webkit-user-select:none;设置某元素的文字不能被选中.\n2. 实现自定义三角形\n.box {\n     height: 0;\n    width: 0;\n    border: 50px solid;\n    border-color: yellow transparent transparent transparent;\n    margin: 50px auto \n}\n3. position:absolute;\n   top:0;\n   left:0;\n   right:0;\n   bottom:0;\n相当于height:100%;width:100%;但是元素必须加绝对定位\n4. backface-visibility:hidden;后面隐藏\n\n","slug":"css3","published":1,"date":"2017-02-27T14:18:38.000Z","updated":"2019-04-26T06:18:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0iq002l7xuqm8x5kpk6","content":"<h3 id=\"如何使用手册\"><a href=\"#如何使用手册\" class=\"headerlink\" title=\"如何使用手册\"></a>如何使用手册</h3><h4 id=\"学会使用工具，可以让我们事半功倍。\"><a href=\"#学会使用工具，可以让我们事半功倍。\" class=\"headerlink\" title=\"学会使用工具，可以让我们事半功倍。\"></a>学会使用工具，可以让我们事半功倍。</h4><ol>\n<li>[]表示全部可选项</li>\n<li>||表示或者</li>\n<li>|表示多选一</li>\n<li>？表示0个或者1个</li>\n<li>*表示0个或者多个</li>\n<li>{}表示范围<h3 id=\"一、选择器\"><a href=\"#一、选择器\" class=\"headerlink\" title=\"一、选择器\"></a>一、选择器</h3><ol>\n<li>属性选择器：<br>–ele[attr]  选取包含这个属性的元素<br>–ele[attr=value]  选取这个attr属性有且只有value这一个值的元素<br>–ele[attr^=value]  选取这个attr属性中以value字符开头的元素<br>–ele[attr$=value]  选取这个attr属性中以value字符结尾的元素<br>–ele[attr*=value]  选取这个attr属性中以包含value字符的元素<br>–ele[attr~=value]  选取这个attr属性中有value这个属性值的元素</li>\n<li>伪类选择器：<br>–ele:first-child  选取当前元素的父级下的第一个子元素<br>–ele:last-child  选取当前元素的父级下的最后一个子元素<br>–ele:nth-child(xn+y)  选取当前元素的父级下的第xn+y个子元素<br>–ele:nth-last-child(xn+y)  选取当前元素的父级下的倒数第xn+y个子元素<br>–ele:empty  选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数）<br>–ele:not(.class)  选取的是除了这个元素之外的元素<br>–ele:target  处在锚点状态下的元素（也就是当前元素被锚点状态）<br>–ele:checked  选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框）<br>–ele:enabled  选取的是当前处在enabled状态下的元素（用于按钮）<br>–ele:disabled  选取的是当前处在disabled状态下的元素（用于按钮）</li>\n<li>伪元素选择器：<br>–ele:before/ele::before  在当前元素下添加一个before伪元素处在当前元素下最开始的位置<br>–ele:after/ele::after  在当前元素下添加一个after伪元素处在当前元素下最末尾的位置<br>  element::before/element::after {<pre><code>content:&apos;&apos;; 这里可以填内容  通常为空(如果设置文本内容,则会在该伪元素上显示文本内容)\ndisplay:block;  新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素)\nwidth:;\nheight:;\n...\n</code></pre>  }</li>\n</ol>\n</li>\n</ol>\n<pre><code>--ele::first-letter  当前文本的首字母（也可以是第一个字）\n--ele::first-line  当前文本的第一行（是相对的）\n--ele::selection  设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小)\n--input::-webkit-input-placeholder{}选中input里的placeholder并设置样式\n注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个.\n4. 小技巧\n-webkit-user-select:none;当前元素下的文字不可选中\n</code></pre><h3 id=\"二、颜色\"><a href=\"#二、颜色\" class=\"headerlink\" title=\"二、颜色\"></a>二、颜色</h3><ol>\n<li>color属性可以赋什么值<br>– red  直接写代表颜色的英文单词<br>– #CCCCCC  16进制表示方法<br>– rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255<br>– rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承<br>– hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100%<br>– hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒</li>\n</ol>\n<p>子继承</p>\n<pre><code>-- transparent 完全透明的意思，不可以调节透明度\n</code></pre><ol>\n<li>opacity  表示透明度的意思，取值为0-1之间的数字，会被子盒子继承</li>\n</ol>\n<h3 id=\"三、文字阴影\"><a href=\"#三、文字阴影\" class=\"headerlink\" title=\"三、文字阴影\"></a>三、文字阴影</h3><ol>\n<li>text-shadow: 0px 0px 0px red  文字阴影<br>– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）<br>– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）<br>– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊<br>– 第四个参数表示阴影颜色<br>(后面可以在用逗号,在添加一个文字阴影.)<h3 id=\"四、边框\"><a href=\"#四、边框\" class=\"headerlink\" title=\"四、边框\"></a>四、边框</h3></li>\n<li>border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px  边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后</li>\n</ol>\n<p>面的值可以省略不写）<br>    – 0 0 0 0 / 0 0 0 0;  标准写法  分别表示1、2、3、4 位置的X/Y轴半径<br>    – 0 0 0 / 0 0 0; 简写  分别表示 1、2/4、3 位置的X/Y轴半径<br>    – 0 0 / 0 0; 简写  分别表示 1/3、2/4 位置的X/Y轴半径<br>    – 0 / 0; 简写  表示四个位置的X/Y轴半径</p>\n<ol>\n<li>box-shadow: 0px 0px 0px red  盒子阴影<br>– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）<br>– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）<br>– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊<br>– 第四个参数表示阴影颜色</li>\n<li>border-image: url(“”) 27 stretch repeat  边框背景图片（复合属性，也可以拆开写）<br>– 第一个参数表示边框背景图片的引入地址<br>– 第二个参数表示引入的图片中以什么样的尺寸来分割成九份<br>– 第三个参数表示X轴方向的填充方式（round，repeat，stretch）<br>– 第四个参数表示Y轴方向的填充方式（round，repeat，stretch）<br>– border-image-source: url(“”);<br>– border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白）<br>– border-image-repeat: stretch repeat round;<br>– border-image-width: 20px;<br>– border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素.<br>说明:  stretch拉伸  repeat平铺(两边会被裁剪)   round显示全部浏览器自动调整</li>\n</ol>\n<h3 id=\"五、盒模型\"><a href=\"#五、盒模型\" class=\"headerlink\" title=\"五、盒模型\"></a>五、盒模型</h3><ol>\n<li>box-sizing:border-box （以边框方式计算盒子的大小）<br>– border-box  设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border<br>– content-box  设置为border-box以后，我们设置的盒子（width/height）即为content（默认）<br>说明:  默认的box-sizing:content-box;优先保证内容的大小  对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.<h3 id=\"六、背景\"><a href=\"#六、背景\" class=\"headerlink\" title=\"六、背景\"></a>六、背景</h3></li>\n<li>background-size: 10px 10px  背景图片的尺寸大小（也可以设置为contain、cover）<br>–contain  图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白）<br>–cover  图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子）</li>\n<li>background-position: 10px 10px/top left  背景图片定位</li>\n<li>background-origin:  背景图片的开始位置<br>–border-box  让图片背景在border开始的位置开始显示<br>–padding-box  让图片背景在padding开始的位置开始显示（默认）<br>–content-box  让图片背景在content开始的位置开始显示</li>\n<li>background-clip:<br>–content-box  内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）<br>–padding-box  padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）</li>\n<li>background-image<br>–background-image:url(“”),url(“”),…,…;  多张背景图片以逗号分隔可以引入多张背景图片<br>–background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的.</li>\n</ol>\n<h3 id=\"七、渐变\"><a href=\"#七、渐变\" class=\"headerlink\" title=\"七、渐变\"></a>七、渐变</h3><ol>\n<li>linear-gradient()  线性渐变<br>–第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg）<br>–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）<br>–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色）<br>–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）<br>–……</li>\n<li>radial-gradient()  径向渐变<br>–第一个参数表示径向渐变的范围（为半径值）<br>–第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值）<br>–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）<br>–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色）<br>–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）<br>–……</li>\n<li><a href=\"http://www.colorzilla.com/gradient-editor/\" target=\"_blank\" rel=\"noopener\">http://www.colorzilla.com/gradient-editor/</a>  自动生成全兼容渐变代码<br>具体说明:  <h4 id=\"渐变\"><a href=\"#渐变\" class=\"headerlink\" title=\"渐变\"></a>渐变</h4><ol>\n<li>线性渐变<br>background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色<br>方向还可以用度数但是要带单位deg 0deg向上 90deg向右<br>background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于       整个盒子)background:linear-</li>\n</ol>\n</li>\n</ol>\n<p>gradient(90deg,yellow 25%,green 50%);<br>       还可以个多个值:例如  background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%);<br>       方向 颜色 范围</p>\n<ol>\n<li>径向渐变<br> 有原点(圆心) 两种颜色<br> background-image:radial=gradient(120px at center center,yellow,green);<br> 第一个参数是半径  后面两个是坐标 左后是颜色<br> background-image:radial=gradient(120px 80px at center center,yellow,green);<br> 写了两个半径就是椭圆  后面坐标可以用单词 给百分比 和具体的数值<br> background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样<br>总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;<h3 id=\"八、过渡动画\"><a href=\"#八、过渡动画\" class=\"headerlink\" title=\"八、过渡动画\"></a>八、过渡动画</h3><ol>\n<li>transition: all 1s 1s ease  过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变）<br>–后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间<br>–一般大家默认写成（属性、过渡时间、延迟时间、线性）<br>–第一个参数为transition-property  是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all）<br>–第二个参数为transition-duration  是完成本次过渡动画的总时间<br>–第三个参数为transition-delay  是本次动画开始是的延迟时间<br>–第四个参数为transition-timing-function  是本次动画的动画线性（默认为ease）</li>\n<li><a href=\"http://cubic-bezier.com/#.17,.67,.83,.67\" target=\"_blank\" rel=\"noopener\">http://cubic-bezier.com/#.17,.67,.83,.67</a>  生成过渡线性（贝塞尔曲线）<br>说明:动画线性的其他值<br>linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)<br>ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)<br>ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)<br>ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)<br>ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)<br>这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画   加在element的时候会执行两次动画</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"九、2D转换\"><a href=\"#九、2D转换\" class=\"headerlink\" title=\"九、2D转换\"></a>九、2D转换</h3><p>  所有2D转换都是transform属性，只不过后面的值不一样</p>\n<ol>\n<li>transform: translate  2D转换中的位移<br>–translateX(20px) 向X轴正方向移动20px<br>–translateY(20px) 向Y轴正方向移动20px</li>\n<li>transform: scale  2D转换中的缩放<br>–scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）<br>–scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）</li>\n<li>transform: rotate  2D转换中的旋转<br>–rotate(360deg)  旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值)</li>\n<li>transform: skew  2D转换中的倾斜（扭曲）<br>–skewX(360deg)  顺着X轴进行倾斜（不常用）<br>–skewY(360deg)  顺着Y轴进行倾斜（不常用）<br>注意:transform:translatex(x);<pre><code> transform:translatex(y);\n上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y);\n</code></pre></li>\n</ol>\n<h3 id=\"十、3D转换\"><a href=\"#十、3D转换\" class=\"headerlink\" title=\"十、3D转换\"></a>十、3D转换</h3><ol>\n<li>transform: translate 3D转换中的位移<br>–translateX(20px) 向X轴正方向移动20px<br>–translateY(20px) 向Y轴正方向移动20px<br>–translateZ(20px) 向Z轴正方向移动20px</li>\n<li>transform: rotate  2D转换中的旋转<br>–rotateX(360deg)  旋转一定的角度（延X轴进行一定的角度旋转）<br>–rotateY(360deg)  旋转一定的角度（延Y轴进行一定的角度旋转）<br>–rotateZ(360deg)  旋转一定的角度 ( 延Z轴进行一定的角度旋转 )<pre><code>注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转\n</code></pre></li>\n<li>transform-origin: left bottom  改变旋转轴的位置<br> 第一个参数可以为 top bottom left right<br> 第一个参数可以为 top bottom left right<br> 这里的参数还可以设置像素值</li>\n<li>transform-style: preserve-3d  设置在父级盒子上，让其子元素在3D效果下</li>\n<li><p>perspective: 600px  进行600px距离的透视效果，距离越大效果越不明显</p>\n<p>注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() …等，其顺序会影转换的效果。</p>\n<pre><code>当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate();\n那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示\n</code></pre><p> 具体例子<br>如:.rocket {</p>\n<pre><code>height: 190px;\nwidth: 100px;\nposition: absolute;\nbottom: 0;\ntransform:  translate(0, 0) rotate(30deg)  ;\ntransition: transform 1s;\n</code></pre><p>   }<br>   section:hover .rocket{</p>\n<pre><code>transform:translate(1000px, -500px) rotate(900deg) ;\n</code></pre><p>   }</p>\n</li>\n</ol>\n<h3 id=\"十一、帧动画\"><a href=\"#十一、帧动画\" class=\"headerlink\" title=\"十一、帧动画\"></a>十一、帧动画</h3><ol>\n<li>@keyframes 名字{}  是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子<br>–{<br>  from{<pre><code>    from中如果不设置,默认使用的是,初始状态\n}\n</code></pre>  to{<pre><code>    to中设置的是结束时的状态\n}\n</code></pre>}<br>–{<br>  0%{<pre><code>0%中如果不设置,默认使用的是,初始状态\n</code></pre>   }<br>  50%{<pre><code>50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致\n</code></pre>   }<br>  100%{<pre><code>100%中设置的是结束时的状态\n</code></pre>   }<br>}</li>\n<li>animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画</li>\n<li>animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成</li>\n<li>animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始</li>\n<li>animation-iteration-count: infinite;  执行次数，是指本次动画执行多少次，infinite为无限</li>\n<li>animation-timing-function: linear;  是指动画执行的线性(step(5)分布执行)</li>\n<li>animation-fill-mode: forwards;  是指动画结束时的状态<br>–backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态<br>–forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态<br>–both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态</li>\n<li>animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置<br>–normal 是指每次动画都是正向执行<br>–reverse 是指每次动画都是反向执行<br>–alternate 是指多次动画时以正向开始，并以（正、反、正…）的顺序执行下去<br>–alternate-reverse 是指多次动画时以反向开始，并以（反、正、反…）的顺序执行下去</li>\n<li>animation-play-state: running; 是指动画的暂停与播放<br>–running 是指动画播放<br>–paused 是指动画暂停<br>(用js暂停动画dom.style.animationPlayState=’paused’;)</li>\n<li>连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停<br>连写注意:    复合写法<pre><code>1属性的顺序是可以随意调换的\n2第一次出现的时间是动画持续时间\n3第二个出现的时间是延迟时间\n4如果只设置一个时间 默认就是动画持续事件\n</code></pre><h3 id=\"十二、flex弹性盒子\"><a href=\"#十二、flex弹性盒子\" class=\"headerlink\" title=\"十二、flex弹性盒子\"></a>十二、flex弹性盒子</h3></li>\n<li>display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下</li>\n<li>justify-content: flex-start;  设置在父级盒子上，表示主轴方向上的分布排列<br>–flex-start 这是默认值，是从开始位向结束位依次排列<br>–flex-end 是从结束位向开始位依次排列<br>–center 是居中显示<br>–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等<br>–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍<br>说明:space-between  左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值<pre><code>space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧\n</code></pre></li>\n<li>align-items: stretch;  设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用<br>–stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突<br>–flex-start 排在开始位<br>–flex-end 排在结束位<br>–center 是居中显示</li>\n<li>align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效)<br>–flex-start 是从开始位向结束位依次排列<br>–flex-end 是从结束位向开始位依次排列<br>–center 是居中显示<br>–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等<br>–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍</li>\n<li>flex-direction: row;  改变主轴的方向<br>–row 是默认值，是主轴从左到右的方向排列,开始位在最左侧<br>–column 是主轴从上到下的方向排列，开始位是最上方<br>–row-reverse 是主轴从右到左的方向排列,开始位在最右侧<br>–column-reverse 是主轴从下到上的方向排列，开始位是最下方</li>\n<li>flex-wrap:nowrap; 是否允许换行<br>–nowrap 是不允许换行，是默认值<br>–wrap 是允许换行</li>\n<li>align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置<br>–flex-start 排在开始位<br>–flex-end 排在结束位<br>–center 是居中显示</li>\n<li>order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1</li>\n<li>flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重</li>\n</ol>\n<h3 id=\"零碎知识点\"><a href=\"#零碎知识点\" class=\"headerlink\" title=\"零碎知识点:\"></a>零碎知识点:</h3><ol>\n<li>-webkit-user-select:none;设置某元素的文字不能被选中.</li>\n<li>实现自定义三角形<br>.box {<br>  height: 0;<br> width: 0;<br> border: 50px solid;<br> border-color: yellow transparent transparent transparent;<br> margin: 50px auto<br>}</li>\n<li>position:absolute;<br>top:0;<br>left:0;<br>right:0;<br>bottom:0;<br>相当于height:100%;width:100%;但是元素必须加绝对定位</li>\n<li>backface-visibility:hidden;后面隐藏</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"如何使用手册\"><a href=\"#如何使用手册\" class=\"headerlink\" title=\"如何使用手册\"></a>如何使用手册</h3><h4 id=\"学会使用工具，可以让我们事半功倍。\"><a href=\"#学会使用工具，可以让我们事半功倍。\" class=\"headerlink\" title=\"学会使用工具，可以让我们事半功倍。\"></a>学会使用工具，可以让我们事半功倍。</h4><ol>\n<li>[]表示全部可选项</li>\n<li>||表示或者</li>\n<li>|表示多选一</li>\n<li>？表示0个或者1个</li>\n<li>*表示0个或者多个</li>\n<li>{}表示范围<h3 id=\"一、选择器\"><a href=\"#一、选择器\" class=\"headerlink\" title=\"一、选择器\"></a>一、选择器</h3><ol>\n<li>属性选择器：<br>–ele[attr]  选取包含这个属性的元素<br>–ele[attr=value]  选取这个attr属性有且只有value这一个值的元素<br>–ele[attr^=value]  选取这个attr属性中以value字符开头的元素<br>–ele[attr$=value]  选取这个attr属性中以value字符结尾的元素<br>–ele[attr*=value]  选取这个attr属性中以包含value字符的元素<br>–ele[attr~=value]  选取这个attr属性中有value这个属性值的元素</li>\n<li>伪类选择器：<br>–ele:first-child  选取当前元素的父级下的第一个子元素<br>–ele:last-child  选取当前元素的父级下的最后一个子元素<br>–ele:nth-child(xn+y)  选取当前元素的父级下的第xn+y个子元素<br>–ele:nth-last-child(xn+y)  选取当前元素的父级下的倒数第xn+y个子元素<br>–ele:empty  选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数）<br>–ele:not(.class)  选取的是除了这个元素之外的元素<br>–ele:target  处在锚点状态下的元素（也就是当前元素被锚点状态）<br>–ele:checked  选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框）<br>–ele:enabled  选取的是当前处在enabled状态下的元素（用于按钮）<br>–ele:disabled  选取的是当前处在disabled状态下的元素（用于按钮）</li>\n<li>伪元素选择器：<br>–ele:before/ele::before  在当前元素下添加一个before伪元素处在当前元素下最开始的位置<br>–ele:after/ele::after  在当前元素下添加一个after伪元素处在当前元素下最末尾的位置<br>  element::before/element::after {<pre><code>content:&apos;&apos;; 这里可以填内容  通常为空(如果设置文本内容,则会在该伪元素上显示文本内容)\ndisplay:block;  新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素)\nwidth:;\nheight:;\n...\n</code></pre>  }</li>\n</ol>\n</li>\n</ol>\n<pre><code>--ele::first-letter  当前文本的首字母（也可以是第一个字）\n--ele::first-line  当前文本的第一行（是相对的）\n--ele::selection  设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小)\n--input::-webkit-input-placeholder{}选中input里的placeholder并设置样式\n注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个.\n4. 小技巧\n-webkit-user-select:none;当前元素下的文字不可选中\n</code></pre><h3 id=\"二、颜色\"><a href=\"#二、颜色\" class=\"headerlink\" title=\"二、颜色\"></a>二、颜色</h3><ol>\n<li>color属性可以赋什么值<br>– red  直接写代表颜色的英文单词<br>– #CCCCCC  16进制表示方法<br>– rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255<br>– rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承<br>– hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100%<br>– hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒</li>\n</ol>\n<p>子继承</p>\n<pre><code>-- transparent 完全透明的意思，不可以调节透明度\n</code></pre><ol>\n<li>opacity  表示透明度的意思，取值为0-1之间的数字，会被子盒子继承</li>\n</ol>\n<h3 id=\"三、文字阴影\"><a href=\"#三、文字阴影\" class=\"headerlink\" title=\"三、文字阴影\"></a>三、文字阴影</h3><ol>\n<li>text-shadow: 0px 0px 0px red  文字阴影<br>– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）<br>– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）<br>– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊<br>– 第四个参数表示阴影颜色<br>(后面可以在用逗号,在添加一个文字阴影.)<h3 id=\"四、边框\"><a href=\"#四、边框\" class=\"headerlink\" title=\"四、边框\"></a>四、边框</h3></li>\n<li>border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px  边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后</li>\n</ol>\n<p>面的值可以省略不写）<br>    – 0 0 0 0 / 0 0 0 0;  标准写法  分别表示1、2、3、4 位置的X/Y轴半径<br>    – 0 0 0 / 0 0 0; 简写  分别表示 1、2/4、3 位置的X/Y轴半径<br>    – 0 0 / 0 0; 简写  分别表示 1/3、2/4 位置的X/Y轴半径<br>    – 0 / 0; 简写  表示四个位置的X/Y轴半径</p>\n<ol>\n<li>box-shadow: 0px 0px 0px red  盒子阴影<br>– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）<br>– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）<br>– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊<br>– 第四个参数表示阴影颜色</li>\n<li>border-image: url(“”) 27 stretch repeat  边框背景图片（复合属性，也可以拆开写）<br>– 第一个参数表示边框背景图片的引入地址<br>– 第二个参数表示引入的图片中以什么样的尺寸来分割成九份<br>– 第三个参数表示X轴方向的填充方式（round，repeat，stretch）<br>– 第四个参数表示Y轴方向的填充方式（round，repeat，stretch）<br>– border-image-source: url(“”);<br>– border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白）<br>– border-image-repeat: stretch repeat round;<br>– border-image-width: 20px;<br>– border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素.<br>说明:  stretch拉伸  repeat平铺(两边会被裁剪)   round显示全部浏览器自动调整</li>\n</ol>\n<h3 id=\"五、盒模型\"><a href=\"#五、盒模型\" class=\"headerlink\" title=\"五、盒模型\"></a>五、盒模型</h3><ol>\n<li>box-sizing:border-box （以边框方式计算盒子的大小）<br>– border-box  设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border<br>– content-box  设置为border-box以后，我们设置的盒子（width/height）即为content（默认）<br>说明:  默认的box-sizing:content-box;优先保证内容的大小  对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.<h3 id=\"六、背景\"><a href=\"#六、背景\" class=\"headerlink\" title=\"六、背景\"></a>六、背景</h3></li>\n<li>background-size: 10px 10px  背景图片的尺寸大小（也可以设置为contain、cover）<br>–contain  图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白）<br>–cover  图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子）</li>\n<li>background-position: 10px 10px/top left  背景图片定位</li>\n<li>background-origin:  背景图片的开始位置<br>–border-box  让图片背景在border开始的位置开始显示<br>–padding-box  让图片背景在padding开始的位置开始显示（默认）<br>–content-box  让图片背景在content开始的位置开始显示</li>\n<li>background-clip:<br>–content-box  内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）<br>–padding-box  padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）</li>\n<li>background-image<br>–background-image:url(“”),url(“”),…,…;  多张背景图片以逗号分隔可以引入多张背景图片<br>–background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的.</li>\n</ol>\n<h3 id=\"七、渐变\"><a href=\"#七、渐变\" class=\"headerlink\" title=\"七、渐变\"></a>七、渐变</h3><ol>\n<li>linear-gradient()  线性渐变<br>–第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg）<br>–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）<br>–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色）<br>–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）<br>–……</li>\n<li>radial-gradient()  径向渐变<br>–第一个参数表示径向渐变的范围（为半径值）<br>–第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值）<br>–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）<br>–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色）<br>–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）<br>–……</li>\n<li><a href=\"http://www.colorzilla.com/gradient-editor/\" target=\"_blank\" rel=\"noopener\">http://www.colorzilla.com/gradient-editor/</a>  自动生成全兼容渐变代码<br>具体说明:  <h4 id=\"渐变\"><a href=\"#渐变\" class=\"headerlink\" title=\"渐变\"></a>渐变</h4><ol>\n<li>线性渐变<br>background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色<br>方向还可以用度数但是要带单位deg 0deg向上 90deg向右<br>background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于       整个盒子)background:linear-</li>\n</ol>\n</li>\n</ol>\n<p>gradient(90deg,yellow 25%,green 50%);<br>       还可以个多个值:例如  background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%);<br>       方向 颜色 范围</p>\n<ol>\n<li>径向渐变<br> 有原点(圆心) 两种颜色<br> background-image:radial=gradient(120px at center center,yellow,green);<br> 第一个参数是半径  后面两个是坐标 左后是颜色<br> background-image:radial=gradient(120px 80px at center center,yellow,green);<br> 写了两个半径就是椭圆  后面坐标可以用单词 给百分比 和具体的数值<br> background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样<br>总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;<h3 id=\"八、过渡动画\"><a href=\"#八、过渡动画\" class=\"headerlink\" title=\"八、过渡动画\"></a>八、过渡动画</h3><ol>\n<li>transition: all 1s 1s ease  过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变）<br>–后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间<br>–一般大家默认写成（属性、过渡时间、延迟时间、线性）<br>–第一个参数为transition-property  是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all）<br>–第二个参数为transition-duration  是完成本次过渡动画的总时间<br>–第三个参数为transition-delay  是本次动画开始是的延迟时间<br>–第四个参数为transition-timing-function  是本次动画的动画线性（默认为ease）</li>\n<li><a href=\"http://cubic-bezier.com/#.17,.67,.83,.67\" target=\"_blank\" rel=\"noopener\">http://cubic-bezier.com/#.17,.67,.83,.67</a>  生成过渡线性（贝塞尔曲线）<br>说明:动画线性的其他值<br>linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)<br>ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)<br>ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)<br>ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)<br>ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)<br>这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画   加在element的时候会执行两次动画</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"九、2D转换\"><a href=\"#九、2D转换\" class=\"headerlink\" title=\"九、2D转换\"></a>九、2D转换</h3><p>  所有2D转换都是transform属性，只不过后面的值不一样</p>\n<ol>\n<li>transform: translate  2D转换中的位移<br>–translateX(20px) 向X轴正方向移动20px<br>–translateY(20px) 向Y轴正方向移动20px</li>\n<li>transform: scale  2D转换中的缩放<br>–scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）<br>–scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）</li>\n<li>transform: rotate  2D转换中的旋转<br>–rotate(360deg)  旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值)</li>\n<li>transform: skew  2D转换中的倾斜（扭曲）<br>–skewX(360deg)  顺着X轴进行倾斜（不常用）<br>–skewY(360deg)  顺着Y轴进行倾斜（不常用）<br>注意:transform:translatex(x);<pre><code> transform:translatex(y);\n上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y);\n</code></pre></li>\n</ol>\n<h3 id=\"十、3D转换\"><a href=\"#十、3D转换\" class=\"headerlink\" title=\"十、3D转换\"></a>十、3D转换</h3><ol>\n<li>transform: translate 3D转换中的位移<br>–translateX(20px) 向X轴正方向移动20px<br>–translateY(20px) 向Y轴正方向移动20px<br>–translateZ(20px) 向Z轴正方向移动20px</li>\n<li>transform: rotate  2D转换中的旋转<br>–rotateX(360deg)  旋转一定的角度（延X轴进行一定的角度旋转）<br>–rotateY(360deg)  旋转一定的角度（延Y轴进行一定的角度旋转）<br>–rotateZ(360deg)  旋转一定的角度 ( 延Z轴进行一定的角度旋转 )<pre><code>注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转\n</code></pre></li>\n<li>transform-origin: left bottom  改变旋转轴的位置<br> 第一个参数可以为 top bottom left right<br> 第一个参数可以为 top bottom left right<br> 这里的参数还可以设置像素值</li>\n<li>transform-style: preserve-3d  设置在父级盒子上，让其子元素在3D效果下</li>\n<li><p>perspective: 600px  进行600px距离的透视效果，距离越大效果越不明显</p>\n<p>注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() …等，其顺序会影转换的效果。</p>\n<pre><code>当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate();\n那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示\n</code></pre><p> 具体例子<br>如:.rocket {</p>\n<pre><code>height: 190px;\nwidth: 100px;\nposition: absolute;\nbottom: 0;\ntransform:  translate(0, 0) rotate(30deg)  ;\ntransition: transform 1s;\n</code></pre><p>   }<br>   section:hover .rocket{</p>\n<pre><code>transform:translate(1000px, -500px) rotate(900deg) ;\n</code></pre><p>   }</p>\n</li>\n</ol>\n<h3 id=\"十一、帧动画\"><a href=\"#十一、帧动画\" class=\"headerlink\" title=\"十一、帧动画\"></a>十一、帧动画</h3><ol>\n<li>@keyframes 名字{}  是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子<br>–{<br>  from{<pre><code>    from中如果不设置,默认使用的是,初始状态\n}\n</code></pre>  to{<pre><code>    to中设置的是结束时的状态\n}\n</code></pre>}<br>–{<br>  0%{<pre><code>0%中如果不设置,默认使用的是,初始状态\n</code></pre>   }<br>  50%{<pre><code>50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致\n</code></pre>   }<br>  100%{<pre><code>100%中设置的是结束时的状态\n</code></pre>   }<br>}</li>\n<li>animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画</li>\n<li>animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成</li>\n<li>animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始</li>\n<li>animation-iteration-count: infinite;  执行次数，是指本次动画执行多少次，infinite为无限</li>\n<li>animation-timing-function: linear;  是指动画执行的线性(step(5)分布执行)</li>\n<li>animation-fill-mode: forwards;  是指动画结束时的状态<br>–backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态<br>–forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态<br>–both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态</li>\n<li>animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置<br>–normal 是指每次动画都是正向执行<br>–reverse 是指每次动画都是反向执行<br>–alternate 是指多次动画时以正向开始，并以（正、反、正…）的顺序执行下去<br>–alternate-reverse 是指多次动画时以反向开始，并以（反、正、反…）的顺序执行下去</li>\n<li>animation-play-state: running; 是指动画的暂停与播放<br>–running 是指动画播放<br>–paused 是指动画暂停<br>(用js暂停动画dom.style.animationPlayState=’paused’;)</li>\n<li>连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停<br>连写注意:    复合写法<pre><code>1属性的顺序是可以随意调换的\n2第一次出现的时间是动画持续时间\n3第二个出现的时间是延迟时间\n4如果只设置一个时间 默认就是动画持续事件\n</code></pre><h3 id=\"十二、flex弹性盒子\"><a href=\"#十二、flex弹性盒子\" class=\"headerlink\" title=\"十二、flex弹性盒子\"></a>十二、flex弹性盒子</h3></li>\n<li>display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下</li>\n<li>justify-content: flex-start;  设置在父级盒子上，表示主轴方向上的分布排列<br>–flex-start 这是默认值，是从开始位向结束位依次排列<br>–flex-end 是从结束位向开始位依次排列<br>–center 是居中显示<br>–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等<br>–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍<br>说明:space-between  左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值<pre><code>space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧\n</code></pre></li>\n<li>align-items: stretch;  设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用<br>–stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突<br>–flex-start 排在开始位<br>–flex-end 排在结束位<br>–center 是居中显示</li>\n<li>align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效)<br>–flex-start 是从开始位向结束位依次排列<br>–flex-end 是从结束位向开始位依次排列<br>–center 是居中显示<br>–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等<br>–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍</li>\n<li>flex-direction: row;  改变主轴的方向<br>–row 是默认值，是主轴从左到右的方向排列,开始位在最左侧<br>–column 是主轴从上到下的方向排列，开始位是最上方<br>–row-reverse 是主轴从右到左的方向排列,开始位在最右侧<br>–column-reverse 是主轴从下到上的方向排列，开始位是最下方</li>\n<li>flex-wrap:nowrap; 是否允许换行<br>–nowrap 是不允许换行，是默认值<br>–wrap 是允许换行</li>\n<li>align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置<br>–flex-start 排在开始位<br>–flex-end 排在结束位<br>–center 是居中显示</li>\n<li>order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1</li>\n<li>flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重</li>\n</ol>\n<h3 id=\"零碎知识点\"><a href=\"#零碎知识点\" class=\"headerlink\" title=\"零碎知识点:\"></a>零碎知识点:</h3><ol>\n<li>-webkit-user-select:none;设置某元素的文字不能被选中.</li>\n<li>实现自定义三角形<br>.box {<br>  height: 0;<br> width: 0;<br> border: 50px solid;<br> border-color: yellow transparent transparent transparent;<br> margin: 50px auto<br>}</li>\n<li>position:absolute;<br>top:0;<br>left:0;<br>right:0;<br>bottom:0;<br>相当于height:100%;width:100%;但是元素必须加绝对定位</li>\n<li>backface-visibility:hidden;后面隐藏</li>\n</ol>\n"},{"title":"JavaScript栈(Stack)","_content":"\n### 一、概念\n- 栈：后进先出。新添加和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫栈底，在栈里，新元素都靠近栈顶，旧元素靠近栈底。\n\n### 二、实现方式\n#### 1.基于数组方式实现的栈\n```\nclass StackArray {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  clear() {\n    this.items = [];\n  }\n\n  toArray() {\n    return this.items;\n  }\n\n  toString() {\n    return this.items.toString();\n  }\n}\n\n```\n\n#### 2.基于对象方式实现的栈\n```\nclass Stack {\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    /* while (!this.isEmpty()) {\n        this.pop();\n      } */\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`;\n    for (let i = 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n```\n\n### 三、保护数据结构内部元素\n- 因为我们能使用JavaScript中in操作符(for..in)、Object.keys()和Object.getOwnPropertyNames()来获取对象里面的属性和方法，我们把自己的属性和方法设置为私有，那么我们要了解一门新的基础数据类型Symbol。\n#### 先了解基础数据类型Symbol\n- 使用Symbol定义的属性名不能被外部(for..in)、Object.keys()和Object.getOwnPropertyNames()访问，但是会被Object.getOwnPropertySymbols(Stack)访问。\n```\nconst _items = Symbol('stackItems');\n\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n\n  push(element) {\n    this[_items].push(element);\n  }\n\n  pop() {\n    return this[_items].pop();\n  }\n\n  peek() {\n    return this[_items][this[_items].length - 1];\n  }\n\n  isEmpty() {\n    return this[_items].length === 0;\n  }\n\n  size() {\n    return this[_items].length;\n  }\n\n  clear() {\n    this[_items] = [];\n  }\n\n  print() {\n    console.log(this.toString());\n  }\n\n  toString() {\n    return this[_items].toString();\n  }\n}\n\nconst stack = new Stack();\nconst objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 5, 8, 1\n\n\n```\n\n#### 使用WeakMap实现私有\n- 缺点：采用这种方式代码可读性差，扩展该类时无法继承私有属性。\n\n```\n\nconst _items = new WeakMap();\nconst _count = new WeakMap();\n\nclass Stack {\n  constructor() {\n    _count.set(this, 0);\n    _items.set(this, {});\n  }\n\n  push(element) {\n    const items = _items.get(this);\n    const count = _count.get(this);\n    items[count] = element;\n    _count.set(this, count + 1);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const items = _items.get(this);\n    let count = _count.get(this);\n    count--;\n    _count.set(this, count);\n    const result = items[count];\n    delete items[count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const items = _items.get(this);\n    const count = _count.get(this);\n    return items[count - 1];\n  }\n\n  isEmpty() {\n    return _count.get(this) === 0;\n  }\n\n  size() {\n    return _count.get(this);\n  }\n\n  clear() {\n    /* while (!this.isEmpty()) {\n        this.pop();\n      } */\n    _count.set(this, 0);\n    _items.set(this, {});\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const items = _items.get(this);\n    const count = _count.get(this);\n    let objString = `${items[0]}`;\n    for (let i = 1; i < count; i++) {\n      objString = `${objString},${items[i]}`;\n    }\n    return objString;\n  }\n}\n\n```","source":"_posts/DataStructure/JavaScript栈(Stack).md","raw":"---\ntitle: JavaScript栈(Stack)\ncategories: ['数据结构']\ntags: ['JavaScript'] \n---\n\n### 一、概念\n- 栈：后进先出。新添加和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫栈底，在栈里，新元素都靠近栈顶，旧元素靠近栈底。\n\n### 二、实现方式\n#### 1.基于数组方式实现的栈\n```\nclass StackArray {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  clear() {\n    this.items = [];\n  }\n\n  toArray() {\n    return this.items;\n  }\n\n  toString() {\n    return this.items.toString();\n  }\n}\n\n```\n\n#### 2.基于对象方式实现的栈\n```\nclass Stack {\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    /* while (!this.isEmpty()) {\n        this.pop();\n      } */\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`;\n    for (let i = 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n\n```\n\n### 三、保护数据结构内部元素\n- 因为我们能使用JavaScript中in操作符(for..in)、Object.keys()和Object.getOwnPropertyNames()来获取对象里面的属性和方法，我们把自己的属性和方法设置为私有，那么我们要了解一门新的基础数据类型Symbol。\n#### 先了解基础数据类型Symbol\n- 使用Symbol定义的属性名不能被外部(for..in)、Object.keys()和Object.getOwnPropertyNames()访问，但是会被Object.getOwnPropertySymbols(Stack)访问。\n```\nconst _items = Symbol('stackItems');\n\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n\n  push(element) {\n    this[_items].push(element);\n  }\n\n  pop() {\n    return this[_items].pop();\n  }\n\n  peek() {\n    return this[_items][this[_items].length - 1];\n  }\n\n  isEmpty() {\n    return this[_items].length === 0;\n  }\n\n  size() {\n    return this[_items].length;\n  }\n\n  clear() {\n    this[_items] = [];\n  }\n\n  print() {\n    console.log(this.toString());\n  }\n\n  toString() {\n    return this[_items].toString();\n  }\n}\n\nconst stack = new Stack();\nconst objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 5, 8, 1\n\n\n```\n\n#### 使用WeakMap实现私有\n- 缺点：采用这种方式代码可读性差，扩展该类时无法继承私有属性。\n\n```\n\nconst _items = new WeakMap();\nconst _count = new WeakMap();\n\nclass Stack {\n  constructor() {\n    _count.set(this, 0);\n    _items.set(this, {});\n  }\n\n  push(element) {\n    const items = _items.get(this);\n    const count = _count.get(this);\n    items[count] = element;\n    _count.set(this, count + 1);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const items = _items.get(this);\n    let count = _count.get(this);\n    count--;\n    _count.set(this, count);\n    const result = items[count];\n    delete items[count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const items = _items.get(this);\n    const count = _count.get(this);\n    return items[count - 1];\n  }\n\n  isEmpty() {\n    return _count.get(this) === 0;\n  }\n\n  size() {\n    return _count.get(this);\n  }\n\n  clear() {\n    /* while (!this.isEmpty()) {\n        this.pop();\n      } */\n    _count.set(this, 0);\n    _items.set(this, {});\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const items = _items.get(this);\n    const count = _count.get(this);\n    let objString = `${items[0]}`;\n    for (let i = 1; i < count; i++) {\n      objString = `${objString},${items[i]}`;\n    }\n    return objString;\n  }\n}\n\n```","slug":"DataStructure/JavaScript栈(Stack)","published":1,"date":"2019-06-14T06:24:30.000Z","updated":"2019-06-14T07:34:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0j600347xuq3u2x2ghf","content":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>栈：后进先出。新添加和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫栈底，在栈里，新元素都靠近栈顶，旧元素靠近栈底。</li>\n</ul>\n<h3 id=\"二、实现方式\"><a href=\"#二、实现方式\" class=\"headerlink\" title=\"二、实现方式\"></a>二、实现方式</h3><h4 id=\"1-基于数组方式实现的栈\"><a href=\"#1-基于数组方式实现的栈\" class=\"headerlink\" title=\"1.基于数组方式实现的栈\"></a>1.基于数组方式实现的栈</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StackArray &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    return this.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    return this.items[this.items.length - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.items.length === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toArray() &#123;</span><br><span class=\"line\">    return this.items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return this.items.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-基于对象方式实现的栈\"><a href=\"#2-基于对象方式实现的栈\" class=\"headerlink\" title=\"2.基于对象方式实现的栈\"></a>2.基于对象方式实现的栈</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.count--;</span><br><span class=\"line\">    const result = this.items[this.count];</span><br><span class=\"line\">    delete this.items[this.count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.count === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    /* while (!this.isEmpty()) &#123;</span><br><span class=\"line\">        this.pop();</span><br><span class=\"line\">      &#125; */</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、保护数据结构内部元素\"><a href=\"#三、保护数据结构内部元素\" class=\"headerlink\" title=\"三、保护数据结构内部元素\"></a>三、保护数据结构内部元素</h3><ul>\n<li>因为我们能使用JavaScript中in操作符(for..in)、Object.keys()和Object.getOwnPropertyNames()来获取对象里面的属性和方法，我们把自己的属性和方法设置为私有，那么我们要了解一门新的基础数据类型Symbol。<h4 id=\"先了解基础数据类型Symbol\"><a href=\"#先了解基础数据类型Symbol\" class=\"headerlink\" title=\"先了解基础数据类型Symbol\"></a>先了解基础数据类型Symbol</h4></li>\n<li>使用Symbol定义的属性名不能被外部(for..in)、Object.keys()和Object.getOwnPropertyNames()访问，但是会被Object.getOwnPropertySymbols(Stack)访问。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const _items = Symbol(&apos;stackItems&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this[_items].push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    return this[_items].pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    return this[_items][this[_items].length - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this[_items].length === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this[_items].length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(this.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return this[_items].toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const stack = new Stack();</span><br><span class=\"line\">const objectSymbols = Object.getOwnPropertySymbols(stack);</span><br><span class=\"line\">console.log(objectSymbols.length); // 1</span><br><span class=\"line\">console.log(objectSymbols); // [Symbol()]</span><br><span class=\"line\">console.log(objectSymbols[0]); // Symbol()</span><br><span class=\"line\">stack[objectSymbols[0]].push(1);</span><br><span class=\"line\">stack.print(); // 5, 8, 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"使用WeakMap实现私有\"><a href=\"#使用WeakMap实现私有\" class=\"headerlink\" title=\"使用WeakMap实现私有\"></a>使用WeakMap实现私有</h4><ul>\n<li>缺点：采用这种方式代码可读性差，扩展该类时无法继承私有属性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const _items = new WeakMap();</span><br><span class=\"line\">const _count = new WeakMap();</span><br><span class=\"line\"></span><br><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    _count.set(this, 0);</span><br><span class=\"line\">    _items.set(this, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    items[count] = element;</span><br><span class=\"line\">    _count.set(this, count + 1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    let count = _count.get(this);</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    _count.set(this, count);</span><br><span class=\"line\">    const result = items[count];</span><br><span class=\"line\">    delete items[count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    return items[count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return _count.get(this) === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return _count.get(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    /* while (!this.isEmpty()) &#123;</span><br><span class=\"line\">        this.pop();</span><br><span class=\"line\">      &#125; */</span><br><span class=\"line\">    _count.set(this, 0);</span><br><span class=\"line\">    _items.set(this, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    let objString = `$&#123;items[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h3><ul>\n<li>栈：后进先出。新添加和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫栈底，在栈里，新元素都靠近栈顶，旧元素靠近栈底。</li>\n</ul>\n<h3 id=\"二、实现方式\"><a href=\"#二、实现方式\" class=\"headerlink\" title=\"二、实现方式\"></a>二、实现方式</h3><h4 id=\"1-基于数组方式实现的栈\"><a href=\"#1-基于数组方式实现的栈\" class=\"headerlink\" title=\"1.基于数组方式实现的栈\"></a>1.基于数组方式实现的栈</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StackArray &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    return this.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    return this.items[this.items.length - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.items.length === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toArray() &#123;</span><br><span class=\"line\">    return this.items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return this.items.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-基于对象方式实现的栈\"><a href=\"#2-基于对象方式实现的栈\" class=\"headerlink\" title=\"2.基于对象方式实现的栈\"></a>2.基于对象方式实现的栈</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this.items[this.count] = element;</span><br><span class=\"line\">    this.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.count--;</span><br><span class=\"line\">    const result = this.items[this.count];</span><br><span class=\"line\">    delete this.items[this.count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.items[this.count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this.count === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    /* while (!this.isEmpty()) &#123;</span><br><span class=\"line\">        this.pop();</span><br><span class=\"line\">      &#125; */</span><br><span class=\"line\">    this.items = &#123;&#125;;</span><br><span class=\"line\">    this.count = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let objString = `$&#123;this.items[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; this.count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、保护数据结构内部元素\"><a href=\"#三、保护数据结构内部元素\" class=\"headerlink\" title=\"三、保护数据结构内部元素\"></a>三、保护数据结构内部元素</h3><ul>\n<li>因为我们能使用JavaScript中in操作符(for..in)、Object.keys()和Object.getOwnPropertyNames()来获取对象里面的属性和方法，我们把自己的属性和方法设置为私有，那么我们要了解一门新的基础数据类型Symbol。<h4 id=\"先了解基础数据类型Symbol\"><a href=\"#先了解基础数据类型Symbol\" class=\"headerlink\" title=\"先了解基础数据类型Symbol\"></a>先了解基础数据类型Symbol</h4></li>\n<li>使用Symbol定义的属性名不能被外部(for..in)、Object.keys()和Object.getOwnPropertyNames()访问，但是会被Object.getOwnPropertySymbols(Stack)访问。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const _items = Symbol(&apos;stackItems&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    this[_items].push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    return this[_items].pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    return this[_items][this[_items].length - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return this[_items].length === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return this[_items].length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    this[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(this.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return this[_items].toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const stack = new Stack();</span><br><span class=\"line\">const objectSymbols = Object.getOwnPropertySymbols(stack);</span><br><span class=\"line\">console.log(objectSymbols.length); // 1</span><br><span class=\"line\">console.log(objectSymbols); // [Symbol()]</span><br><span class=\"line\">console.log(objectSymbols[0]); // Symbol()</span><br><span class=\"line\">stack[objectSymbols[0]].push(1);</span><br><span class=\"line\">stack.print(); // 5, 8, 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"使用WeakMap实现私有\"><a href=\"#使用WeakMap实现私有\" class=\"headerlink\" title=\"使用WeakMap实现私有\"></a>使用WeakMap实现私有</h4><ul>\n<li>缺点：采用这种方式代码可读性差，扩展该类时无法继承私有属性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const _items = new WeakMap();</span><br><span class=\"line\">const _count = new WeakMap();</span><br><span class=\"line\"></span><br><span class=\"line\">class Stack &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    _count.set(this, 0);</span><br><span class=\"line\">    _items.set(this, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  push(element) &#123;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    items[count] = element;</span><br><span class=\"line\">    _count.set(this, count + 1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    let count = _count.get(this);</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    _count.set(this, count);</span><br><span class=\"line\">    const result = items[count];</span><br><span class=\"line\">    delete items[count];</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  peek() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    return items[count - 1];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    return _count.get(this) === 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  size() &#123;</span><br><span class=\"line\">    return _count.get(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    /* while (!this.isEmpty()) &#123;</span><br><span class=\"line\">        this.pop();</span><br><span class=\"line\">      &#125; */</span><br><span class=\"line\">    _count.set(this, 0);</span><br><span class=\"line\">    _items.set(this, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    if (this.isEmpty()) &#123;</span><br><span class=\"line\">      return &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const items = _items.get(this);</span><br><span class=\"line\">    const count = _count.get(this);</span><br><span class=\"line\">    let objString = `$&#123;items[0]&#125;`;</span><br><span class=\"line\">    for (let i = 1; i &lt; count; i++) &#123;</span><br><span class=\"line\">      objString = `$&#123;objString&#125;,$&#123;items[i]&#125;`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"小程序云开发","_content":"\n### 云待办\n---\n#### 数据设计\n\n#### vant weapp 引入\n- miniprogram 执行 `npm i vant-weapp -S --production`\n- 右上角点击详情勾选使用npm模块\n- 菜单栏点击工具=>构建npm","source":"_posts/小程序/小程序云开发.md","raw":"---\ntitle: 小程序云开发\ncategories: ['小程序云开发']\n---\n\n### 云待办\n---\n#### 数据设计\n\n#### vant weapp 引入\n- miniprogram 执行 `npm i vant-weapp -S --production`\n- 右上角点击详情勾选使用npm模块\n- 菜单栏点击工具=>构建npm","slug":"小程序/小程序云开发","published":1,"date":"2019-06-17T03:28:16.000Z","updated":"2019-06-17T06:56:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0jf00377xuqr4rro48i","content":"<h3 id=\"云待办\"><a href=\"#云待办\" class=\"headerlink\" title=\"云待办\"></a>云待办</h3><hr>\n<h4 id=\"数据设计\"><a href=\"#数据设计\" class=\"headerlink\" title=\"数据设计\"></a>数据设计</h4><h4 id=\"vant-weapp-引入\"><a href=\"#vant-weapp-引入\" class=\"headerlink\" title=\"vant weapp 引入\"></a>vant weapp 引入</h4><ul>\n<li>miniprogram 执行 <code>npm i vant-weapp -S --production</code></li>\n<li>右上角点击详情勾选使用npm模块</li>\n<li>菜单栏点击工具=&gt;构建npm</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"云待办\"><a href=\"#云待办\" class=\"headerlink\" title=\"云待办\"></a>云待办</h3><hr>\n<h4 id=\"数据设计\"><a href=\"#数据设计\" class=\"headerlink\" title=\"数据设计\"></a>数据设计</h4><h4 id=\"vant-weapp-引入\"><a href=\"#vant-weapp-引入\" class=\"headerlink\" title=\"vant weapp 引入\"></a>vant weapp 引入</h4><ul>\n<li>miniprogram 执行 <code>npm i vant-weapp -S --production</code></li>\n<li>右上角点击详情勾选使用npm模块</li>\n<li>菜单栏点击工具=&gt;构建npm</li>\n</ul>\n"},{"title":"javascript 面向对象：7","_content":"1. 正则表达式\n\tregular expression\n\t一个有规则的表达式\n\n\t简单的说 他就是一个用于 查找的通配符\n\n\tbook\n\tbok\n\tbouk\n\t...\n\n\tb*k 或 b?k\n\n\t将以 b 开头, 以 k 结尾的单词 全部列出来\n\n\n\t正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串\n\n\n\t\"123\"\n\t\"abc\"\n\n\t\"\\\\d\"  一个数字( 0 ~ 9 )\n \n\n2. 正则表达式对象\n\tjs 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换.\n\n\t创建正则表达式对象\n\t1) 构造函数\n\t\tvar regex = new RegExp( 正则表达式字符串[, 匹配模式] );\n\t2) 字面量\n\t\tvar regex = /正则表达式/;\n\n3. 使用正则表达式进行匹配\n\t语法:\n\t\t正则对象.test( 字符串 ) -> bool\n\t如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false\n\n\t例如: 查询一段文字中是否包含 itcast\n\n\n4. 基本元字符\n\t1> .\t\t表示任一个非换行的字符\n\t\t案例: foot\t_ 是 food, foot\t写成 foo.\n\t2> ()\t\t表示分组和提高优先级\n\t3> []\t\t表示一个字符, 出现在 [] 中的字符\n\t\t用法: [abc]\t出现 [] 中的任意一个字符\n\t\t匹配 a, 或 b, 或 c\n\t\tfoo[dt]\n\t4> |\t\t或\n\t\t用法:\t正则表达式|正则表达式\n\t\tfoot 或 food\n\t\tfoot|food\n\t\tfoo(t|d)\n\n\t扩展: \n\t\t. \t\t任意的一个字符. 没有任何限制\n\t\t[]\t\t是出现在[]中的一个字符. 认为 . 的限制级版本\n\t\t\t\t[abc]: a 或者 b 或者 c\n\t\t|\t\t可以认为是 允许使用多个字符的 匹配\n\t\t\t\ta|b|c\n\t\t\t\taa|bb|cc\n\n\t转义字符: \\\n\t\t表示点:   \\.\n\t\t表示[]:   \\[  \\]\n\t\t表示():\t  \\(  \\)\n\t\t表示\\ :   \\\\\n\n5. 限定元字符\n\t1> *\t\t紧跟前面的一个字符或一组字符出现 0 次到多次\n\t\t表示: 123333333 后面很多 3\n\t\t正则: 1233*\n\t\t\t  123 \t\t\t\t\t0 次\n\t\t\t  1233 \t\t\t\t\t1 次\n\t\t\t  12333 \t\t\t\t2 次\n\t\t\t  ...\n\t\t\t  1233333333333333333\n\n\t\t1(23)*\n\t\t表示:\n\t\t\t1 \t\t\t\t\t\t0 次\n\t\t\t123 \t\t\t\t\t1 次\n\t\t\t12323 \t\t\t\t\t2 次\n\t\t\t1232323\t\t\t\t\t3 次\n\t2> +\t\t紧跟在前面的字符出现 1 次到多次\n\t\t字符串: 123333333\n\t\t正则:   123+\n\t\t\t    123\n\t\t\t    1233\n\t\t\t    12333\n\t3> ?\t\t紧跟在前面的字符出现 0 次或 1 次\n\t\t在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串\n\t\t\thttp://.+|https://.+\n\t\t\thttps?://.+\n\t4\t{数字}\t\t紧跟在前面的字符出现指定次数\n\t\ta{3}\taaa\n\t5\t{数字,}\t\t紧跟在前面的字符至少出现指定次数\n\t\ta{3,}\taaa, aaaaaaaaa, aaaaaaaaaaaaaa, ...\n\t6 \t{数字, 数字} 紧跟在前面的字符出现的次数范围\n\t\ta{1, 3}\t\ta, aa, aaa\n\n6. 首尾正则表达式\n\t^\t\t表示必须以 xxx 开头\n\t\t\t^a    \t必须以 a 开头的字符串\n\t\t\ta \t\t表示一个字符串中只要含有 a 就可以匹配\n\n\t\t\t^a^a    非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个\n\n\t$\t\t表示 必须以 xxx 结尾\n\t\t\ta$\t\t必须以 a 结尾\n\n\t分析\t^a+$\n\n7. 案例\n\t1> 写一个正则表达式匹配 身份证号码\n\t\t身份证是 18 位数字\n\t\t省 市 区 出生年月 随机编码X\n\t\t1) 首先是要做匹配, 就一定要使用 ^ $\n\t\t2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]\n\t\t\t还可以使用 0|1|2|3|4|5|6|7|8|9\n\t\t3) 要求是 18 位. 限定 18 位, 即 {18}\n\t\t\n\t\t组合: ^[0123456789]{18}$\n\n\t\t如果最后一位是x\n\t\t前面 17 位数字: ^[0123456789]{17}$\n\t\t后面要么是数字: [0123456789]\n\t\t要么是 x: x\n\t\t写法: \t[0123456789x]\n\t\t\t\t[0123456789]|x\n\t\t\t\t0|1|2|3|4|5|6|7|8|9|x\n\n\t\t^[0123456789]{17}[0123456789x]$\n\n\t2> 匹配邮箱\n\t\t12345678901@qq.com\n\t\tabcdefg@126.com\n\t\tabcdefg@163.com\n\t\tabc@yahoo.com.cn\n\t\t.cc\n\t\t.org\n\t\t.edu\n\t\t.中文\n\t\t...\n\t\t\n\t\t名字 @ 主机名\n\n\t\t1) 是要验证邮箱, 那么就需要使用 ^ $\n\t\t2) 名字:\n\t\t\t数字与字母\n\t\t\t[0123456789]\n\t\t\t[abcdefghi...]\n\t\t\t[ABCDEFG...]\n\n\t\t\t[] 里面的字符如果是编码序号连续的可以使用连字符连接\n\t\t\t数字: [0-9]  \n\t\t\t\t  [9-0] 错误的, 编码逆序\n\t\t\t字母: [a-z]\n\t\t\t\t  [A-Z]\n\t\t\t整合: [0-9a-zA-Z]\n\n\t\t\t名字的变式方法: [0-9a-zA-Z]+\n\t\t3) 主机名\n\t\t\t主机名也是一串字符串或数字\n\t\t\t但是它多了一个 .com .cn\n\t\t\n\t\t3.1) 只有名字\t [0-9a-zA-Z]+\n\n\t\t3.2) 只含有一个 .什么\n\t\t\t开始 \\.\n\t\t\t中间 [0-9a-zA-Z]+\n\t\t\t只含有一个名字: \\.[0-9a-zA-Z]+\n\n\t\t3.3) 含有多个名字\n\t\t\t.com.con.cc.c1.c2.c3\n\t\t\t即 .什么 出现一次到多次\n\n\t\t\t(\\.[0-9a-zA-Z]+)+\n\n\t\t最后主机名可以写成\n\t\t\t[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+\n\n\t最后整合一下\n\t\t^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+$\n\n8. 匹配一个数字\n\t1> 匹配一个数字\n\t\t[0-9]+\n\t\t1) 由于是匹配, 包含 ^ $\n\t\t2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]\n\t\t3) 后面的数字就是 [0-9]\n\t\t4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*\n\t\t5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0\n\t\t6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$\n\n\t\t^(-?[1-9][0-9]*|0)$\n\n\n\t2> 匹配一个指定范围的数字\n\t\t匹配 0 ~ 255 为例\n\t\t[0-255]\t\t0, 1, 2, 5\t\t错误的\n\n\t\t如果要匹配指定范围的数字, 那么需要将字符串结构进行分类\n\t\t1) 0 要匹配的, 所以在正则表达式中有 0 这一项\n\t\t2) 任意的 2 位数, 即 [1-9][0-9]\n\t\t3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并\n\t\t4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制\n\t\t\t因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]\n\t\t5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以\n\t\t\t写成: 2[0-4][0-9]\n\t\t6) 考虑 250 到 255, 写成 25[0-5]\n\n\t\t综合一起:\n\t\t\t^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\n\n\t\t匹配赢 IPv4 \n\t\t\t127.0.0.1\n\t\t\t192.168.1.1\n\t\t^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$\n\n\t3> 匹配小数\n\t\t要求, 小数不允许以 0 结尾\n\t\t3.1415\n\t\t[0-9]*[1-9]\n\n\t\t^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$\n\n\t\t(aaa)?\t这个内容出现或不出现\n\t\t(aaa|)\t也是表达aaa可出现可不出现\n\t\t^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$\n\n\t\tjq 中有一属性过滤选择器\n\n\t\t[value=name] [value] [value !=name] ...\n\t\t了解\n\t\t\\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\]\n\n\n\n9. 简写元字符\n\t\\s\t空白字符, 包括空格, tab, 回车换行等\n\t\\S \t非空白字符\n\n\tjs 中常常使用 [\\s\\S] 表示任意字符\n\n\n\t\\w\t表示字符, 包含字母, 数字, 下划线. \n\t\\W  非字符\n\n\n\t\\d  数字\n\t\\D \t非数字\n\n\n10. 提取\n\t使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来\n\n\t语法:\n\t\t正则表达式对象.exec( 字符串 ) -> 封装成数组\n\n\t案例： 在 'abc123def456ghij789klum' 提取数字\n\n\n11. 循环提取\n\t在一个字符串中将所有复合的要求的字符串提取出来\n\t1> 正则表达式需要使用全局模式\n\t\tvar r = new RegExp( '正则', 'g' );\n\t\tvar r = /正则/g;\n\t2> 调用 exec 首先获得第一个匹配项\n\t\t再调用一次该方法, 就可以获得 第二个匹配项\n\t\t一直调用下去, 就可以得到所有的匹配项\n\t\t直到最后全部匹配完, 如果还用该方法, 则返回 null\n\n\t案例： 在 'abc123def456ghij789klum' 提取数字\n\n\t\tvar r = /\\d+/g;\n\n\t\tr.exec( str )\t\t\t=> 123\n\t\tr.exec( str )\t\t\t=> 456\n\t\tr.exec( str )\t\t\t=> 789\n\t\tr.exec( str )\t\t\t=> null\n\n\t\twhile ( res = r.exec( str ) ) {\n\t\t\t// 操作 res, 处理捕获的结果\n\t\t}\n\n\n12. 将匹配到的结果进行解析\n\t假如有一个字符串: itcast@itcast.cn\n\t匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来\n\n\t案例:\n\tvar str = '我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com'\n\t要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来\n\n\n\t// 循环提取的正则表达式\n\tvar r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+/g;\n\n\t// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可\n\n\tvar r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+)/g;\n\n\t// 注意, 正则表达式中, 分组是有编号的. 从左往右数 '('. 从 1 开始依次编号\n\t// 匹配提取的结果中, 对应的编号就可以获得分解的数据\n\n13. 匹配但是不去捕获的元字符\n\t(?:其他正则表达式内容)\n\n14. 要截取一个字符串中的一个 html 标签\n\tvar str = '123<div>456</div>78<span>9</span>0';\n\n\t1> 要截取 html 标签, 标签使用 <>. 因此正则表达式写成 <\\w+>\n\t2> 与之匹配的标签名是什么?\n\t\t如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用\n\t\t'\\数字' 的方式引用该组\n\n\t\t<(\\w+)>.*<\\/\\1>\n\n15. 贪婪模式\n\t凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.\n\n\t取消贪婪模式. 在次数限定符后面加上 ?\n\n\t注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题\n\t\t只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪\n\n\t多个贪婪在一起的时候的强度\n\n\t\\d+\\d+\\d+\n\n\t1234567\n\n\t如果取消贪婪模式\n\n\t\\d+?\\d+\\d+\n\n16. 否定元字符\n\t语法:\n\t\t[^字符]\n\t不为这些字符的字符\n\n\t[^abc]\t\t不是 a 也不是 b 也不是 c 的字符\n\n\n17. 字符串的替换\n\t语法:\n\t\t字符串.replace( 查找字符串, 替换字符串 ) -> 字符串\n\t1> 字符串替换方法\n\t\t字符串1.replace( 字符串2, 字符串3 )\n\t\t在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串\n\t\t特点: 只替换第一个找到的字符串\n\n\t\t\"aaa\".replace( 'a', 'A' ) -> 'Aaa'\n\n\t2> 正则替换\n\t\t字符串.replace( 正则表达式, 字符串 ) -> 字符串\n\n\t\t1. 简单替换\n\t\t\t'aaaaa-------bbbbbb------ccccc'.replace( /-+/, '-' )\n\t\t\t'aaaaa-------bbbbbb------ccccc'.replace( /-+/g, '-' )\n\t\t2. 分组替换\n\t\t\t可以在替换字符串中, 使用 $数字 来引用替换的数据\n\n\t\t\t'abc123'.replace( /(\\d+)/, 'd$1' ) -> 'abcd123'\n\n\t\t\t'1991-1-1'\n\t\t\t中国: 1991年1月1日\n\t\t\t欧洲: 1/1/1991\n\t\t\t... : 1991 1 1\n\n\t\t\t'1991-1-19'.replace( /(\\d+)-(\\d+)-(\\d+)/, '$1年$2月$3日' )\n\n\t3> 函数参数用法(了解)\n\t\t语法:\n\t\t\t字符串.replace( 正则表达式, fn )\n\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn'\n\t\t\t.replace( /\\w+@\\w+(\\.\\w+)+/g, '*' );\n\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn'\n\t\t\t.replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\t\t\t\treturn '*';\n\t\t\t} );\n\n\t\t// 要求 只显示 第一个字符, 其余的都是用 * 表示\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn'\n\t\t\t.replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\t\t\t\t\n\t\t\t\t// 将用户名 变成 a***** 的形式\n\t\t\t\tvar first = g1.charAt( 0 );\n\t\t\t\tvar start = [];\n\t\t\t\tfor ( var i = 0; i < g1.length - 1; i++ ) {\n\t\t\t\t\tstart.push( '*' );\n\t\t\t\t}\n\n\t\t\t\treturn first + start.join('') + '@' + g2;\n\n\t\t\t} );\n","source":"_posts/面向对象/面向对象第七天.md","raw":"---\ntitle: javascript 面向对象：7\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1. 正则表达式\n\tregular expression\n\t一个有规则的表达式\n\n\t简单的说 他就是一个用于 查找的通配符\n\n\tbook\n\tbok\n\tbouk\n\t...\n\n\tb*k 或 b?k\n\n\t将以 b 开头, 以 k 结尾的单词 全部列出来\n\n\n\t正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串\n\n\n\t\"123\"\n\t\"abc\"\n\n\t\"\\\\d\"  一个数字( 0 ~ 9 )\n \n\n2. 正则表达式对象\n\tjs 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换.\n\n\t创建正则表达式对象\n\t1) 构造函数\n\t\tvar regex = new RegExp( 正则表达式字符串[, 匹配模式] );\n\t2) 字面量\n\t\tvar regex = /正则表达式/;\n\n3. 使用正则表达式进行匹配\n\t语法:\n\t\t正则对象.test( 字符串 ) -> bool\n\t如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false\n\n\t例如: 查询一段文字中是否包含 itcast\n\n\n4. 基本元字符\n\t1> .\t\t表示任一个非换行的字符\n\t\t案例: foot\t_ 是 food, foot\t写成 foo.\n\t2> ()\t\t表示分组和提高优先级\n\t3> []\t\t表示一个字符, 出现在 [] 中的字符\n\t\t用法: [abc]\t出现 [] 中的任意一个字符\n\t\t匹配 a, 或 b, 或 c\n\t\tfoo[dt]\n\t4> |\t\t或\n\t\t用法:\t正则表达式|正则表达式\n\t\tfoot 或 food\n\t\tfoot|food\n\t\tfoo(t|d)\n\n\t扩展: \n\t\t. \t\t任意的一个字符. 没有任何限制\n\t\t[]\t\t是出现在[]中的一个字符. 认为 . 的限制级版本\n\t\t\t\t[abc]: a 或者 b 或者 c\n\t\t|\t\t可以认为是 允许使用多个字符的 匹配\n\t\t\t\ta|b|c\n\t\t\t\taa|bb|cc\n\n\t转义字符: \\\n\t\t表示点:   \\.\n\t\t表示[]:   \\[  \\]\n\t\t表示():\t  \\(  \\)\n\t\t表示\\ :   \\\\\n\n5. 限定元字符\n\t1> *\t\t紧跟前面的一个字符或一组字符出现 0 次到多次\n\t\t表示: 123333333 后面很多 3\n\t\t正则: 1233*\n\t\t\t  123 \t\t\t\t\t0 次\n\t\t\t  1233 \t\t\t\t\t1 次\n\t\t\t  12333 \t\t\t\t2 次\n\t\t\t  ...\n\t\t\t  1233333333333333333\n\n\t\t1(23)*\n\t\t表示:\n\t\t\t1 \t\t\t\t\t\t0 次\n\t\t\t123 \t\t\t\t\t1 次\n\t\t\t12323 \t\t\t\t\t2 次\n\t\t\t1232323\t\t\t\t\t3 次\n\t2> +\t\t紧跟在前面的字符出现 1 次到多次\n\t\t字符串: 123333333\n\t\t正则:   123+\n\t\t\t    123\n\t\t\t    1233\n\t\t\t    12333\n\t3> ?\t\t紧跟在前面的字符出现 0 次或 1 次\n\t\t在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串\n\t\t\thttp://.+|https://.+\n\t\t\thttps?://.+\n\t4\t{数字}\t\t紧跟在前面的字符出现指定次数\n\t\ta{3}\taaa\n\t5\t{数字,}\t\t紧跟在前面的字符至少出现指定次数\n\t\ta{3,}\taaa, aaaaaaaaa, aaaaaaaaaaaaaa, ...\n\t6 \t{数字, 数字} 紧跟在前面的字符出现的次数范围\n\t\ta{1, 3}\t\ta, aa, aaa\n\n6. 首尾正则表达式\n\t^\t\t表示必须以 xxx 开头\n\t\t\t^a    \t必须以 a 开头的字符串\n\t\t\ta \t\t表示一个字符串中只要含有 a 就可以匹配\n\n\t\t\t^a^a    非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个\n\n\t$\t\t表示 必须以 xxx 结尾\n\t\t\ta$\t\t必须以 a 结尾\n\n\t分析\t^a+$\n\n7. 案例\n\t1> 写一个正则表达式匹配 身份证号码\n\t\t身份证是 18 位数字\n\t\t省 市 区 出生年月 随机编码X\n\t\t1) 首先是要做匹配, 就一定要使用 ^ $\n\t\t2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]\n\t\t\t还可以使用 0|1|2|3|4|5|6|7|8|9\n\t\t3) 要求是 18 位. 限定 18 位, 即 {18}\n\t\t\n\t\t组合: ^[0123456789]{18}$\n\n\t\t如果最后一位是x\n\t\t前面 17 位数字: ^[0123456789]{17}$\n\t\t后面要么是数字: [0123456789]\n\t\t要么是 x: x\n\t\t写法: \t[0123456789x]\n\t\t\t\t[0123456789]|x\n\t\t\t\t0|1|2|3|4|5|6|7|8|9|x\n\n\t\t^[0123456789]{17}[0123456789x]$\n\n\t2> 匹配邮箱\n\t\t12345678901@qq.com\n\t\tabcdefg@126.com\n\t\tabcdefg@163.com\n\t\tabc@yahoo.com.cn\n\t\t.cc\n\t\t.org\n\t\t.edu\n\t\t.中文\n\t\t...\n\t\t\n\t\t名字 @ 主机名\n\n\t\t1) 是要验证邮箱, 那么就需要使用 ^ $\n\t\t2) 名字:\n\t\t\t数字与字母\n\t\t\t[0123456789]\n\t\t\t[abcdefghi...]\n\t\t\t[ABCDEFG...]\n\n\t\t\t[] 里面的字符如果是编码序号连续的可以使用连字符连接\n\t\t\t数字: [0-9]  \n\t\t\t\t  [9-0] 错误的, 编码逆序\n\t\t\t字母: [a-z]\n\t\t\t\t  [A-Z]\n\t\t\t整合: [0-9a-zA-Z]\n\n\t\t\t名字的变式方法: [0-9a-zA-Z]+\n\t\t3) 主机名\n\t\t\t主机名也是一串字符串或数字\n\t\t\t但是它多了一个 .com .cn\n\t\t\n\t\t3.1) 只有名字\t [0-9a-zA-Z]+\n\n\t\t3.2) 只含有一个 .什么\n\t\t\t开始 \\.\n\t\t\t中间 [0-9a-zA-Z]+\n\t\t\t只含有一个名字: \\.[0-9a-zA-Z]+\n\n\t\t3.3) 含有多个名字\n\t\t\t.com.con.cc.c1.c2.c3\n\t\t\t即 .什么 出现一次到多次\n\n\t\t\t(\\.[0-9a-zA-Z]+)+\n\n\t\t最后主机名可以写成\n\t\t\t[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+\n\n\t最后整合一下\n\t\t^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+$\n\n8. 匹配一个数字\n\t1> 匹配一个数字\n\t\t[0-9]+\n\t\t1) 由于是匹配, 包含 ^ $\n\t\t2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]\n\t\t3) 后面的数字就是 [0-9]\n\t\t4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*\n\t\t5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0\n\t\t6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$\n\n\t\t^(-?[1-9][0-9]*|0)$\n\n\n\t2> 匹配一个指定范围的数字\n\t\t匹配 0 ~ 255 为例\n\t\t[0-255]\t\t0, 1, 2, 5\t\t错误的\n\n\t\t如果要匹配指定范围的数字, 那么需要将字符串结构进行分类\n\t\t1) 0 要匹配的, 所以在正则表达式中有 0 这一项\n\t\t2) 任意的 2 位数, 即 [1-9][0-9]\n\t\t3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并\n\t\t4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制\n\t\t\t因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]\n\t\t5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以\n\t\t\t写成: 2[0-4][0-9]\n\t\t6) 考虑 250 到 255, 写成 25[0-5]\n\n\t\t综合一起:\n\t\t\t^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\n\n\t\t匹配赢 IPv4 \n\t\t\t127.0.0.1\n\t\t\t192.168.1.1\n\t\t^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$\n\n\t3> 匹配小数\n\t\t要求, 小数不允许以 0 结尾\n\t\t3.1415\n\t\t[0-9]*[1-9]\n\n\t\t^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$\n\n\t\t(aaa)?\t这个内容出现或不出现\n\t\t(aaa|)\t也是表达aaa可出现可不出现\n\t\t^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$\n\n\t\tjq 中有一属性过滤选择器\n\n\t\t[value=name] [value] [value !=name] ...\n\t\t了解\n\t\t\\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\]\n\n\n\n9. 简写元字符\n\t\\s\t空白字符, 包括空格, tab, 回车换行等\n\t\\S \t非空白字符\n\n\tjs 中常常使用 [\\s\\S] 表示任意字符\n\n\n\t\\w\t表示字符, 包含字母, 数字, 下划线. \n\t\\W  非字符\n\n\n\t\\d  数字\n\t\\D \t非数字\n\n\n10. 提取\n\t使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来\n\n\t语法:\n\t\t正则表达式对象.exec( 字符串 ) -> 封装成数组\n\n\t案例： 在 'abc123def456ghij789klum' 提取数字\n\n\n11. 循环提取\n\t在一个字符串中将所有复合的要求的字符串提取出来\n\t1> 正则表达式需要使用全局模式\n\t\tvar r = new RegExp( '正则', 'g' );\n\t\tvar r = /正则/g;\n\t2> 调用 exec 首先获得第一个匹配项\n\t\t再调用一次该方法, 就可以获得 第二个匹配项\n\t\t一直调用下去, 就可以得到所有的匹配项\n\t\t直到最后全部匹配完, 如果还用该方法, 则返回 null\n\n\t案例： 在 'abc123def456ghij789klum' 提取数字\n\n\t\tvar r = /\\d+/g;\n\n\t\tr.exec( str )\t\t\t=> 123\n\t\tr.exec( str )\t\t\t=> 456\n\t\tr.exec( str )\t\t\t=> 789\n\t\tr.exec( str )\t\t\t=> null\n\n\t\twhile ( res = r.exec( str ) ) {\n\t\t\t// 操作 res, 处理捕获的结果\n\t\t}\n\n\n12. 将匹配到的结果进行解析\n\t假如有一个字符串: itcast@itcast.cn\n\t匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来\n\n\t案例:\n\tvar str = '我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com'\n\t要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来\n\n\n\t// 循环提取的正则表达式\n\tvar r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+/g;\n\n\t// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可\n\n\tvar r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+)/g;\n\n\t// 注意, 正则表达式中, 分组是有编号的. 从左往右数 '('. 从 1 开始依次编号\n\t// 匹配提取的结果中, 对应的编号就可以获得分解的数据\n\n13. 匹配但是不去捕获的元字符\n\t(?:其他正则表达式内容)\n\n14. 要截取一个字符串中的一个 html 标签\n\tvar str = '123<div>456</div>78<span>9</span>0';\n\n\t1> 要截取 html 标签, 标签使用 <>. 因此正则表达式写成 <\\w+>\n\t2> 与之匹配的标签名是什么?\n\t\t如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用\n\t\t'\\数字' 的方式引用该组\n\n\t\t<(\\w+)>.*<\\/\\1>\n\n15. 贪婪模式\n\t凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.\n\n\t取消贪婪模式. 在次数限定符后面加上 ?\n\n\t注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题\n\t\t只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪\n\n\t多个贪婪在一起的时候的强度\n\n\t\\d+\\d+\\d+\n\n\t1234567\n\n\t如果取消贪婪模式\n\n\t\\d+?\\d+\\d+\n\n16. 否定元字符\n\t语法:\n\t\t[^字符]\n\t不为这些字符的字符\n\n\t[^abc]\t\t不是 a 也不是 b 也不是 c 的字符\n\n\n17. 字符串的替换\n\t语法:\n\t\t字符串.replace( 查找字符串, 替换字符串 ) -> 字符串\n\t1> 字符串替换方法\n\t\t字符串1.replace( 字符串2, 字符串3 )\n\t\t在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串\n\t\t特点: 只替换第一个找到的字符串\n\n\t\t\"aaa\".replace( 'a', 'A' ) -> 'Aaa'\n\n\t2> 正则替换\n\t\t字符串.replace( 正则表达式, 字符串 ) -> 字符串\n\n\t\t1. 简单替换\n\t\t\t'aaaaa-------bbbbbb------ccccc'.replace( /-+/, '-' )\n\t\t\t'aaaaa-------bbbbbb------ccccc'.replace( /-+/g, '-' )\n\t\t2. 分组替换\n\t\t\t可以在替换字符串中, 使用 $数字 来引用替换的数据\n\n\t\t\t'abc123'.replace( /(\\d+)/, 'd$1' ) -> 'abcd123'\n\n\t\t\t'1991-1-1'\n\t\t\t中国: 1991年1月1日\n\t\t\t欧洲: 1/1/1991\n\t\t\t... : 1991 1 1\n\n\t\t\t'1991-1-19'.replace( /(\\d+)-(\\d+)-(\\d+)/, '$1年$2月$3日' )\n\n\t3> 函数参数用法(了解)\n\t\t语法:\n\t\t\t字符串.replace( 正则表达式, fn )\n\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn'\n\t\t\t.replace( /\\w+@\\w+(\\.\\w+)+/g, '*' );\n\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn'\n\t\t\t.replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\t\t\t\treturn '*';\n\t\t\t} );\n\n\t\t// 要求 只显示 第一个字符, 其余的都是用 * 表示\n\t\t'我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn'\n\t\t\t.replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\t\t\t\t\n\t\t\t\t// 将用户名 变成 a***** 的形式\n\t\t\t\tvar first = g1.charAt( 0 );\n\t\t\t\tvar start = [];\n\t\t\t\tfor ( var i = 0; i < g1.length - 1; i++ ) {\n\t\t\t\t\tstart.push( '*' );\n\t\t\t\t}\n\n\t\t\t\treturn first + start.join('') + '@' + g2;\n\n\t\t\t} );\n","slug":"面向对象/面向对象第七天","published":1,"date":"2016-12-26T01:00:48.000Z","updated":"2019-04-26T06:39:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0jg00387xuql1z2zg98","content":"<ol>\n<li><p>正则表达式<br> regular expression<br> 一个有规则的表达式</p>\n<p> 简单的说 他就是一个用于 查找的通配符</p>\n<p> book<br> bok<br> bouk<br> …</p>\n<p> b*k 或 b?k</p>\n<p> 将以 b 开头, 以 k 结尾的单词 全部列出来</p>\n</li>\n</ol>\n<pre><code>正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串\n\n\n&quot;123&quot;\n&quot;abc&quot;\n\n&quot;\\\\d&quot;  一个数字( 0 ~ 9 )\n</code></pre><ol>\n<li><p>正则表达式对象<br> js 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换.</p>\n<p> 创建正则表达式对象<br> 1) 构造函数</p>\n<pre><code>var regex = new RegExp( 正则表达式字符串[, 匹配模式] );\n</code></pre><p> 2) 字面量</p>\n<pre><code>var regex = /正则表达式/;\n</code></pre></li>\n<li><p>使用正则表达式进行匹配<br> 语法:</p>\n<pre><code>正则对象.test( 字符串 ) -&gt; bool\n</code></pre><p> 如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false</p>\n<p> 例如: 查询一段文字中是否包含 itcast</p>\n</li>\n</ol>\n<ol>\n<li><p>基本元字符<br> 1&gt; .        表示任一个非换行的字符</p>\n<pre><code>案例: foot    _ 是 food, foot    写成 foo.\n</code></pre><p> 2&gt; ()        表示分组和提高优先级<br> 3&gt; []        表示一个字符, 出现在 [] 中的字符</p>\n<pre><code>用法: [abc]    出现 [] 中的任意一个字符\n匹配 a, 或 b, 或 c\nfoo[dt]\n</code></pre><p> 4&gt; |        或</p>\n<pre><code>用法:    正则表达式|正则表达式\nfoot 或 food\nfoot|food\nfoo(t|d)\n</code></pre><p> 扩展: </p>\n<pre><code>.         任意的一个字符. 没有任何限制\n[]        是出现在[]中的一个字符. 认为 . 的限制级版本\n        [abc]: a 或者 b 或者 c\n|        可以认为是 允许使用多个字符的 匹配\n        a|b|c\n        aa|bb|cc\n</code></pre><p> 转义字符: \\</p>\n<pre><code>表示点:   \\.\n表示[]:   \\[  \\]\n表示():      \\(  \\)\n表示\\ :   \\\\\n</code></pre></li>\n<li><p>限定元字符<br> 1&gt; *        紧跟前面的一个字符或一组字符出现 0 次到多次</p>\n<pre><code>表示: 123333333 后面很多 3\n正则: 1233*\n      123                     0 次\n      1233                     1 次\n      12333                 2 次\n      ...\n      1233333333333333333\n\n1(23)*\n表示:\n    1                         0 次\n    123                     1 次\n    12323                     2 次\n    1232323                    3 次\n</code></pre><p> 2&gt; +        紧跟在前面的字符出现 1 次到多次</p>\n<pre><code>字符串: 123333333\n正则:   123+\n        123\n        1233\n        12333\n</code></pre><p> 3&gt; ?        紧跟在前面的字符出现 0 次或 1 次</p>\n<pre><code>在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串\n    http://.+|https://.+\n    https?://.+\n</code></pre><p> 4    {数字}        紧跟在前面的字符出现指定次数</p>\n<pre><code>a{3}    aaa\n</code></pre><p> 5    {数字,}        紧跟在前面的字符至少出现指定次数</p>\n<pre><code>a{3,}    aaa, aaaaaaaaa, aaaaaaaaaaaaaa, ...\n</code></pre><p> 6     {数字, 数字} 紧跟在前面的字符出现的次数范围</p>\n<pre><code>a{1, 3}        a, aa, aaa\n</code></pre></li>\n<li><p>首尾正则表达式<br> ^        表示必须以 xxx 开头</p>\n<pre><code>^a        必须以 a 开头的字符串\na         表示一个字符串中只要含有 a 就可以匹配\n\n^a^a    非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个\n</code></pre><p> $        表示 必须以 xxx 结尾</p>\n<pre><code>a$        必须以 a 结尾\n</code></pre><p> 分析    ^a+$</p>\n</li>\n<li><p>案例<br> 1&gt; 写一个正则表达式匹配 身份证号码</p>\n<pre><code>身份证是 18 位数字\n省 市 区 出生年月 随机编码X\n1) 首先是要做匹配, 就一定要使用 ^ $\n2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]\n    还可以使用 0|1|2|3|4|5|6|7|8|9\n3) 要求是 18 位. 限定 18 位, 即 {18}\n\n组合: ^[0123456789]{18}$\n\n如果最后一位是x\n前面 17 位数字: ^[0123456789]{17}$\n后面要么是数字: [0123456789]\n要么是 x: x\n写法:     [0123456789x]\n        [0123456789]|x\n        0|1|2|3|4|5|6|7|8|9|x\n\n^[0123456789]{17}[0123456789x]$\n</code></pre><p> 2&gt; 匹配邮箱</p>\n<pre><code>12345678901@qq.com\nabcdefg@126.com\nabcdefg@163.com\nabc@yahoo.com.cn\n.cc\n.org\n.edu\n.中文\n...\n\n名字 @ 主机名\n\n1) 是要验证邮箱, 那么就需要使用 ^ $\n2) 名字:\n    数字与字母\n    [0123456789]\n    [abcdefghi...]\n    [ABCDEFG...]\n\n    [] 里面的字符如果是编码序号连续的可以使用连字符连接\n    数字: [0-9]  \n          [9-0] 错误的, 编码逆序\n    字母: [a-z]\n          [A-Z]\n    整合: [0-9a-zA-Z]\n\n    名字的变式方法: [0-9a-zA-Z]+\n3) 主机名\n    主机名也是一串字符串或数字\n    但是它多了一个 .com .cn\n\n3.1) 只有名字     [0-9a-zA-Z]+\n\n3.2) 只含有一个 .什么\n    开始 \\.\n    中间 [0-9a-zA-Z]+\n    只含有一个名字: \\.[0-9a-zA-Z]+\n\n3.3) 含有多个名字\n    .com.con.cc.c1.c2.c3\n    即 .什么 出现一次到多次\n\n    (\\.[0-9a-zA-Z]+)+\n\n最后主机名可以写成\n    [0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+\n</code></pre><p> 最后整合一下</p>\n<pre><code>^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+$\n</code></pre></li>\n<li><p>匹配一个数字<br> 1&gt; 匹配一个数字</p>\n<pre><code>[0-9]+\n1) 由于是匹配, 包含 ^ $\n2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]\n3) 后面的数字就是 [0-9]\n4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*\n5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0\n6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$\n\n^(-?[1-9][0-9]*|0)$\n</code></pre></li>\n</ol>\n<pre><code>2&gt; 匹配一个指定范围的数字\n    匹配 0 ~ 255 为例\n    [0-255]        0, 1, 2, 5        错误的\n\n    如果要匹配指定范围的数字, 那么需要将字符串结构进行分类\n    1) 0 要匹配的, 所以在正则表达式中有 0 这一项\n    2) 任意的 2 位数, 即 [1-9][0-9]\n    3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并\n    4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制\n        因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]\n    5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以\n        写成: 2[0-4][0-9]\n    6) 考虑 250 到 255, 写成 25[0-5]\n\n    综合一起:\n        ^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\n\n    匹配赢 IPv4 \n        127.0.0.1\n        192.168.1.1\n    ^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$\n\n3&gt; 匹配小数\n    要求, 小数不允许以 0 结尾\n    3.1415\n    [0-9]*[1-9]\n\n    ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$\n\n    (aaa)?    这个内容出现或不出现\n    (aaa|)    也是表达aaa可出现可不出现\n    ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$\n\n    jq 中有一属性过滤选择器\n\n    [value=name] [value] [value !=name] ...\n    了解\n    \\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\]\n</code></pre><ol>\n<li><p>简写元字符<br> \\s    空白字符, 包括空格, tab, 回车换行等<br> \\S     非空白字符</p>\n<p> js 中常常使用 [\\s\\S] 表示任意字符</p>\n</li>\n</ol>\n<pre><code>\\w    表示字符, 包含字母, 数字, 下划线. \n\\W  非字符\n\n\n\\d  数字\n\\D     非数字\n</code></pre><ol>\n<li><p>提取<br>使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来</p>\n<p>语法:</p>\n<pre><code>正则表达式对象.exec( 字符串 ) -&gt; 封装成数组\n</code></pre><p>案例： 在 ‘abc123def456ghij789klum’ 提取数字</p>\n</li>\n</ol>\n<ol>\n<li><p>循环提取<br>在一个字符串中将所有复合的要求的字符串提取出来<br>1&gt; 正则表达式需要使用全局模式</p>\n<pre><code>var r = new RegExp( &apos;正则&apos;, &apos;g&apos; );\nvar r = /正则/g;\n</code></pre><p>2&gt; 调用 exec 首先获得第一个匹配项</p>\n<pre><code>再调用一次该方法, 就可以获得 第二个匹配项\n一直调用下去, 就可以得到所有的匹配项\n直到最后全部匹配完, 如果还用该方法, 则返回 null\n</code></pre><p>案例： 在 ‘abc123def456ghij789klum’ 提取数字</p>\n<pre><code>var r = /\\d+/g;\n\nr.exec( str )            =&gt; 123\nr.exec( str )            =&gt; 456\nr.exec( str )            =&gt; 789\nr.exec( str )            =&gt; null\n\nwhile ( res = r.exec( str ) ) {\n    // 操作 res, 处理捕获的结果\n}\n</code></pre></li>\n</ol>\n<ol>\n<li><p>将匹配到的结果进行解析<br>假如有一个字符串: itcast@itcast.cn<br>匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来</p>\n<p>案例:<br>var str = ‘我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com’<br>要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来</p>\n</li>\n</ol>\n<pre><code>// 循环提取的正则表达式\nvar r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+/g;\n\n// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可\n\nvar r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+)/g;\n\n// 注意, 正则表达式中, 分组是有编号的. 从左往右数 &apos;(&apos;. 从 1 开始依次编号\n// 匹配提取的结果中, 对应的编号就可以获得分解的数据\n</code></pre><ol>\n<li><p>匹配但是不去捕获的元字符<br>(?:其他正则表达式内容)</p>\n</li>\n<li><p>要截取一个字符串中的一个 html 标签<br>var str = ‘123<div>456</div>78<span>9</span>0’;</p>\n<p>1&gt; 要截取 html 标签, 标签使用 &lt;&gt;. 因此正则表达式写成 &lt;\\w+&gt;<br>2&gt; 与之匹配的标签名是什么?</p>\n<pre><code>如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用\n&apos;\\数字&apos; 的方式引用该组\n\n&lt;(\\w+)&gt;.*&lt;\\/\\1&gt;\n</code></pre></li>\n<li><p>贪婪模式<br>凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.</p>\n<p>取消贪婪模式. 在次数限定符后面加上 ?</p>\n<p>注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题</p>\n<pre><code>只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪\n</code></pre><p>多个贪婪在一起的时候的强度</p>\n<p>\\d+\\d+\\d+</p>\n<p>1234567</p>\n<p>如果取消贪婪模式</p>\n<p>\\d+?\\d+\\d+</p>\n</li>\n<li><p>否定元字符<br>语法:</p>\n<pre><code>[^字符]\n</code></pre><p>不为这些字符的字符</p>\n<p>[^abc]        不是 a 也不是 b 也不是 c 的字符</p>\n</li>\n</ol>\n<ol>\n<li><p>字符串的替换<br>语法:</p>\n<pre><code>字符串.replace( 查找字符串, 替换字符串 ) -&gt; 字符串\n</code></pre><p>1&gt; 字符串替换方法</p>\n<pre><code>字符串1.replace( 字符串2, 字符串3 )\n在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串\n特点: 只替换第一个找到的字符串\n\n&quot;aaa&quot;.replace( &apos;a&apos;, &apos;A&apos; ) -&gt; &apos;Aaa&apos;\n</code></pre><p>2&gt; 正则替换</p>\n<pre><code>字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串\n\n1. 简单替换\n    &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/, &apos;-&apos; )\n    &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/g, &apos;-&apos; )\n2. 分组替换\n    可以在替换字符串中, 使用 $数字 来引用替换的数据\n\n    &apos;abc123&apos;.replace( /(\\d+)/, &apos;d$1&apos; ) -&gt; &apos;abcd123&apos;\n\n    &apos;1991-1-1&apos;\n    中国: 1991年1月1日\n    欧洲: 1/1/1991\n    ... : 1991 1 1\n\n    &apos;1991-1-19&apos;.replace( /(\\d+)-(\\d+)-(\\d+)/, &apos;$1年$2月$3日&apos; )\n</code></pre><p>3&gt; 函数参数用法(了解)</p>\n<pre><code>语法:\n    字符串.replace( 正则表达式, fn )\n\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn&apos;\n    .replace( /\\w+@\\w+(\\.\\w+)+/g, &apos;*&apos; );\n\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&apos;\n    .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n        return &apos;*&apos;;\n    } );\n\n// 要求 只显示 第一个字符, 其余的都是用 * 表示\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&apos;\n    .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\n        // 将用户名 变成 a***** 的形式\n        var first = g1.charAt( 0 );\n        var start = [];\n        for ( var i = 0; i &lt; g1.length - 1; i++ ) {\n            start.push( &apos;*&apos; );\n        }\n\n        return first + start.join(&apos;&apos;) + &apos;@&apos; + g2;\n\n    } );\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>正则表达式<br> regular expression<br> 一个有规则的表达式</p>\n<p> 简单的说 他就是一个用于 查找的通配符</p>\n<p> book<br> bok<br> bouk<br> …</p>\n<p> b*k 或 b?k</p>\n<p> 将以 b 开头, 以 k 结尾的单词 全部列出来</p>\n</li>\n</ol>\n<pre><code>正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串\n\n\n&quot;123&quot;\n&quot;abc&quot;\n\n&quot;\\\\d&quot;  一个数字( 0 ~ 9 )\n</code></pre><ol>\n<li><p>正则表达式对象<br> js 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换.</p>\n<p> 创建正则表达式对象<br> 1) 构造函数</p>\n<pre><code>var regex = new RegExp( 正则表达式字符串[, 匹配模式] );\n</code></pre><p> 2) 字面量</p>\n<pre><code>var regex = /正则表达式/;\n</code></pre></li>\n<li><p>使用正则表达式进行匹配<br> 语法:</p>\n<pre><code>正则对象.test( 字符串 ) -&gt; bool\n</code></pre><p> 如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false</p>\n<p> 例如: 查询一段文字中是否包含 itcast</p>\n</li>\n</ol>\n<ol>\n<li><p>基本元字符<br> 1&gt; .        表示任一个非换行的字符</p>\n<pre><code>案例: foot    _ 是 food, foot    写成 foo.\n</code></pre><p> 2&gt; ()        表示分组和提高优先级<br> 3&gt; []        表示一个字符, 出现在 [] 中的字符</p>\n<pre><code>用法: [abc]    出现 [] 中的任意一个字符\n匹配 a, 或 b, 或 c\nfoo[dt]\n</code></pre><p> 4&gt; |        或</p>\n<pre><code>用法:    正则表达式|正则表达式\nfoot 或 food\nfoot|food\nfoo(t|d)\n</code></pre><p> 扩展: </p>\n<pre><code>.         任意的一个字符. 没有任何限制\n[]        是出现在[]中的一个字符. 认为 . 的限制级版本\n        [abc]: a 或者 b 或者 c\n|        可以认为是 允许使用多个字符的 匹配\n        a|b|c\n        aa|bb|cc\n</code></pre><p> 转义字符: \\</p>\n<pre><code>表示点:   \\.\n表示[]:   \\[  \\]\n表示():      \\(  \\)\n表示\\ :   \\\\\n</code></pre></li>\n<li><p>限定元字符<br> 1&gt; *        紧跟前面的一个字符或一组字符出现 0 次到多次</p>\n<pre><code>表示: 123333333 后面很多 3\n正则: 1233*\n      123                     0 次\n      1233                     1 次\n      12333                 2 次\n      ...\n      1233333333333333333\n\n1(23)*\n表示:\n    1                         0 次\n    123                     1 次\n    12323                     2 次\n    1232323                    3 次\n</code></pre><p> 2&gt; +        紧跟在前面的字符出现 1 次到多次</p>\n<pre><code>字符串: 123333333\n正则:   123+\n        123\n        1233\n        12333\n</code></pre><p> 3&gt; ?        紧跟在前面的字符出现 0 次或 1 次</p>\n<pre><code>在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串\n    http://.+|https://.+\n    https?://.+\n</code></pre><p> 4    {数字}        紧跟在前面的字符出现指定次数</p>\n<pre><code>a{3}    aaa\n</code></pre><p> 5    {数字,}        紧跟在前面的字符至少出现指定次数</p>\n<pre><code>a{3,}    aaa, aaaaaaaaa, aaaaaaaaaaaaaa, ...\n</code></pre><p> 6     {数字, 数字} 紧跟在前面的字符出现的次数范围</p>\n<pre><code>a{1, 3}        a, aa, aaa\n</code></pre></li>\n<li><p>首尾正则表达式<br> ^        表示必须以 xxx 开头</p>\n<pre><code>^a        必须以 a 开头的字符串\na         表示一个字符串中只要含有 a 就可以匹配\n\n^a^a    非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个\n</code></pre><p> $        表示 必须以 xxx 结尾</p>\n<pre><code>a$        必须以 a 结尾\n</code></pre><p> 分析    ^a+$</p>\n</li>\n<li><p>案例<br> 1&gt; 写一个正则表达式匹配 身份证号码</p>\n<pre><code>身份证是 18 位数字\n省 市 区 出生年月 随机编码X\n1) 首先是要做匹配, 就一定要使用 ^ $\n2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]\n    还可以使用 0|1|2|3|4|5|6|7|8|9\n3) 要求是 18 位. 限定 18 位, 即 {18}\n\n组合: ^[0123456789]{18}$\n\n如果最后一位是x\n前面 17 位数字: ^[0123456789]{17}$\n后面要么是数字: [0123456789]\n要么是 x: x\n写法:     [0123456789x]\n        [0123456789]|x\n        0|1|2|3|4|5|6|7|8|9|x\n\n^[0123456789]{17}[0123456789x]$\n</code></pre><p> 2&gt; 匹配邮箱</p>\n<pre><code>12345678901@qq.com\nabcdefg@126.com\nabcdefg@163.com\nabc@yahoo.com.cn\n.cc\n.org\n.edu\n.中文\n...\n\n名字 @ 主机名\n\n1) 是要验证邮箱, 那么就需要使用 ^ $\n2) 名字:\n    数字与字母\n    [0123456789]\n    [abcdefghi...]\n    [ABCDEFG...]\n\n    [] 里面的字符如果是编码序号连续的可以使用连字符连接\n    数字: [0-9]  \n          [9-0] 错误的, 编码逆序\n    字母: [a-z]\n          [A-Z]\n    整合: [0-9a-zA-Z]\n\n    名字的变式方法: [0-9a-zA-Z]+\n3) 主机名\n    主机名也是一串字符串或数字\n    但是它多了一个 .com .cn\n\n3.1) 只有名字     [0-9a-zA-Z]+\n\n3.2) 只含有一个 .什么\n    开始 \\.\n    中间 [0-9a-zA-Z]+\n    只含有一个名字: \\.[0-9a-zA-Z]+\n\n3.3) 含有多个名字\n    .com.con.cc.c1.c2.c3\n    即 .什么 出现一次到多次\n\n    (\\.[0-9a-zA-Z]+)+\n\n最后主机名可以写成\n    [0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+\n</code></pre><p> 最后整合一下</p>\n<pre><code>^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+$\n</code></pre></li>\n<li><p>匹配一个数字<br> 1&gt; 匹配一个数字</p>\n<pre><code>[0-9]+\n1) 由于是匹配, 包含 ^ $\n2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]\n3) 后面的数字就是 [0-9]\n4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*\n5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0\n6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$\n\n^(-?[1-9][0-9]*|0)$\n</code></pre></li>\n</ol>\n<pre><code>2&gt; 匹配一个指定范围的数字\n    匹配 0 ~ 255 为例\n    [0-255]        0, 1, 2, 5        错误的\n\n    如果要匹配指定范围的数字, 那么需要将字符串结构进行分类\n    1) 0 要匹配的, 所以在正则表达式中有 0 这一项\n    2) 任意的 2 位数, 即 [1-9][0-9]\n    3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并\n    4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制\n        因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]\n    5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以\n        写成: 2[0-4][0-9]\n    6) 考虑 250 到 255, 写成 25[0-5]\n\n    综合一起:\n        ^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\n\n    匹配赢 IPv4 \n        127.0.0.1\n        192.168.1.1\n    ^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$\n\n3&gt; 匹配小数\n    要求, 小数不允许以 0 结尾\n    3.1415\n    [0-9]*[1-9]\n\n    ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$\n\n    (aaa)?    这个内容出现或不出现\n    (aaa|)    也是表达aaa可出现可不出现\n    ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$\n\n    jq 中有一属性过滤选择器\n\n    [value=name] [value] [value !=name] ...\n    了解\n    \\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\]\n</code></pre><ol>\n<li><p>简写元字符<br> \\s    空白字符, 包括空格, tab, 回车换行等<br> \\S     非空白字符</p>\n<p> js 中常常使用 [\\s\\S] 表示任意字符</p>\n</li>\n</ol>\n<pre><code>\\w    表示字符, 包含字母, 数字, 下划线. \n\\W  非字符\n\n\n\\d  数字\n\\D     非数字\n</code></pre><ol>\n<li><p>提取<br>使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来</p>\n<p>语法:</p>\n<pre><code>正则表达式对象.exec( 字符串 ) -&gt; 封装成数组\n</code></pre><p>案例： 在 ‘abc123def456ghij789klum’ 提取数字</p>\n</li>\n</ol>\n<ol>\n<li><p>循环提取<br>在一个字符串中将所有复合的要求的字符串提取出来<br>1&gt; 正则表达式需要使用全局模式</p>\n<pre><code>var r = new RegExp( &apos;正则&apos;, &apos;g&apos; );\nvar r = /正则/g;\n</code></pre><p>2&gt; 调用 exec 首先获得第一个匹配项</p>\n<pre><code>再调用一次该方法, 就可以获得 第二个匹配项\n一直调用下去, 就可以得到所有的匹配项\n直到最后全部匹配完, 如果还用该方法, 则返回 null\n</code></pre><p>案例： 在 ‘abc123def456ghij789klum’ 提取数字</p>\n<pre><code>var r = /\\d+/g;\n\nr.exec( str )            =&gt; 123\nr.exec( str )            =&gt; 456\nr.exec( str )            =&gt; 789\nr.exec( str )            =&gt; null\n\nwhile ( res = r.exec( str ) ) {\n    // 操作 res, 处理捕获的结果\n}\n</code></pre></li>\n</ol>\n<ol>\n<li><p>将匹配到的结果进行解析<br>假如有一个字符串: itcast@itcast.cn<br>匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来</p>\n<p>案例:<br>var str = ‘我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com’<br>要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来</p>\n</li>\n</ol>\n<pre><code>// 循环提取的正则表达式\nvar r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+/g;\n\n// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可\n\nvar r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+)/g;\n\n// 注意, 正则表达式中, 分组是有编号的. 从左往右数 &apos;(&apos;. 从 1 开始依次编号\n// 匹配提取的结果中, 对应的编号就可以获得分解的数据\n</code></pre><ol>\n<li><p>匹配但是不去捕获的元字符<br>(?:其他正则表达式内容)</p>\n</li>\n<li><p>要截取一个字符串中的一个 html 标签<br>var str = ‘123<div>456</div>78<span>9</span>0’;</p>\n<p>1&gt; 要截取 html 标签, 标签使用 &lt;&gt;. 因此正则表达式写成 &lt;\\w+&gt;<br>2&gt; 与之匹配的标签名是什么?</p>\n<pre><code>如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用\n&apos;\\数字&apos; 的方式引用该组\n\n&lt;(\\w+)&gt;.*&lt;\\/\\1&gt;\n</code></pre></li>\n<li><p>贪婪模式<br>凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.</p>\n<p>取消贪婪模式. 在次数限定符后面加上 ?</p>\n<p>注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题</p>\n<pre><code>只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪\n</code></pre><p>多个贪婪在一起的时候的强度</p>\n<p>\\d+\\d+\\d+</p>\n<p>1234567</p>\n<p>如果取消贪婪模式</p>\n<p>\\d+?\\d+\\d+</p>\n</li>\n<li><p>否定元字符<br>语法:</p>\n<pre><code>[^字符]\n</code></pre><p>不为这些字符的字符</p>\n<p>[^abc]        不是 a 也不是 b 也不是 c 的字符</p>\n</li>\n</ol>\n<ol>\n<li><p>字符串的替换<br>语法:</p>\n<pre><code>字符串.replace( 查找字符串, 替换字符串 ) -&gt; 字符串\n</code></pre><p>1&gt; 字符串替换方法</p>\n<pre><code>字符串1.replace( 字符串2, 字符串3 )\n在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串\n特点: 只替换第一个找到的字符串\n\n&quot;aaa&quot;.replace( &apos;a&apos;, &apos;A&apos; ) -&gt; &apos;Aaa&apos;\n</code></pre><p>2&gt; 正则替换</p>\n<pre><code>字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串\n\n1. 简单替换\n    &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/, &apos;-&apos; )\n    &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/g, &apos;-&apos; )\n2. 分组替换\n    可以在替换字符串中, 使用 $数字 来引用替换的数据\n\n    &apos;abc123&apos;.replace( /(\\d+)/, &apos;d$1&apos; ) -&gt; &apos;abcd123&apos;\n\n    &apos;1991-1-1&apos;\n    中国: 1991年1月1日\n    欧洲: 1/1/1991\n    ... : 1991 1 1\n\n    &apos;1991-1-19&apos;.replace( /(\\d+)-(\\d+)-(\\d+)/, &apos;$1年$2月$3日&apos; )\n</code></pre><p>3&gt; 函数参数用法(了解)</p>\n<pre><code>语法:\n    字符串.replace( 正则表达式, fn )\n\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn&apos;\n    .replace( /\\w+@\\w+(\\.\\w+)+/g, &apos;*&apos; );\n\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&apos;\n    .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n        return &apos;*&apos;;\n    } );\n\n// 要求 只显示 第一个字符, 其余的都是用 * 表示\n&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&apos;\n    .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) {\n\n        // 将用户名 变成 a***** 的形式\n        var first = g1.charAt( 0 );\n        var start = [];\n        for ( var i = 0; i &lt; g1.length - 1; i++ ) {\n            start.push( &apos;*&apos; );\n        }\n\n        return first + start.join(&apos;&apos;) + &apos;@&apos; + g2;\n\n    } );\n</code></pre></li>\n</ol>\n"},{"title":"javascript 面向对象：2","_content":"1. 为什么需要原型\n\t构造器创建对象的时候, 实际上会有成员重复\n\t如果使用 构造器 this.方法名 = function .... 方式创建对象. 那么每一个对象\n\t对应的方法就会重复. \n\n\t解决办法就是让这个方法( 函数 )共享\n\t-> 将函数写到外面, 那么 Person 在初始化对象的时候就不会再创建一个函数了.\n\t\t只需要将 外面的函数引用 交给对象即可.\n\n\t\t缺点: 一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库\n\t\t\t冲突的几率就会变大. 所以不宜采取该方法.\n\t-> 将所有的方法( 函数 )都绑定到一个对象中.\n\n\n\t-> js 原生就支持解决该问题的办法\n\t\t每一个函数都有 一个属性 prototype\n\t\t该属性指向一对象. 每一个函数的该对象都是存在. \n\t\t(重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上.\n\t\t\t如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype\n\t\t\t表示的对象中去找.\n\n\t-> prototype 就是原型之意\n\t\t\n2.  针对构造函数而言, 原型就是 构造函数的 prototype 属性, 常常将其称为 原型属性.\n\t针对实例对象而言, 原型就是 实例对象的 原型对象.\n\t\n\t例:\n\t\tfunction Person () {}\t// 有了构造函数, 和 原型\n\t\tvar p = new Person(); \t// 有了实例\n\n3. 一般如何使用原型对象\n\t-> 简单的说就是将共享的方法放到原型中, 而独有数据与行为放在当前对象里\n\t-> 例:\n\t\tPerson( name, age, gender, sayHello, eat, run )\n\t-> 直接给原型对象添加成员\n\t-> 直接替换原型对象( 注意: 手动的添加 constructor 属性, 表示对应的构造函数 ) \n\n4. __proto__\n   和 prototype 是否存在关系\n\n   早期浏览器是不支持 __proto__ \n   火狐率先使用该属性, 但是是非标准\n   基本现在的新浏览器都支持该属性\n\n   -> 访问\n   \t使用构造函数, 就使用 prototype 属性访问原型\n   \t使用实例对象, 就使用 非标准的 __proto__ 属性访问原型\n\n5. 继承\n\t-> 什么是继承\n\t\t 自己没有, 别人有, 拿过来自己用, 就好像自己的一样.\n\t-> 原型与实例对象\n\t\t在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中\n\t\t调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用\n\t\t该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象\n\t\t继承自 原型对象\n\t-> 任何一个实例, 都是继承自其原型对象的. 即原型式继承.\n\n6. 为什么需要继承\n\t-> 编程的发展\n\t\t复用( 重复使用 )\n\n\t\tdiv 标签对象\tnodeName, nodeType, nodeName, ...\n\t\t\t\t\t\tappendChild, insertBefore, getElementsByTagName, ...\n\n\t\ta 标签对象\n\n\t\tbaseElement\n\n\t-> js 运行效率\n\t\t共享特性\n\t\t复用\n\n7. 传统的编程语言的面向对象操作\n\t-> 对象: 是具有方法和属性的逻辑单元\n\t\t在 js 函数是一个特殊的数据类型( 函数在 js 是一等公民 )\n\t\tjs 对象就是键值对, 值如果是数据, 那么键值就构成属性\n\t\t如果值是函数, 那么就构成方法.\n\n\t-> 创建方式\n\t\t类 -> 实例化 -> 对象( 实例 )\n\t\t\n\t\tclass Person {\n\t\t\tpublic string name;\n\t\t\tpublic int age;\n\t\t\tpublic string gender;\n\n\t\t\tpublic void sayHello () {\n\t\t\t\t// ...\n\t\t\t}\n\t\t}\n\t\t// 类, 用来描述对象的结构, 它就是一个模板\n\n\t\tPerson p = new Person(); // 利用模板创建对象\n\n\t\t// 访问属性\n\t\tp.name\n\t\t// 调用方法\n\t\tp.sayHello();\n\n\t\t传统的面向对象编程语言, 重点需要一个\"模板\", 即 类( class )\n\n\t-> 传统的继承\n\t\t传统的继承是模板的继承.\n\n\t\tclass Student : Person {\n\t\t}\n\n\t\tStudent s = new Student();\n\t\t// 注意此时 s 就可以调用 sayHello 方法\n\t\t// 可以使用 name, age, 和 gender 属性了\n\n8. 相关概念\n\t类 class\t\t\t\t模板\t\t\t\t\t构造函数, 类名就是构造函数名\n\t子类 subclass\t\t\t派生的模板\t\t\t\t原型设置为指定对象的构造函数\n\t实例 instance\t\t\t 某个类的对象\t\t\t...\n\t实例成员(实例方法, 实例属性)\n\t静态成员\n\t\t静态方法\t\t\t...\t\t\t\t\t\t直接绑定在函数上的方法\n\t\t静态属性\t\t\t...\t\t\t\t\t\t直接绑定在函数上的属性\n\n\n\n\t// js 代码\n\tfunction Person () {\n\t\tthis.name = '黄帝';\n\t\tthis.age = 0;\n\t\tthis.gender = '男';\n\t}\n\n\t// 不叫子类, 只是一个 Student 类\n\tfunction Student() {\n\t}\n\n\t// 继承派生 成为子类\n\tStudent.prototype = new Person();\n\n\t// 即完成派生\n\tvar s = new Student();\n\ts.name // OK\n\n9. 属性访问原则( 重点 )\n\t1) 对象在调用方法或访问属性的时候, 首先在当前对象中查询. 如果有该成员使用并停止查找.\n\t2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找.\n\t3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找.\n\t...\n\t4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined.\n\n10. 如果修改原型对象中的属性值会怎样\n\t给当前对象的原型提供的属性赋值, 实际上是给当前对象添加了该属性的新成员\n\t并不会修改运行对象中的成员. \n\n11. 混入( mix )\n\t\n\tvar o1 = { name: '张三' };\n\tvar o2 = { age: 19 };\n\t-----------\n\to2.name = o1.name\n\t利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中\n\t执行混入操作， 如果o2里面有name值，则将会被覆盖。\n\t混入使得 o2 具有了 age 和 o1 中的 name. 即将 o1 混入到 o2 中\n\n\t混入也是一种继承的方式\n\t实例\n<script>\n\t\tvar o = {\n\t\t\textend:function(obj){\n\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\tfor(var k in arguments[i] ){\n\t\t\t\t\t\tthis[k]=arguments[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\to.extend({name:\"sy\"},{age:18},{sex:\"男\"});\n\n\t\tconsole.log(o);\n</script>\n\n12. 如何使用代码实现混入\n\t\n\t// 考虑需要执行, 写函数即可\n\t// 由于将 一个 对象混入到 另一个对象. 所以有两个参数\n\tfunction __mix__ ( obj, obj1 ) {\n\t\t// 如何获得 obj1 中的所有成员?\n\t\tfor ( var  k in obj1 ) {\n\t\t\tobj[ k ] = obj1[ k ];\n\t\t}\n\t}\n\n13. 原型式继承\n\t-> 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么\n\t\t只需要设置该构造函数的 prototype 属性为 o 即可\n\n\t\tfunction Person {}\n\n\t\tvar o = { ... }\n\n\t\tPerson.prototype = o;\t// 继承\n\n14. 混合式继承\n\t-> 混合就是将多个对象的各个功能混合到一起, 加到构造函数的原型对象上.\n\t\t那么该构造函数创建的实例 就继承自多个对象了.\n\n\n15. 对象 -> 父对象 -> 父对象的父对象 -> ... -> 原对象 -> ....\n\t链式结构( 原型链 )\n\n\t由于链越深, 属性搜索越需要性能. 所以一般少用深层次的链式结构继承\n\t一般使用时, 链结构只有 3 级. 一般都是使用混入, 在原型上加成员\n\n\n16. ES5 中 的 Object.create\n\t继承的最经典结构\n\t\tfunction Animal() {}\n\n\t\tfunction Person() {}\n\n\t\tPerson.prototype = new Animal();\n\n\t语法:\n\t\t新对象 Object.create( 原对象 );\n\t\t\n\t例如\n\t\tvar o ={name:\"sy\",age:20,gender:\"男\"}\n\t\t var obj = Object.create(o);\n\t\t实现继承的快速方法\n\n如果在低版本的浏览器中要使用该方法 ，先判断有没有，如果没有在加上。\nif(!Object.create){\n\tObject.create = function(o) {\n\t\tfunction F(){}\n\t\tf.prototype = o;\n\t\treturn new F();\n\t};\n}\n这个写法已经过时了\n现在使用\nfunction createWithObject ( obj ) {\n\t\tif ( Object.create ) {\n\t\t\treturn Object.create( obj );\n\t\t} else {\n\t\t\tfunction F() {}\n\t\t\tF.prototype = obj;\n\t\t\treturn new F();\n\t\t}\n\t}\n\n\n实际应用\n<script>\n\tvar o ={name:\"sy\",age:20,gender:\"男\"};\n\tvar obj = createWithObject(o);\n\tconsole.log(obj);\n\tfunction createWithObject ( obj ) {\n\t\t\tif ( Object.create ) {\n\t\t\t\treturn Object.create( obj );\n\t\t\t} else {\n\t\t\t\tfunction F() {}\n\t\t\t\tF.prototype = obj;\n\t\t\t\treturn new F();\n\t\t\t}\n\t\t}\n\t</script>\n\n\t// jQuery\n\t// Sizzle 引擎 select 方法\n\t// 在这个方法, 首先判断系统是否具有 querySelectAll 方法. 如果有直接使用\n\t// 如果没有 再自己实现\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象/面向对象第二天.md","raw":"---\ntitle: javascript 面向对象：2\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1. 为什么需要原型\n\t构造器创建对象的时候, 实际上会有成员重复\n\t如果使用 构造器 this.方法名 = function .... 方式创建对象. 那么每一个对象\n\t对应的方法就会重复. \n\n\t解决办法就是让这个方法( 函数 )共享\n\t-> 将函数写到外面, 那么 Person 在初始化对象的时候就不会再创建一个函数了.\n\t\t只需要将 外面的函数引用 交给对象即可.\n\n\t\t缺点: 一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库\n\t\t\t冲突的几率就会变大. 所以不宜采取该方法.\n\t-> 将所有的方法( 函数 )都绑定到一个对象中.\n\n\n\t-> js 原生就支持解决该问题的办法\n\t\t每一个函数都有 一个属性 prototype\n\t\t该属性指向一对象. 每一个函数的该对象都是存在. \n\t\t(重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上.\n\t\t\t如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype\n\t\t\t表示的对象中去找.\n\n\t-> prototype 就是原型之意\n\t\t\n2.  针对构造函数而言, 原型就是 构造函数的 prototype 属性, 常常将其称为 原型属性.\n\t针对实例对象而言, 原型就是 实例对象的 原型对象.\n\t\n\t例:\n\t\tfunction Person () {}\t// 有了构造函数, 和 原型\n\t\tvar p = new Person(); \t// 有了实例\n\n3. 一般如何使用原型对象\n\t-> 简单的说就是将共享的方法放到原型中, 而独有数据与行为放在当前对象里\n\t-> 例:\n\t\tPerson( name, age, gender, sayHello, eat, run )\n\t-> 直接给原型对象添加成员\n\t-> 直接替换原型对象( 注意: 手动的添加 constructor 属性, 表示对应的构造函数 ) \n\n4. __proto__\n   和 prototype 是否存在关系\n\n   早期浏览器是不支持 __proto__ \n   火狐率先使用该属性, 但是是非标准\n   基本现在的新浏览器都支持该属性\n\n   -> 访问\n   \t使用构造函数, 就使用 prototype 属性访问原型\n   \t使用实例对象, 就使用 非标准的 __proto__ 属性访问原型\n\n5. 继承\n\t-> 什么是继承\n\t\t 自己没有, 别人有, 拿过来自己用, 就好像自己的一样.\n\t-> 原型与实例对象\n\t\t在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中\n\t\t调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用\n\t\t该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象\n\t\t继承自 原型对象\n\t-> 任何一个实例, 都是继承自其原型对象的. 即原型式继承.\n\n6. 为什么需要继承\n\t-> 编程的发展\n\t\t复用( 重复使用 )\n\n\t\tdiv 标签对象\tnodeName, nodeType, nodeName, ...\n\t\t\t\t\t\tappendChild, insertBefore, getElementsByTagName, ...\n\n\t\ta 标签对象\n\n\t\tbaseElement\n\n\t-> js 运行效率\n\t\t共享特性\n\t\t复用\n\n7. 传统的编程语言的面向对象操作\n\t-> 对象: 是具有方法和属性的逻辑单元\n\t\t在 js 函数是一个特殊的数据类型( 函数在 js 是一等公民 )\n\t\tjs 对象就是键值对, 值如果是数据, 那么键值就构成属性\n\t\t如果值是函数, 那么就构成方法.\n\n\t-> 创建方式\n\t\t类 -> 实例化 -> 对象( 实例 )\n\t\t\n\t\tclass Person {\n\t\t\tpublic string name;\n\t\t\tpublic int age;\n\t\t\tpublic string gender;\n\n\t\t\tpublic void sayHello () {\n\t\t\t\t// ...\n\t\t\t}\n\t\t}\n\t\t// 类, 用来描述对象的结构, 它就是一个模板\n\n\t\tPerson p = new Person(); // 利用模板创建对象\n\n\t\t// 访问属性\n\t\tp.name\n\t\t// 调用方法\n\t\tp.sayHello();\n\n\t\t传统的面向对象编程语言, 重点需要一个\"模板\", 即 类( class )\n\n\t-> 传统的继承\n\t\t传统的继承是模板的继承.\n\n\t\tclass Student : Person {\n\t\t}\n\n\t\tStudent s = new Student();\n\t\t// 注意此时 s 就可以调用 sayHello 方法\n\t\t// 可以使用 name, age, 和 gender 属性了\n\n8. 相关概念\n\t类 class\t\t\t\t模板\t\t\t\t\t构造函数, 类名就是构造函数名\n\t子类 subclass\t\t\t派生的模板\t\t\t\t原型设置为指定对象的构造函数\n\t实例 instance\t\t\t 某个类的对象\t\t\t...\n\t实例成员(实例方法, 实例属性)\n\t静态成员\n\t\t静态方法\t\t\t...\t\t\t\t\t\t直接绑定在函数上的方法\n\t\t静态属性\t\t\t...\t\t\t\t\t\t直接绑定在函数上的属性\n\n\n\n\t// js 代码\n\tfunction Person () {\n\t\tthis.name = '黄帝';\n\t\tthis.age = 0;\n\t\tthis.gender = '男';\n\t}\n\n\t// 不叫子类, 只是一个 Student 类\n\tfunction Student() {\n\t}\n\n\t// 继承派生 成为子类\n\tStudent.prototype = new Person();\n\n\t// 即完成派生\n\tvar s = new Student();\n\ts.name // OK\n\n9. 属性访问原则( 重点 )\n\t1) 对象在调用方法或访问属性的时候, 首先在当前对象中查询. 如果有该成员使用并停止查找.\n\t2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找.\n\t3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找.\n\t...\n\t4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined.\n\n10. 如果修改原型对象中的属性值会怎样\n\t给当前对象的原型提供的属性赋值, 实际上是给当前对象添加了该属性的新成员\n\t并不会修改运行对象中的成员. \n\n11. 混入( mix )\n\t\n\tvar o1 = { name: '张三' };\n\tvar o2 = { age: 19 };\n\t-----------\n\to2.name = o1.name\n\t利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中\n\t执行混入操作， 如果o2里面有name值，则将会被覆盖。\n\t混入使得 o2 具有了 age 和 o1 中的 name. 即将 o1 混入到 o2 中\n\n\t混入也是一种继承的方式\n\t实例\n<script>\n\t\tvar o = {\n\t\t\textend:function(obj){\n\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\tfor(var k in arguments[i] ){\n\t\t\t\t\t\tthis[k]=arguments[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\to.extend({name:\"sy\"},{age:18},{sex:\"男\"});\n\n\t\tconsole.log(o);\n</script>\n\n12. 如何使用代码实现混入\n\t\n\t// 考虑需要执行, 写函数即可\n\t// 由于将 一个 对象混入到 另一个对象. 所以有两个参数\n\tfunction __mix__ ( obj, obj1 ) {\n\t\t// 如何获得 obj1 中的所有成员?\n\t\tfor ( var  k in obj1 ) {\n\t\t\tobj[ k ] = obj1[ k ];\n\t\t}\n\t}\n\n13. 原型式继承\n\t-> 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么\n\t\t只需要设置该构造函数的 prototype 属性为 o 即可\n\n\t\tfunction Person {}\n\n\t\tvar o = { ... }\n\n\t\tPerson.prototype = o;\t// 继承\n\n14. 混合式继承\n\t-> 混合就是将多个对象的各个功能混合到一起, 加到构造函数的原型对象上.\n\t\t那么该构造函数创建的实例 就继承自多个对象了.\n\n\n15. 对象 -> 父对象 -> 父对象的父对象 -> ... -> 原对象 -> ....\n\t链式结构( 原型链 )\n\n\t由于链越深, 属性搜索越需要性能. 所以一般少用深层次的链式结构继承\n\t一般使用时, 链结构只有 3 级. 一般都是使用混入, 在原型上加成员\n\n\n16. ES5 中 的 Object.create\n\t继承的最经典结构\n\t\tfunction Animal() {}\n\n\t\tfunction Person() {}\n\n\t\tPerson.prototype = new Animal();\n\n\t语法:\n\t\t新对象 Object.create( 原对象 );\n\t\t\n\t例如\n\t\tvar o ={name:\"sy\",age:20,gender:\"男\"}\n\t\t var obj = Object.create(o);\n\t\t实现继承的快速方法\n\n如果在低版本的浏览器中要使用该方法 ，先判断有没有，如果没有在加上。\nif(!Object.create){\n\tObject.create = function(o) {\n\t\tfunction F(){}\n\t\tf.prototype = o;\n\t\treturn new F();\n\t};\n}\n这个写法已经过时了\n现在使用\nfunction createWithObject ( obj ) {\n\t\tif ( Object.create ) {\n\t\t\treturn Object.create( obj );\n\t\t} else {\n\t\t\tfunction F() {}\n\t\t\tF.prototype = obj;\n\t\t\treturn new F();\n\t\t}\n\t}\n\n\n实际应用\n<script>\n\tvar o ={name:\"sy\",age:20,gender:\"男\"};\n\tvar obj = createWithObject(o);\n\tconsole.log(obj);\n\tfunction createWithObject ( obj ) {\n\t\t\tif ( Object.create ) {\n\t\t\t\treturn Object.create( obj );\n\t\t\t} else {\n\t\t\t\tfunction F() {}\n\t\t\t\tF.prototype = obj;\n\t\t\t\treturn new F();\n\t\t\t}\n\t\t}\n\t</script>\n\n\t// jQuery\n\t// Sizzle 引擎 select 方法\n\t// 在这个方法, 首先判断系统是否具有 querySelectAll 方法. 如果有直接使用\n\t// 如果没有 再自己实现\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"面向对象/面向对象第二天","published":1,"date":"2016-12-22T02:50:00.000Z","updated":"2019-04-26T06:38:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0jh003a7xuqr36yebyn","content":"<ol>\n<li><p>为什么需要原型<br> 构造器创建对象的时候, 实际上会有成员重复<br> 如果使用 构造器 this.方法名 = function …. 方式创建对象. 那么每一个对象<br> 对应的方法就会重复. </p>\n<p> 解决办法就是让这个方法( 函数 )共享<br> -&gt; 将函数写到外面, 那么 Person 在初始化对象的时候就不会再创建一个函数了.</p>\n<pre><code>只需要将 外面的函数引用 交给对象即可.\n\n缺点: 一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库\n    冲突的几率就会变大. 所以不宜采取该方法.\n</code></pre><p> -&gt; 将所有的方法( 函数 )都绑定到一个对象中.</p>\n</li>\n</ol>\n<pre><code>-&gt; js 原生就支持解决该问题的办法\n    每一个函数都有 一个属性 prototype\n    该属性指向一对象. 每一个函数的该对象都是存在. \n    (重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上.\n        如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype\n        表示的对象中去找.\n\n-&gt; prototype 就是原型之意\n</code></pre><ol>\n<li><p>针对构造函数而言, 原型就是 构造函数的 prototype 属性, 常常将其称为 原型属性.<br>针对实例对象而言, 原型就是 实例对象的 原型对象.</p>\n<p>例:</p>\n<pre><code>function Person () {}    // 有了构造函数, 和 原型\nvar p = new Person();     // 有了实例\n</code></pre></li>\n<li><p>一般如何使用原型对象<br> -&gt; 简单的说就是将共享的方法放到原型中, 而独有数据与行为放在当前对象里<br> -&gt; 例:</p>\n<pre><code>Person( name, age, gender, sayHello, eat, run )\n</code></pre><p> -&gt; 直接给原型对象添加成员<br> -&gt; 直接替换原型对象( 注意: 手动的添加 constructor 属性, 表示对应的构造函数 ) </p>\n</li>\n<li><p><strong>proto</strong><br>和 prototype 是否存在关系</p>\n<p>早期浏览器是不支持 <strong>proto</strong><br>火狐率先使用该属性, 但是是非标准<br>基本现在的新浏览器都支持该属性</p>\n<p>-&gt; 访问</p>\n<pre><code>使用构造函数, 就使用 prototype 属性访问原型\n使用实例对象, 就使用 非标准的 __proto__ 属性访问原型\n</code></pre></li>\n<li><p>继承<br> -&gt; 什么是继承</p>\n<pre><code>自己没有, 别人有, 拿过来自己用, 就好像自己的一样.\n</code></pre><p> -&gt; 原型与实例对象</p>\n<pre><code>在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中\n调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用\n该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象\n继承自 原型对象\n</code></pre><p> -&gt; 任何一个实例, 都是继承自其原型对象的. 即原型式继承.</p>\n</li>\n<li><p>为什么需要继承<br> -&gt; 编程的发展</p>\n<pre><code>复用( 重复使用 )\n\ndiv 标签对象    nodeName, nodeType, nodeName, ...\n                appendChild, insertBefore, getElementsByTagName, ...\n\na 标签对象\n\nbaseElement\n</code></pre><p> -&gt; js 运行效率</p>\n<pre><code>共享特性\n复用\n</code></pre></li>\n<li><p>传统的编程语言的面向对象操作<br> -&gt; 对象: 是具有方法和属性的逻辑单元</p>\n<pre><code>在 js 函数是一个特殊的数据类型( 函数在 js 是一等公民 )\njs 对象就是键值对, 值如果是数据, 那么键值就构成属性\n如果值是函数, 那么就构成方法.\n</code></pre><p> -&gt; 创建方式</p>\n<pre><code>类 -&gt; 实例化 -&gt; 对象( 实例 )\n\nclass Person {\n    public string name;\n    public int age;\n    public string gender;\n\n    public void sayHello () {\n        // ...\n    }\n}\n// 类, 用来描述对象的结构, 它就是一个模板\n\nPerson p = new Person(); // 利用模板创建对象\n\n// 访问属性\np.name\n// 调用方法\np.sayHello();\n\n传统的面向对象编程语言, 重点需要一个&quot;模板&quot;, 即 类( class )\n</code></pre><p> -&gt; 传统的继承</p>\n<pre><code>传统的继承是模板的继承.\n\nclass Student : Person {\n}\n\nStudent s = new Student();\n// 注意此时 s 就可以调用 sayHello 方法\n// 可以使用 name, age, 和 gender 属性了\n</code></pre></li>\n<li><p>相关概念<br> 类 class                模板                    构造函数, 类名就是构造函数名<br> 子类 subclass            派生的模板                原型设置为指定对象的构造函数<br> 实例 instance             某个类的对象            …<br> 实例成员(实例方法, 实例属性)<br> 静态成员</p>\n<pre><code>静态方法            ...                        直接绑定在函数上的方法\n静态属性            ...                        直接绑定在函数上的属性\n</code></pre></li>\n</ol>\n<pre><code>// js 代码\nfunction Person () {\n    this.name = &apos;黄帝&apos;;\n    this.age = 0;\n    this.gender = &apos;男&apos;;\n}\n\n// 不叫子类, 只是一个 Student 类\nfunction Student() {\n}\n\n// 继承派生 成为子类\nStudent.prototype = new Person();\n\n// 即完成派生\nvar s = new Student();\ns.name // OK\n</code></pre><ol>\n<li><p>属性访问原则( 重点 )<br> 1) 对象在调用方法或访问属性的时候, 首先在当前对象中查询. 如果有该成员使用并停止查找.<br> 2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找.<br> 3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找.<br> …<br> 4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined.</p>\n</li>\n<li><p>如果修改原型对象中的属性值会怎样<br>给当前对象的原型提供的属性赋值, 实际上是给当前对象添加了该属性的新成员<br>并不会修改运行对象中的成员. </p>\n</li>\n<li><p>混入( mix )</p>\n<p>var o1 = { name: ‘张三’ };</p>\n<h2 id=\"var-o2-age-19\"><a href=\"#var-o2-age-19\" class=\"headerlink\" title=\"var o2 = { age: 19 };\"></a>var o2 = { age: 19 };</h2><p>o2.name = o1.name<br>利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中<br>执行混入操作， 如果o2里面有name值，则将会被覆盖。<br>混入使得 o2 具有了 age 和 o1 中的 name. 即将 o1 混入到 o2 中</p>\n<p>混入也是一种继承的方式<br>实例</p>\n<script>\n    var o = {\n        extend:function(obj){\n            for (var i = 0; i < arguments.length; i++) {\n                for(var k in arguments[i] ){\n                    this[k]=arguments[i][k];\n                }\n            }\n        }\n    };\n    o.extend({name:\"sy\"},{age:18},{sex:\"男\"});\n\n    console.log(o);\n</script>\n</li>\n<li><p>如何使用代码实现混入</p>\n<p>// 考虑需要执行, 写函数即可<br>// 由于将 一个 对象混入到 另一个对象. 所以有两个参数<br>function <strong>mix</strong> ( obj, obj1 ) {</p>\n<pre><code>// 如何获得 obj1 中的所有成员?\nfor ( var  k in obj1 ) {\n    obj[ k ] = obj1[ k ];\n}\n</code></pre><p>}</p>\n</li>\n<li><p>原型式继承<br>-&gt; 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么</p>\n<pre><code>只需要设置该构造函数的 prototype 属性为 o 即可\n\nfunction Person {}\n\nvar o = { ... }\n\nPerson.prototype = o;    // 继承\n</code></pre></li>\n<li><p>混合式继承<br>-&gt; 混合就是将多个对象的各个功能混合到一起, 加到构造函数的原型对象上.</p>\n<pre><code>那么该构造函数创建的实例 就继承自多个对象了.\n</code></pre></li>\n</ol>\n<ol>\n<li><p>对象 -&gt; 父对象 -&gt; 父对象的父对象 -&gt; … -&gt; 原对象 -&gt; ….<br>链式结构( 原型链 )</p>\n<p>由于链越深, 属性搜索越需要性能. 所以一般少用深层次的链式结构继承<br>一般使用时, 链结构只有 3 级. 一般都是使用混入, 在原型上加成员</p>\n</li>\n</ol>\n<ol>\n<li><p>ES5 中 的 Object.create<br>继承的最经典结构</p>\n<pre><code>function Animal() {}\n\nfunction Person() {}\n\nPerson.prototype = new Animal();\n</code></pre><p>语法:</p>\n<pre><code>新对象 Object.create( 原对象 );\n</code></pre><p>例如</p>\n<pre><code>var o ={name:&quot;sy&quot;,age:20,gender:&quot;男&quot;}\n var obj = Object.create(o);\n实现继承的快速方法\n</code></pre></li>\n</ol>\n<p>如果在低版本的浏览器中要使用该方法 ，先判断有没有，如果没有在加上。<br>if(!Object.create){<br>    Object.create = function(o) {<br>        function F(){}<br>        f.prototype = o;<br>        return new F();<br>    };<br>}<br>这个写法已经过时了<br>现在使用<br>function createWithObject ( obj ) {<br>        if ( Object.create ) {<br>            return Object.create( obj );<br>        } else {<br>            function F() {}<br>            F.prototype = obj;<br>            return new F();<br>        }<br>    }</p>\n<p>实际应用</p>\n<script>\n    var o ={name:\"sy\",age:20,gender:\"男\"};\n    var obj = createWithObject(o);\n    console.log(obj);\n    function createWithObject ( obj ) {\n            if ( Object.create ) {\n                return Object.create( obj );\n            } else {\n                function F() {}\n                F.prototype = obj;\n                return new F();\n            }\n        }\n    </script>\n\n<pre><code>// jQuery\n// Sizzle 引擎 select 方法\n// 在这个方法, 首先判断系统是否具有 querySelectAll 方法. 如果有直接使用\n// 如果没有 再自己实现\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>为什么需要原型<br> 构造器创建对象的时候, 实际上会有成员重复<br> 如果使用 构造器 this.方法名 = function …. 方式创建对象. 那么每一个对象<br> 对应的方法就会重复. </p>\n<p> 解决办法就是让这个方法( 函数 )共享<br> -&gt; 将函数写到外面, 那么 Person 在初始化对象的时候就不会再创建一个函数了.</p>\n<pre><code>只需要将 外面的函数引用 交给对象即可.\n\n缺点: 一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库\n    冲突的几率就会变大. 所以不宜采取该方法.\n</code></pre><p> -&gt; 将所有的方法( 函数 )都绑定到一个对象中.</p>\n</li>\n</ol>\n<pre><code>-&gt; js 原生就支持解决该问题的办法\n    每一个函数都有 一个属性 prototype\n    该属性指向一对象. 每一个函数的该对象都是存在. \n    (重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上.\n        如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype\n        表示的对象中去找.\n\n-&gt; prototype 就是原型之意\n</code></pre><ol>\n<li><p>针对构造函数而言, 原型就是 构造函数的 prototype 属性, 常常将其称为 原型属性.<br>针对实例对象而言, 原型就是 实例对象的 原型对象.</p>\n<p>例:</p>\n<pre><code>function Person () {}    // 有了构造函数, 和 原型\nvar p = new Person();     // 有了实例\n</code></pre></li>\n<li><p>一般如何使用原型对象<br> -&gt; 简单的说就是将共享的方法放到原型中, 而独有数据与行为放在当前对象里<br> -&gt; 例:</p>\n<pre><code>Person( name, age, gender, sayHello, eat, run )\n</code></pre><p> -&gt; 直接给原型对象添加成员<br> -&gt; 直接替换原型对象( 注意: 手动的添加 constructor 属性, 表示对应的构造函数 ) </p>\n</li>\n<li><p><strong>proto</strong><br>和 prototype 是否存在关系</p>\n<p>早期浏览器是不支持 <strong>proto</strong><br>火狐率先使用该属性, 但是是非标准<br>基本现在的新浏览器都支持该属性</p>\n<p>-&gt; 访问</p>\n<pre><code>使用构造函数, 就使用 prototype 属性访问原型\n使用实例对象, 就使用 非标准的 __proto__ 属性访问原型\n</code></pre></li>\n<li><p>继承<br> -&gt; 什么是继承</p>\n<pre><code>自己没有, 别人有, 拿过来自己用, 就好像自己的一样.\n</code></pre><p> -&gt; 原型与实例对象</p>\n<pre><code>在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中\n调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用\n该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象\n继承自 原型对象\n</code></pre><p> -&gt; 任何一个实例, 都是继承自其原型对象的. 即原型式继承.</p>\n</li>\n<li><p>为什么需要继承<br> -&gt; 编程的发展</p>\n<pre><code>复用( 重复使用 )\n\ndiv 标签对象    nodeName, nodeType, nodeName, ...\n                appendChild, insertBefore, getElementsByTagName, ...\n\na 标签对象\n\nbaseElement\n</code></pre><p> -&gt; js 运行效率</p>\n<pre><code>共享特性\n复用\n</code></pre></li>\n<li><p>传统的编程语言的面向对象操作<br> -&gt; 对象: 是具有方法和属性的逻辑单元</p>\n<pre><code>在 js 函数是一个特殊的数据类型( 函数在 js 是一等公民 )\njs 对象就是键值对, 值如果是数据, 那么键值就构成属性\n如果值是函数, 那么就构成方法.\n</code></pre><p> -&gt; 创建方式</p>\n<pre><code>类 -&gt; 实例化 -&gt; 对象( 实例 )\n\nclass Person {\n    public string name;\n    public int age;\n    public string gender;\n\n    public void sayHello () {\n        // ...\n    }\n}\n// 类, 用来描述对象的结构, 它就是一个模板\n\nPerson p = new Person(); // 利用模板创建对象\n\n// 访问属性\np.name\n// 调用方法\np.sayHello();\n\n传统的面向对象编程语言, 重点需要一个&quot;模板&quot;, 即 类( class )\n</code></pre><p> -&gt; 传统的继承</p>\n<pre><code>传统的继承是模板的继承.\n\nclass Student : Person {\n}\n\nStudent s = new Student();\n// 注意此时 s 就可以调用 sayHello 方法\n// 可以使用 name, age, 和 gender 属性了\n</code></pre></li>\n<li><p>相关概念<br> 类 class                模板                    构造函数, 类名就是构造函数名<br> 子类 subclass            派生的模板                原型设置为指定对象的构造函数<br> 实例 instance             某个类的对象            …<br> 实例成员(实例方法, 实例属性)<br> 静态成员</p>\n<pre><code>静态方法            ...                        直接绑定在函数上的方法\n静态属性            ...                        直接绑定在函数上的属性\n</code></pre></li>\n</ol>\n<pre><code>// js 代码\nfunction Person () {\n    this.name = &apos;黄帝&apos;;\n    this.age = 0;\n    this.gender = &apos;男&apos;;\n}\n\n// 不叫子类, 只是一个 Student 类\nfunction Student() {\n}\n\n// 继承派生 成为子类\nStudent.prototype = new Person();\n\n// 即完成派生\nvar s = new Student();\ns.name // OK\n</code></pre><ol>\n<li><p>属性访问原则( 重点 )<br> 1) 对象在调用方法或访问属性的时候, 首先在当前对象中查询. 如果有该成员使用并停止查找.<br> 2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找.<br> 3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找.<br> …<br> 4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined.</p>\n</li>\n<li><p>如果修改原型对象中的属性值会怎样<br>给当前对象的原型提供的属性赋值, 实际上是给当前对象添加了该属性的新成员<br>并不会修改运行对象中的成员. </p>\n</li>\n<li><p>混入( mix )</p>\n<p>var o1 = { name: ‘张三’ };</p>\n<h2 id=\"var-o2-age-19\"><a href=\"#var-o2-age-19\" class=\"headerlink\" title=\"var o2 = { age: 19 };\"></a>var o2 = { age: 19 };</h2><p>o2.name = o1.name<br>利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中<br>执行混入操作， 如果o2里面有name值，则将会被覆盖。<br>混入使得 o2 具有了 age 和 o1 中的 name. 即将 o1 混入到 o2 中</p>\n<p>混入也是一种继承的方式<br>实例</p>\n<script>\n    var o = {\n        extend:function(obj){\n            for (var i = 0; i < arguments.length; i++) {\n                for(var k in arguments[i] ){\n                    this[k]=arguments[i][k];\n                }\n            }\n        }\n    };\n    o.extend({name:\"sy\"},{age:18},{sex:\"男\"});\n\n    console.log(o);\n</script>\n</li>\n<li><p>如何使用代码实现混入</p>\n<p>// 考虑需要执行, 写函数即可<br>// 由于将 一个 对象混入到 另一个对象. 所以有两个参数<br>function <strong>mix</strong> ( obj, obj1 ) {</p>\n<pre><code>// 如何获得 obj1 中的所有成员?\nfor ( var  k in obj1 ) {\n    obj[ k ] = obj1[ k ];\n}\n</code></pre><p>}</p>\n</li>\n<li><p>原型式继承<br>-&gt; 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么</p>\n<pre><code>只需要设置该构造函数的 prototype 属性为 o 即可\n\nfunction Person {}\n\nvar o = { ... }\n\nPerson.prototype = o;    // 继承\n</code></pre></li>\n<li><p>混合式继承<br>-&gt; 混合就是将多个对象的各个功能混合到一起, 加到构造函数的原型对象上.</p>\n<pre><code>那么该构造函数创建的实例 就继承自多个对象了.\n</code></pre></li>\n</ol>\n<ol>\n<li><p>对象 -&gt; 父对象 -&gt; 父对象的父对象 -&gt; … -&gt; 原对象 -&gt; ….<br>链式结构( 原型链 )</p>\n<p>由于链越深, 属性搜索越需要性能. 所以一般少用深层次的链式结构继承<br>一般使用时, 链结构只有 3 级. 一般都是使用混入, 在原型上加成员</p>\n</li>\n</ol>\n<ol>\n<li><p>ES5 中 的 Object.create<br>继承的最经典结构</p>\n<pre><code>function Animal() {}\n\nfunction Person() {}\n\nPerson.prototype = new Animal();\n</code></pre><p>语法:</p>\n<pre><code>新对象 Object.create( 原对象 );\n</code></pre><p>例如</p>\n<pre><code>var o ={name:&quot;sy&quot;,age:20,gender:&quot;男&quot;}\n var obj = Object.create(o);\n实现继承的快速方法\n</code></pre></li>\n</ol>\n<p>如果在低版本的浏览器中要使用该方法 ，先判断有没有，如果没有在加上。<br>if(!Object.create){<br>    Object.create = function(o) {<br>        function F(){}<br>        f.prototype = o;<br>        return new F();<br>    };<br>}<br>这个写法已经过时了<br>现在使用<br>function createWithObject ( obj ) {<br>        if ( Object.create ) {<br>            return Object.create( obj );<br>        } else {<br>            function F() {}<br>            F.prototype = obj;<br>            return new F();<br>        }<br>    }</p>\n<p>实际应用</p>\n<script>\n    var o ={name:\"sy\",age:20,gender:\"男\"};\n    var obj = createWithObject(o);\n    console.log(obj);\n    function createWithObject ( obj ) {\n            if ( Object.create ) {\n                return Object.create( obj );\n            } else {\n                function F() {}\n                F.prototype = obj;\n                return new F();\n            }\n        }\n    </script>\n\n<pre><code>// jQuery\n// Sizzle 引擎 select 方法\n// 在这个方法, 首先判断系统是否具有 querySelectAll 方法. 如果有直接使用\n// 如果没有 再自己实现\n</code></pre>"},{"title":"javascript 面向对象：4","_content":"1. 复习\n\t加入我希望所有的函数都具有 inherit 功能\n\t\tfunction Person() {}\n\n\t\tvar Student = Person.inherit( 成员 );\n\t\t// 生成函数 Student, 但是 Student 里面的成员( this.XXX )\n\t\t// 由参数来提供, 而 Student 的对象, 继承自 Person 的对象\n\n\t如果希望所有的函数都有 inherit 方法, 那么可以给 Function.prototype 添加该方法\n\n\n2. 代码的预解析\n\t-> 预解析\n\t\t预\n\t\t解析\n\n\t\t提前的翻译解释, 在运行代码之前的一个解释.\n\t-> 为什么需要它\n\t\t-> 编译型语言: C, C++, C#, Java\n\t\t\t就是需要一个 \"翻译\" 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ).\n\t\t\t然后存储成可执行文件. \n\n\t\t\t提前翻译好, 运行时直接执行得结果\n\n\t\t-> 解释型( 脚本型 ): JavaScript, SQL, ...\n\t\t\t代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, \n\t\t\t再执行一句代码.\n\n\t\t\t一句一句的翻译执行. 每次运行都需要翻译一次.\n\n\t\t-> 代码在执行之前, 需要快速的 \"预览\" 一遍. 那么可以尽可能提高执行效率.\n\n3. 在 js 中预解析的特点\n\t-> 代码是如何执行的: 读取 js 文本, 预解析, 一句一句地执行\n\t-> js 在预解析的过程中完成了声明部分的标记与变量作用域的设定\n\n4. 什么是 js 中的声明\n\t-> 简单的说就是让 js 执行引擎知道有什么东西( 标识符 )\n\t\tconsole.log( num );\t// error: num is not defined\n\t\tnum(); // error: is not function\n\n\t\t即代码在执行之前的预解析, 首先让 js 的执行引擎知道在当前运行环境中\n\t\t有什么东西( 名字, 标识符 )是可以被使用的. 它是变量, 还是函数等? \n\n\t-> 在 js 中有哪些声明: \n\t\t1) 标识符的声明( 变量的声明 )\n\t\t2) 函数的声明\n\n\t-> 变量的声明:\n\t\t语法: \t\tvar 变量名;\n\t\t目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.\n\n\t\t语句: 就是可以执行的东西.\n\t\t\tvar a = 123; 是一个语句\n\t\t在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理:\n\t\t-> 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了\n\t\t-> 如果没有标记, 就表明这个名字是一个标识符, 需要被标记\n\t\t-> 如果已经被标记了, 那么 这个 var 被忽略\n\n\t\t结论:\n\t\t\tvar a;\n\t\t\tvar a = 10;\n\t\t\t等价\n\t\t\tvar a;\n\t\t\ta = 10;\n\n\t\t\tvar a = 123;\n\t\t\tvar a = 456;\n\t\t\tvar a = 789;\n\t\t\t等价于\n\t\t\tvar a = 123;\n\t\t\ta = 456;\n\t\t\ta = 789;\n\n\t\t如果在代码中有多个 var 后面紧跟的名字是一样的. 那么只有第一个 var 起作用.\n\t\t后面的所有 var 都会被自动的忽略.\n\n\t-> 变量名提升\n\n\t-> 函数的声明\n\t\t-> 函数的各种定义形式\n\t\t\t-> 声明式:\t\n\t\t\t\tfunction func () {\n\t\t\t\t\tconsole.log( '使用声明式定义' );\n\t\t\t\t}\n\t\t\t-> 表达式式( 匿名函数, 字面量函数, lambda 函数 ):\n\t\t\t\tvar func = function () {\n\t\t\t\t\tconsole.log( '使用表达式式定义' );\n\t\t\t\t};\n\t\t\t-> ... \n\t\t-> 特点:\n\t\t\t1> 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.\n\t\t\t2> 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.\n\n\t\t-> 表达式:\n\t\t\t-> 将运算符与操作数连接起来的式子.\n\t\t\t-> 就是一个有结果的代码单元( 不包括语句 )\n\t\t\t\tvar a;\t\t// 声明, 不是语句, 也没有结果\n\t\t\t\t123\t\t\t// 字面量, 有值, 是表达式. 是常量表达式\n\t\t\t\ta = 123\t\t// 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.\n\n\t\t\t\tfunction () {}\n\n5. 如果将变量的声明与函数的声明放在一起有些需要注意的情况\n\t1) 函数的声明实际上包含两部分\n\t\t1> 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 )\n\t\t2> 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 )\n\t2) 当函数声明与变量声明冲突的时候. 只看谁先有数据.\n\n6. 一个在新版本的浏览器中的特性\n\tif ( true ) {\n\t\tfunction foo() {\n\t\t\tconsole.log( true );\n\t\t}\n\t} else {\n\t\tfunction foo() {\n\t\t\tconsole.log( false );\n\t\t}\n\t}\n\tfoo();\n\n7. 词法作用域\n\t-> 作用域: 就是变量可以使用到不能使用的范围\n\t-> 块级作用域:\n\t\t-> 块: 代码块, 即 {  }\n\t\t-> 变量的使用从定义开始, 到其所在的块级作用域结束\n\t\t\t// js 伪代码\n\t\t\t{\n\t\t\t\tconsole.log( num );\t\t// error: num 未定义\n\t\t\t\tvar num = 123;\n\t\t\t\t{\n\t\t\t\t\tconsole.log( num ); // => 123\n\t\t\t\t}\n\n\t\t\t\tconsole.log( num ); \t// => 123\n\t\t\t}\n\t\t\tconsole.log( num );  // error: num 未定义\n\t\t-> 代表语言: C, C++, C#, Java, ...\n\t-> js 是词法作用域\n\t\t-> 词法: 就是定义, 书写代码的规则.\n\t\t-> 所以 所谓的 词法作用域, 就是 在书写代码的时候, 根据书写代码的结构\n\t\t\t就可以确定数据的访问范围的作用域.\n\t\t-> js 不受 块的影响, 即使在块中定义声明变量, 在块的外面依旧可以使用\n\t\t\tconsole.log( num );  // => undefined\n\t\t\t{\n\t\t\t\tvar num = 123;\n\t\t\t}\n\t\t\tconsole.log( num );  // => 123\n\t\t-> 所谓的 js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 全部代码中\n\t\t\t只有函数可以限定范围. 其他均不能限定访问范围. 在内部是一个独立的作用范围结构.\n\n\t\t-> 结论:\n\t\t\t词法作用域就是描述变量的访问范围:\n\t\t\t1> 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.\n\t\t\t2> 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.\n\t\t\t3> 所有变量的访问规则, 按照预解析规则来访问\n\n8. 案例\n\tvar num = 123;\n\tfunction f1 () {\n\t\tconsole.log( num );\n\t}\n\tfunction f2 () {\n\t\tconsole.log( num );\n\t\tvar num = 456;\n\t\tf1();\n\t\tconsole.log( num );\n\t}\n\tf2();\n\n\t1> 读取代码预解析. 得到 num, f1, f2\n\t2> 逐步的执行代码\n\t\t1) 赋值 num = 123;   注意 f1 和 f2 由于是函数, 所以也有数据.\n\t\t2) 调用 f2.\n\t\t\t进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num\n\t\t\t执行每一句代码\n\t\t\t-> 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined\n\t\t\t-> 赋值 num = 456\n\t\t\t-> 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否还有函数的声明. 如果有直接使用. 如果\n\t\t\t\t没有, 则在函数外面找, 看时候有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数\n\t\t\t-> 跳入 f1 函数中. 又要解析一次. 没有得到任何声明.\n\t\t\t-> 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. \n\t\t\t\t函数调用结束, 回到 f2 中.\n\t\t\t-> 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456.\n\n\n\t任务:\n\t\tvar num = 123;\n\t\tfunction f1 () {\n\t\t\tconsole.log( num );\n\t\t}\n\t\tfunction f2 () {\n\t\t\tconsole.log( num );   // => 123 , 456, 456\n\t\t\tnum = 456;\t\t\t\n\t\t\tf1();\n\t\t\tconsole.log( num );\n\t\t}\n\t\tf2();\n\n\n\n9. 案例\n\t(function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t})( 100 );\n\n\t拆解\n\t( 函数 ) ( 100 )\n\t第一个圆括号就是将函数变成表达式\n\t后面一个圆括号就是调用该函数\n\n\tvar func = function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t}\n\tfunc( 100 );\n\n\t注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明\n\tfunction ( a ) { ... }\n\t其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明.\n\n\t由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效.\n\t所以上面的代码, 等价于\n\tvar func = function ( a ) {\n\t\tconsole.log( a );\t\t\t// => 100\n\t\ta = 10;\n\t\tconsole.log( a );\t\t\t// => 10\n\t}\n\tfunc( 100 );\n\n\t// 变式\n\n\t(function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t\tfunction a () {\n\t\t\tconsole.log( a );\n\t\t}\n\t\ta();\n\t})( 100 );\n\n\t1> 直接调用\n\t2> 进入到函数中, 已有声明 a 并且其值为 100\n\t3> 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. \n\t\t1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了\n\t\t2) 让 a 指向函数. 相当于\n\t\t\tvar a;\n\t\t\tfunction a () {}\n\t\t\t...\n\t4> 开始逐步执行每一句代码\n\t\t1) 打印 a. 所以打印函数体\n\t\t2) 赋值 a = 10\n\t\t3) 打印 a, 打印出 10\n\t\t4) 如果让 a 调用, 那么报错 error: a is not function\n\n10. 作用域链规则\n\t-> 什么是作用域链\n\t\t链指的就是访问规则\n\t\tfunction foo() {\n\t\t\tconsole.log( num );\n\t\t}\n\n\t\t--------------------\n\t\tfunction func () {\n\t\t\tfunction foo() {\n\t\t\t\tconsole.log( num );\n\t\t\t}\n\t\t\tfoo();\n\t\t}\n\n\t\t--------------------\n\t\tfunction F () {\n\t\t\tfunction func () {\n\t\t\t\tfunction foo() {\n\t\t\t\t\tconsole.log( num );\n\t\t\t\t}\n\t\t\t\tfoo();\n\t\t\t}\n\t\t\tfunc();\n\t\t}\n\t\t... ...\n\n\t\t由于这种一环套一环的访问规则, 这样的作用域构成一个链式结构. 所以直接称其为作用域链.\n\n\t-> 作用域链是用来做变量查找的. 因此变量可以存储什么东西. 链中就应该有什么东西. \n\t\t换句话说就是, 链里面存储的是各种对象. 可以将其想象成对象的序列( 数组 )\n\n11. 绘制作用域链的规则\n\t1> 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.\n\t2> 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.\n\t3> 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.\n\t4> 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.\n\t5> 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推.\n\n12. 分析代码的执行\n\t当作用域链绘制完成后. 代码的的分析也需要一步一步的完成.\n\t1> 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化\n\t2> 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.\n\t3> 如果找到变量, 直接使用. 如果没有找到变量在 上一级, n - 1 级中查找.\n\t4> 一直找下去, 知直到 0 级链. 如果 0 级链还没有就报错. xxx is not defined.\n\n13. 经典面试题\n\n14. 经典面试题的变式( 练习 )\n\t写一段代码, 生成 5 个 a 标签. 要求在 a 标签中分别显示出 1, 2, 3, 4, 5\n\t即最后得到 <a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>\n\n15. 闭包的概念\n\t-> 字面意义\n\t\t闭: 关闭, 封闭\n\t\t包: 包裹, 打包\n\t\t闭包的含义就是一个被包裹的隔离的空间.\n\t-> 在 js 中, 什么是闭包\n\t\t在 js 中函数是一个具有变量作用域隔离特性的一个内存结构, 即为一个闭包.\n\t\t\n\t\tfunction foo () {\n\t\t\t\n\t\t}\n\n16. 学习闭包, 在 js 中到底要解决什么问题\n\t在 js 中闭包要解决的问题就是间接的访问到这个被隔离的数据.\n\n\tfunction foo () {\n\t\tvar num = 123;\n\n\t}\n\n\t// 在外界访问到 num 中的数据. 怎么做?\n\n\n17. 函数, 在 js 中与普通的对象具有一样的意义\n\t-> 函数可以像变量一样使用\n\t\t-> 赋值\n\t\t-> 传递\n\n18. 闭包的间接访问\n\t-> 使用 return 数据不能直接访问原来的数据, 那么可以考虑利用函数的返回访问原始数据\n\n\tfunction foo () {\n\t\tvar num = 123;   // 原始数据\n\t\t\n\t\tfunction func () {\n\t\t\treturn num; // 它就是原始数据 num\n\t\t}\n\t\t\n\t\treturn func;\n\t}\n\n\n19，当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式。\n\t1）引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数。\n\t2）函数表达式带有名字，该名字只允许在函数内部使用。属于局部作用域。\n\t3）带有名字的函数表达式，函数的name属性即为该名字。\n\n\n\n\n\n\n\n\n","source":"_posts/面向对象/面向对象第四天.md","raw":"---\ntitle: javascript 面向对象：4\ncategories: ['前端']\ntags: ['面向对象'] \n---\n1. 复习\n\t加入我希望所有的函数都具有 inherit 功能\n\t\tfunction Person() {}\n\n\t\tvar Student = Person.inherit( 成员 );\n\t\t// 生成函数 Student, 但是 Student 里面的成员( this.XXX )\n\t\t// 由参数来提供, 而 Student 的对象, 继承自 Person 的对象\n\n\t如果希望所有的函数都有 inherit 方法, 那么可以给 Function.prototype 添加该方法\n\n\n2. 代码的预解析\n\t-> 预解析\n\t\t预\n\t\t解析\n\n\t\t提前的翻译解释, 在运行代码之前的一个解释.\n\t-> 为什么需要它\n\t\t-> 编译型语言: C, C++, C#, Java\n\t\t\t就是需要一个 \"翻译\" 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ).\n\t\t\t然后存储成可执行文件. \n\n\t\t\t提前翻译好, 运行时直接执行得结果\n\n\t\t-> 解释型( 脚本型 ): JavaScript, SQL, ...\n\t\t\t代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, \n\t\t\t再执行一句代码.\n\n\t\t\t一句一句的翻译执行. 每次运行都需要翻译一次.\n\n\t\t-> 代码在执行之前, 需要快速的 \"预览\" 一遍. 那么可以尽可能提高执行效率.\n\n3. 在 js 中预解析的特点\n\t-> 代码是如何执行的: 读取 js 文本, 预解析, 一句一句地执行\n\t-> js 在预解析的过程中完成了声明部分的标记与变量作用域的设定\n\n4. 什么是 js 中的声明\n\t-> 简单的说就是让 js 执行引擎知道有什么东西( 标识符 )\n\t\tconsole.log( num );\t// error: num is not defined\n\t\tnum(); // error: is not function\n\n\t\t即代码在执行之前的预解析, 首先让 js 的执行引擎知道在当前运行环境中\n\t\t有什么东西( 名字, 标识符 )是可以被使用的. 它是变量, 还是函数等? \n\n\t-> 在 js 中有哪些声明: \n\t\t1) 标识符的声明( 变量的声明 )\n\t\t2) 函数的声明\n\n\t-> 变量的声明:\n\t\t语法: \t\tvar 变量名;\n\t\t目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.\n\n\t\t语句: 就是可以执行的东西.\n\t\t\tvar a = 123; 是一个语句\n\t\t在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理:\n\t\t-> 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了\n\t\t-> 如果没有标记, 就表明这个名字是一个标识符, 需要被标记\n\t\t-> 如果已经被标记了, 那么 这个 var 被忽略\n\n\t\t结论:\n\t\t\tvar a;\n\t\t\tvar a = 10;\n\t\t\t等价\n\t\t\tvar a;\n\t\t\ta = 10;\n\n\t\t\tvar a = 123;\n\t\t\tvar a = 456;\n\t\t\tvar a = 789;\n\t\t\t等价于\n\t\t\tvar a = 123;\n\t\t\ta = 456;\n\t\t\ta = 789;\n\n\t\t如果在代码中有多个 var 后面紧跟的名字是一样的. 那么只有第一个 var 起作用.\n\t\t后面的所有 var 都会被自动的忽略.\n\n\t-> 变量名提升\n\n\t-> 函数的声明\n\t\t-> 函数的各种定义形式\n\t\t\t-> 声明式:\t\n\t\t\t\tfunction func () {\n\t\t\t\t\tconsole.log( '使用声明式定义' );\n\t\t\t\t}\n\t\t\t-> 表达式式( 匿名函数, 字面量函数, lambda 函数 ):\n\t\t\t\tvar func = function () {\n\t\t\t\t\tconsole.log( '使用表达式式定义' );\n\t\t\t\t};\n\t\t\t-> ... \n\t\t-> 特点:\n\t\t\t1> 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.\n\t\t\t2> 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.\n\n\t\t-> 表达式:\n\t\t\t-> 将运算符与操作数连接起来的式子.\n\t\t\t-> 就是一个有结果的代码单元( 不包括语句 )\n\t\t\t\tvar a;\t\t// 声明, 不是语句, 也没有结果\n\t\t\t\t123\t\t\t// 字面量, 有值, 是表达式. 是常量表达式\n\t\t\t\ta = 123\t\t// 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.\n\n\t\t\t\tfunction () {}\n\n5. 如果将变量的声明与函数的声明放在一起有些需要注意的情况\n\t1) 函数的声明实际上包含两部分\n\t\t1> 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 )\n\t\t2> 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 )\n\t2) 当函数声明与变量声明冲突的时候. 只看谁先有数据.\n\n6. 一个在新版本的浏览器中的特性\n\tif ( true ) {\n\t\tfunction foo() {\n\t\t\tconsole.log( true );\n\t\t}\n\t} else {\n\t\tfunction foo() {\n\t\t\tconsole.log( false );\n\t\t}\n\t}\n\tfoo();\n\n7. 词法作用域\n\t-> 作用域: 就是变量可以使用到不能使用的范围\n\t-> 块级作用域:\n\t\t-> 块: 代码块, 即 {  }\n\t\t-> 变量的使用从定义开始, 到其所在的块级作用域结束\n\t\t\t// js 伪代码\n\t\t\t{\n\t\t\t\tconsole.log( num );\t\t// error: num 未定义\n\t\t\t\tvar num = 123;\n\t\t\t\t{\n\t\t\t\t\tconsole.log( num ); // => 123\n\t\t\t\t}\n\n\t\t\t\tconsole.log( num ); \t// => 123\n\t\t\t}\n\t\t\tconsole.log( num );  // error: num 未定义\n\t\t-> 代表语言: C, C++, C#, Java, ...\n\t-> js 是词法作用域\n\t\t-> 词法: 就是定义, 书写代码的规则.\n\t\t-> 所以 所谓的 词法作用域, 就是 在书写代码的时候, 根据书写代码的结构\n\t\t\t就可以确定数据的访问范围的作用域.\n\t\t-> js 不受 块的影响, 即使在块中定义声明变量, 在块的外面依旧可以使用\n\t\t\tconsole.log( num );  // => undefined\n\t\t\t{\n\t\t\t\tvar num = 123;\n\t\t\t}\n\t\t\tconsole.log( num );  // => 123\n\t\t-> 所谓的 js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 全部代码中\n\t\t\t只有函数可以限定范围. 其他均不能限定访问范围. 在内部是一个独立的作用范围结构.\n\n\t\t-> 结论:\n\t\t\t词法作用域就是描述变量的访问范围:\n\t\t\t1> 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.\n\t\t\t2> 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.\n\t\t\t3> 所有变量的访问规则, 按照预解析规则来访问\n\n8. 案例\n\tvar num = 123;\n\tfunction f1 () {\n\t\tconsole.log( num );\n\t}\n\tfunction f2 () {\n\t\tconsole.log( num );\n\t\tvar num = 456;\n\t\tf1();\n\t\tconsole.log( num );\n\t}\n\tf2();\n\n\t1> 读取代码预解析. 得到 num, f1, f2\n\t2> 逐步的执行代码\n\t\t1) 赋值 num = 123;   注意 f1 和 f2 由于是函数, 所以也有数据.\n\t\t2) 调用 f2.\n\t\t\t进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num\n\t\t\t执行每一句代码\n\t\t\t-> 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined\n\t\t\t-> 赋值 num = 456\n\t\t\t-> 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否还有函数的声明. 如果有直接使用. 如果\n\t\t\t\t没有, 则在函数外面找, 看时候有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数\n\t\t\t-> 跳入 f1 函数中. 又要解析一次. 没有得到任何声明.\n\t\t\t-> 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. \n\t\t\t\t函数调用结束, 回到 f2 中.\n\t\t\t-> 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456.\n\n\n\t任务:\n\t\tvar num = 123;\n\t\tfunction f1 () {\n\t\t\tconsole.log( num );\n\t\t}\n\t\tfunction f2 () {\n\t\t\tconsole.log( num );   // => 123 , 456, 456\n\t\t\tnum = 456;\t\t\t\n\t\t\tf1();\n\t\t\tconsole.log( num );\n\t\t}\n\t\tf2();\n\n\n\n9. 案例\n\t(function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t})( 100 );\n\n\t拆解\n\t( 函数 ) ( 100 )\n\t第一个圆括号就是将函数变成表达式\n\t后面一个圆括号就是调用该函数\n\n\tvar func = function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t}\n\tfunc( 100 );\n\n\t注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明\n\tfunction ( a ) { ... }\n\t其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明.\n\n\t由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效.\n\t所以上面的代码, 等价于\n\tvar func = function ( a ) {\n\t\tconsole.log( a );\t\t\t// => 100\n\t\ta = 10;\n\t\tconsole.log( a );\t\t\t// => 10\n\t}\n\tfunc( 100 );\n\n\t// 变式\n\n\t(function ( a ) {\n\t\tconsole.log( a );\n\t\tvar a = 10;\n\t\tconsole.log( a );\n\t\tfunction a () {\n\t\t\tconsole.log( a );\n\t\t}\n\t\ta();\n\t})( 100 );\n\n\t1> 直接调用\n\t2> 进入到函数中, 已有声明 a 并且其值为 100\n\t3> 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. \n\t\t1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了\n\t\t2) 让 a 指向函数. 相当于\n\t\t\tvar a;\n\t\t\tfunction a () {}\n\t\t\t...\n\t4> 开始逐步执行每一句代码\n\t\t1) 打印 a. 所以打印函数体\n\t\t2) 赋值 a = 10\n\t\t3) 打印 a, 打印出 10\n\t\t4) 如果让 a 调用, 那么报错 error: a is not function\n\n10. 作用域链规则\n\t-> 什么是作用域链\n\t\t链指的就是访问规则\n\t\tfunction foo() {\n\t\t\tconsole.log( num );\n\t\t}\n\n\t\t--------------------\n\t\tfunction func () {\n\t\t\tfunction foo() {\n\t\t\t\tconsole.log( num );\n\t\t\t}\n\t\t\tfoo();\n\t\t}\n\n\t\t--------------------\n\t\tfunction F () {\n\t\t\tfunction func () {\n\t\t\t\tfunction foo() {\n\t\t\t\t\tconsole.log( num );\n\t\t\t\t}\n\t\t\t\tfoo();\n\t\t\t}\n\t\t\tfunc();\n\t\t}\n\t\t... ...\n\n\t\t由于这种一环套一环的访问规则, 这样的作用域构成一个链式结构. 所以直接称其为作用域链.\n\n\t-> 作用域链是用来做变量查找的. 因此变量可以存储什么东西. 链中就应该有什么东西. \n\t\t换句话说就是, 链里面存储的是各种对象. 可以将其想象成对象的序列( 数组 )\n\n11. 绘制作用域链的规则\n\t1> 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.\n\t2> 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.\n\t3> 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.\n\t4> 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.\n\t5> 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推.\n\n12. 分析代码的执行\n\t当作用域链绘制完成后. 代码的的分析也需要一步一步的完成.\n\t1> 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化\n\t2> 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.\n\t3> 如果找到变量, 直接使用. 如果没有找到变量在 上一级, n - 1 级中查找.\n\t4> 一直找下去, 知直到 0 级链. 如果 0 级链还没有就报错. xxx is not defined.\n\n13. 经典面试题\n\n14. 经典面试题的变式( 练习 )\n\t写一段代码, 生成 5 个 a 标签. 要求在 a 标签中分别显示出 1, 2, 3, 4, 5\n\t即最后得到 <a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>\n\n15. 闭包的概念\n\t-> 字面意义\n\t\t闭: 关闭, 封闭\n\t\t包: 包裹, 打包\n\t\t闭包的含义就是一个被包裹的隔离的空间.\n\t-> 在 js 中, 什么是闭包\n\t\t在 js 中函数是一个具有变量作用域隔离特性的一个内存结构, 即为一个闭包.\n\t\t\n\t\tfunction foo () {\n\t\t\t\n\t\t}\n\n16. 学习闭包, 在 js 中到底要解决什么问题\n\t在 js 中闭包要解决的问题就是间接的访问到这个被隔离的数据.\n\n\tfunction foo () {\n\t\tvar num = 123;\n\n\t}\n\n\t// 在外界访问到 num 中的数据. 怎么做?\n\n\n17. 函数, 在 js 中与普通的对象具有一样的意义\n\t-> 函数可以像变量一样使用\n\t\t-> 赋值\n\t\t-> 传递\n\n18. 闭包的间接访问\n\t-> 使用 return 数据不能直接访问原来的数据, 那么可以考虑利用函数的返回访问原始数据\n\n\tfunction foo () {\n\t\tvar num = 123;   // 原始数据\n\t\t\n\t\tfunction func () {\n\t\t\treturn num; // 它就是原始数据 num\n\t\t}\n\t\t\n\t\treturn func;\n\t}\n\n\n19，当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式。\n\t1）引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数。\n\t2）函数表达式带有名字，该名字只允许在函数内部使用。属于局部作用域。\n\t3）带有名字的函数表达式，函数的name属性即为该名字。\n\n\n\n\n\n\n\n\n","slug":"面向对象/面向对象第四天","published":1,"date":"2016-12-20T09:55:48.000Z","updated":"2019-04-26T06:38:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0ji003c7xuq61u00gwo","content":"<ol>\n<li><p>复习<br> 加入我希望所有的函数都具有 inherit 功能</p>\n<pre><code>function Person() {}\n\nvar Student = Person.inherit( 成员 );\n// 生成函数 Student, 但是 Student 里面的成员( this.XXX )\n// 由参数来提供, 而 Student 的对象, 继承自 Person 的对象\n</code></pre><p> 如果希望所有的函数都有 inherit 方法, 那么可以给 Function.prototype 添加该方法</p>\n</li>\n</ol>\n<ol>\n<li><p>代码的预解析<br> -&gt; 预解析</p>\n<pre><code>预\n解析\n\n提前的翻译解释, 在运行代码之前的一个解释.\n</code></pre><p> -&gt; 为什么需要它</p>\n<pre><code>-&gt; 编译型语言: C, C++, C#, Java\n    就是需要一个 &quot;翻译&quot; 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ).\n    然后存储成可执行文件. \n\n    提前翻译好, 运行时直接执行得结果\n\n-&gt; 解释型( 脚本型 ): JavaScript, SQL, ...\n    代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, \n    再执行一句代码.\n\n    一句一句的翻译执行. 每次运行都需要翻译一次.\n\n-&gt; 代码在执行之前, 需要快速的 &quot;预览&quot; 一遍. 那么可以尽可能提高执行效率.\n</code></pre></li>\n<li><p>在 js 中预解析的特点<br> -&gt; 代码是如何执行的: 读取 js 文本, 预解析, 一句一句地执行<br> -&gt; js 在预解析的过程中完成了声明部分的标记与变量作用域的设定</p>\n</li>\n<li><p>什么是 js 中的声明<br> -&gt; 简单的说就是让 js 执行引擎知道有什么东西( 标识符 )</p>\n<pre><code>console.log( num );    // error: num is not defined\nnum(); // error: is not function\n\n即代码在执行之前的预解析, 首先让 js 的执行引擎知道在当前运行环境中\n有什么东西( 名字, 标识符 )是可以被使用的. 它是变量, 还是函数等? \n</code></pre><p> -&gt; 在 js 中有哪些声明: </p>\n<pre><code>1) 标识符的声明( 变量的声明 )\n2) 函数的声明\n</code></pre><p> -&gt; 变量的声明:</p>\n<pre><code>语法:         var 变量名;\n目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.\n\n语句: 就是可以执行的东西.\n    var a = 123; 是一个语句\n在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理:\n-&gt; 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了\n-&gt; 如果没有标记, 就表明这个名字是一个标识符, 需要被标记\n-&gt; 如果已经被标记了, 那么 这个 var 被忽略\n\n结论:\n    var a;\n    var a = 10;\n    等价\n    var a;\n    a = 10;\n\n    var a = 123;\n    var a = 456;\n    var a = 789;\n    等价于\n    var a = 123;\n    a = 456;\n    a = 789;\n\n如果在代码中有多个 var 后面紧跟的名字是一样的. 那么只有第一个 var 起作用.\n后面的所有 var 都会被自动的忽略.\n</code></pre><p> -&gt; 变量名提升</p>\n<p> -&gt; 函数的声明</p>\n<pre><code>-&gt; 函数的各种定义形式\n    -&gt; 声明式:    \n        function func () {\n            console.log( &apos;使用声明式定义&apos; );\n        }\n    -&gt; 表达式式( 匿名函数, 字面量函数, lambda 函数 ):\n        var func = function () {\n            console.log( &apos;使用表达式式定义&apos; );\n        };\n    -&gt; ... \n-&gt; 特点:\n    1&gt; 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.\n    2&gt; 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.\n\n-&gt; 表达式:\n    -&gt; 将运算符与操作数连接起来的式子.\n    -&gt; 就是一个有结果的代码单元( 不包括语句 )\n        var a;        // 声明, 不是语句, 也没有结果\n        123            // 字面量, 有值, 是表达式. 是常量表达式\n        a = 123        // 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.\n\n        function () {}\n</code></pre></li>\n<li><p>如果将变量的声明与函数的声明放在一起有些需要注意的情况<br> 1) 函数的声明实际上包含两部分</p>\n<pre><code>1&gt; 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 )\n2&gt; 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 )\n</code></pre><p> 2) 当函数声明与变量声明冲突的时候. 只看谁先有数据.</p>\n</li>\n<li><p>一个在新版本的浏览器中的特性<br> if ( true ) {</p>\n<pre><code>function foo() {\n    console.log( true );\n}\n</code></pre><p> } else {</p>\n<pre><code>function foo() {\n    console.log( false );\n}\n</code></pre><p> }<br> foo();</p>\n</li>\n<li><p>词法作用域<br> -&gt; 作用域: 就是变量可以使用到不能使用的范围<br> -&gt; 块级作用域:</p>\n<pre><code>-&gt; 块: 代码块, 即 {  }\n-&gt; 变量的使用从定义开始, 到其所在的块级作用域结束\n    // js 伪代码\n    {\n        console.log( num );        // error: num 未定义\n        var num = 123;\n        {\n            console.log( num ); // =&gt; 123\n        }\n\n        console.log( num );     // =&gt; 123\n    }\n    console.log( num );  // error: num 未定义\n-&gt; 代表语言: C, C++, C#, Java, ...\n</code></pre><p> -&gt; js 是词法作用域</p>\n<pre><code>-&gt; 词法: 就是定义, 书写代码的规则.\n-&gt; 所以 所谓的 词法作用域, 就是 在书写代码的时候, 根据书写代码的结构\n    就可以确定数据的访问范围的作用域.\n-&gt; js 不受 块的影响, 即使在块中定义声明变量, 在块的外面依旧可以使用\n    console.log( num );  // =&gt; undefined\n    {\n        var num = 123;\n    }\n    console.log( num );  // =&gt; 123\n-&gt; 所谓的 js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 全部代码中\n    只有函数可以限定范围. 其他均不能限定访问范围. 在内部是一个独立的作用范围结构.\n\n-&gt; 结论:\n    词法作用域就是描述变量的访问范围:\n    1&gt; 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.\n    2&gt; 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.\n    3&gt; 所有变量的访问规则, 按照预解析规则来访问\n</code></pre></li>\n<li><p>案例<br> var num = 123;<br> function f1 () {</p>\n<pre><code>console.log( num );\n</code></pre><p> }<br> function f2 () {</p>\n<pre><code>console.log( num );\nvar num = 456;\nf1();\nconsole.log( num );\n</code></pre><p> }<br> f2();</p>\n<p> 1&gt; 读取代码预解析. 得到 num, f1, f2<br> 2&gt; 逐步的执行代码</p>\n<pre><code>1) 赋值 num = 123;   注意 f1 和 f2 由于是函数, 所以也有数据.\n2) 调用 f2.\n    进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num\n    执行每一句代码\n    -&gt; 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined\n    -&gt; 赋值 num = 456\n    -&gt; 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否还有函数的声明. 如果有直接使用. 如果\n        没有, 则在函数外面找, 看时候有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数\n    -&gt; 跳入 f1 函数中. 又要解析一次. 没有得到任何声明.\n    -&gt; 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. \n        函数调用结束, 回到 f2 中.\n    -&gt; 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456.\n</code></pre></li>\n</ol>\n<pre><code>任务:\n    var num = 123;\n    function f1 () {\n        console.log( num );\n    }\n    function f2 () {\n        console.log( num );   // =&gt; 123 , 456, 456\n        num = 456;            \n        f1();\n        console.log( num );\n    }\n    f2();\n</code></pre><ol>\n<li><p>案例<br> (function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\n</code></pre><p> })( 100 );</p>\n<p> 拆解<br> ( 函数 ) ( 100 )<br> 第一个圆括号就是将函数变成表达式<br> 后面一个圆括号就是调用该函数</p>\n<p> var func = function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\n</code></pre><p> }<br> func( 100 );</p>\n<p> 注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明<br> function ( a ) { … }<br> 其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明.</p>\n<p> 由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效.<br> 所以上面的代码, 等价于<br> var func = function ( a ) {</p>\n<pre><code>console.log( a );            // =&gt; 100\na = 10;\nconsole.log( a );            // =&gt; 10\n</code></pre><p> }<br> func( 100 );</p>\n<p> // 变式</p>\n<p> (function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\nfunction a () {\n    console.log( a );\n}\na();\n</code></pre><p> })( 100 );</p>\n<p> 1&gt; 直接调用<br> 2&gt; 进入到函数中, 已有声明 a 并且其值为 100<br> 3&gt; 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. </p>\n<pre><code>1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了\n2) 让 a 指向函数. 相当于\n    var a;\n    function a () {}\n    ...\n</code></pre><p> 4&gt; 开始逐步执行每一句代码</p>\n<pre><code>1) 打印 a. 所以打印函数体\n2) 赋值 a = 10\n3) 打印 a, 打印出 10\n4) 如果让 a 调用, 那么报错 error: a is not function\n</code></pre></li>\n<li><p>作用域链规则<br>-&gt; 什么是作用域链</p>\n<pre><code>链指的就是访问规则\nfunction foo() {\n    console.log( num );\n}\n\n--------------------\nfunction func () {\n    function foo() {\n        console.log( num );\n    }\n    foo();\n}\n\n--------------------\nfunction F () {\n    function func () {\n        function foo() {\n            console.log( num );\n        }\n        foo();\n    }\n    func();\n}\n... ...\n\n由于这种一环套一环的访问规则, 这样的作用域构成一个链式结构. 所以直接称其为作用域链.\n</code></pre><p>-&gt; 作用域链是用来做变量查找的. 因此变量可以存储什么东西. 链中就应该有什么东西. </p>\n<pre><code>换句话说就是, 链里面存储的是各种对象. 可以将其想象成对象的序列( 数组 )\n</code></pre></li>\n<li><p>绘制作用域链的规则<br>1&gt; 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.<br>2&gt; 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.<br>3&gt; 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.<br>4&gt; 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.<br>5&gt; 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推.</p>\n</li>\n<li><p>分析代码的执行<br>当作用域链绘制完成后. 代码的的分析也需要一步一步的完成.<br>1&gt; 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化<br>2&gt; 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.<br>3&gt; 如果找到变量, 直接使用. 如果没有找到变量在 上一级, n - 1 级中查找.<br>4&gt; 一直找下去, 知直到 0 级链. 如果 0 级链还没有就报错. xxx is not defined.</p>\n</li>\n<li><p>经典面试题</p>\n</li>\n<li><p>经典面试题的变式( 练习 )<br>写一段代码, 生成 5 个 a 标签. 要求在 a 标签中分别显示出 1, 2, 3, 4, 5<br>即最后得到 <a>1</a><a>2</a><a>3</a><a>4</a><a>5</a></p>\n</li>\n<li><p>闭包的概念<br>-&gt; 字面意义</p>\n<pre><code>闭: 关闭, 封闭\n包: 包裹, 打包\n闭包的含义就是一个被包裹的隔离的空间.\n</code></pre><p>-&gt; 在 js 中, 什么是闭包</p>\n<pre><code>在 js 中函数是一个具有变量作用域隔离特性的一个内存结构, 即为一个闭包.\n\nfunction foo () {\n\n}\n</code></pre></li>\n<li><p>学习闭包, 在 js 中到底要解决什么问题<br>在 js 中闭包要解决的问题就是间接的访问到这个被隔离的数据.</p>\n<p>function foo () {</p>\n<pre><code>var num = 123;\n</code></pre><p>}</p>\n<p>// 在外界访问到 num 中的数据. 怎么做?</p>\n</li>\n</ol>\n<ol>\n<li><p>函数, 在 js 中与普通的对象具有一样的意义<br>-&gt; 函数可以像变量一样使用</p>\n<pre><code>-&gt; 赋值\n-&gt; 传递\n</code></pre></li>\n<li><p>闭包的间接访问<br>-&gt; 使用 return 数据不能直接访问原来的数据, 那么可以考虑利用函数的返回访问原始数据</p>\n<p>function foo () {</p>\n<pre><code>var num = 123;   // 原始数据\n\nfunction func () {\n    return num; // 它就是原始数据 num\n}\n\nreturn func;\n</code></pre><p>}</p>\n</li>\n</ol>\n<p>19，当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式。<br>    1）引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数。<br>    2）函数表达式带有名字，该名字只允许在函数内部使用。属于局部作用域。<br>    3）带有名字的函数表达式，函数的name属性即为该名字。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>复习<br> 加入我希望所有的函数都具有 inherit 功能</p>\n<pre><code>function Person() {}\n\nvar Student = Person.inherit( 成员 );\n// 生成函数 Student, 但是 Student 里面的成员( this.XXX )\n// 由参数来提供, 而 Student 的对象, 继承自 Person 的对象\n</code></pre><p> 如果希望所有的函数都有 inherit 方法, 那么可以给 Function.prototype 添加该方法</p>\n</li>\n</ol>\n<ol>\n<li><p>代码的预解析<br> -&gt; 预解析</p>\n<pre><code>预\n解析\n\n提前的翻译解释, 在运行代码之前的一个解释.\n</code></pre><p> -&gt; 为什么需要它</p>\n<pre><code>-&gt; 编译型语言: C, C++, C#, Java\n    就是需要一个 &quot;翻译&quot; 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ).\n    然后存储成可执行文件. \n\n    提前翻译好, 运行时直接执行得结果\n\n-&gt; 解释型( 脚本型 ): JavaScript, SQL, ...\n    代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, \n    再执行一句代码.\n\n    一句一句的翻译执行. 每次运行都需要翻译一次.\n\n-&gt; 代码在执行之前, 需要快速的 &quot;预览&quot; 一遍. 那么可以尽可能提高执行效率.\n</code></pre></li>\n<li><p>在 js 中预解析的特点<br> -&gt; 代码是如何执行的: 读取 js 文本, 预解析, 一句一句地执行<br> -&gt; js 在预解析的过程中完成了声明部分的标记与变量作用域的设定</p>\n</li>\n<li><p>什么是 js 中的声明<br> -&gt; 简单的说就是让 js 执行引擎知道有什么东西( 标识符 )</p>\n<pre><code>console.log( num );    // error: num is not defined\nnum(); // error: is not function\n\n即代码在执行之前的预解析, 首先让 js 的执行引擎知道在当前运行环境中\n有什么东西( 名字, 标识符 )是可以被使用的. 它是变量, 还是函数等? \n</code></pre><p> -&gt; 在 js 中有哪些声明: </p>\n<pre><code>1) 标识符的声明( 变量的声明 )\n2) 函数的声明\n</code></pre><p> -&gt; 变量的声明:</p>\n<pre><code>语法:         var 变量名;\n目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.\n\n语句: 就是可以执行的东西.\n    var a = 123; 是一个语句\n在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理:\n-&gt; 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了\n-&gt; 如果没有标记, 就表明这个名字是一个标识符, 需要被标记\n-&gt; 如果已经被标记了, 那么 这个 var 被忽略\n\n结论:\n    var a;\n    var a = 10;\n    等价\n    var a;\n    a = 10;\n\n    var a = 123;\n    var a = 456;\n    var a = 789;\n    等价于\n    var a = 123;\n    a = 456;\n    a = 789;\n\n如果在代码中有多个 var 后面紧跟的名字是一样的. 那么只有第一个 var 起作用.\n后面的所有 var 都会被自动的忽略.\n</code></pre><p> -&gt; 变量名提升</p>\n<p> -&gt; 函数的声明</p>\n<pre><code>-&gt; 函数的各种定义形式\n    -&gt; 声明式:    \n        function func () {\n            console.log( &apos;使用声明式定义&apos; );\n        }\n    -&gt; 表达式式( 匿名函数, 字面量函数, lambda 函数 ):\n        var func = function () {\n            console.log( &apos;使用表达式式定义&apos; );\n        };\n    -&gt; ... \n-&gt; 特点:\n    1&gt; 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.\n    2&gt; 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.\n\n-&gt; 表达式:\n    -&gt; 将运算符与操作数连接起来的式子.\n    -&gt; 就是一个有结果的代码单元( 不包括语句 )\n        var a;        // 声明, 不是语句, 也没有结果\n        123            // 字面量, 有值, 是表达式. 是常量表达式\n        a = 123        // 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.\n\n        function () {}\n</code></pre></li>\n<li><p>如果将变量的声明与函数的声明放在一起有些需要注意的情况<br> 1) 函数的声明实际上包含两部分</p>\n<pre><code>1&gt; 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 )\n2&gt; 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 )\n</code></pre><p> 2) 当函数声明与变量声明冲突的时候. 只看谁先有数据.</p>\n</li>\n<li><p>一个在新版本的浏览器中的特性<br> if ( true ) {</p>\n<pre><code>function foo() {\n    console.log( true );\n}\n</code></pre><p> } else {</p>\n<pre><code>function foo() {\n    console.log( false );\n}\n</code></pre><p> }<br> foo();</p>\n</li>\n<li><p>词法作用域<br> -&gt; 作用域: 就是变量可以使用到不能使用的范围<br> -&gt; 块级作用域:</p>\n<pre><code>-&gt; 块: 代码块, 即 {  }\n-&gt; 变量的使用从定义开始, 到其所在的块级作用域结束\n    // js 伪代码\n    {\n        console.log( num );        // error: num 未定义\n        var num = 123;\n        {\n            console.log( num ); // =&gt; 123\n        }\n\n        console.log( num );     // =&gt; 123\n    }\n    console.log( num );  // error: num 未定义\n-&gt; 代表语言: C, C++, C#, Java, ...\n</code></pre><p> -&gt; js 是词法作用域</p>\n<pre><code>-&gt; 词法: 就是定义, 书写代码的规则.\n-&gt; 所以 所谓的 词法作用域, 就是 在书写代码的时候, 根据书写代码的结构\n    就可以确定数据的访问范围的作用域.\n-&gt; js 不受 块的影响, 即使在块中定义声明变量, 在块的外面依旧可以使用\n    console.log( num );  // =&gt; undefined\n    {\n        var num = 123;\n    }\n    console.log( num );  // =&gt; 123\n-&gt; 所谓的 js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 全部代码中\n    只有函数可以限定范围. 其他均不能限定访问范围. 在内部是一个独立的作用范围结构.\n\n-&gt; 结论:\n    词法作用域就是描述变量的访问范围:\n    1&gt; 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.\n    2&gt; 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.\n    3&gt; 所有变量的访问规则, 按照预解析规则来访问\n</code></pre></li>\n<li><p>案例<br> var num = 123;<br> function f1 () {</p>\n<pre><code>console.log( num );\n</code></pre><p> }<br> function f2 () {</p>\n<pre><code>console.log( num );\nvar num = 456;\nf1();\nconsole.log( num );\n</code></pre><p> }<br> f2();</p>\n<p> 1&gt; 读取代码预解析. 得到 num, f1, f2<br> 2&gt; 逐步的执行代码</p>\n<pre><code>1) 赋值 num = 123;   注意 f1 和 f2 由于是函数, 所以也有数据.\n2) 调用 f2.\n    进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num\n    执行每一句代码\n    -&gt; 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined\n    -&gt; 赋值 num = 456\n    -&gt; 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否还有函数的声明. 如果有直接使用. 如果\n        没有, 则在函数外面找, 看时候有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数\n    -&gt; 跳入 f1 函数中. 又要解析一次. 没有得到任何声明.\n    -&gt; 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. \n        函数调用结束, 回到 f2 中.\n    -&gt; 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456.\n</code></pre></li>\n</ol>\n<pre><code>任务:\n    var num = 123;\n    function f1 () {\n        console.log( num );\n    }\n    function f2 () {\n        console.log( num );   // =&gt; 123 , 456, 456\n        num = 456;            \n        f1();\n        console.log( num );\n    }\n    f2();\n</code></pre><ol>\n<li><p>案例<br> (function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\n</code></pre><p> })( 100 );</p>\n<p> 拆解<br> ( 函数 ) ( 100 )<br> 第一个圆括号就是将函数变成表达式<br> 后面一个圆括号就是调用该函数</p>\n<p> var func = function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\n</code></pre><p> }<br> func( 100 );</p>\n<p> 注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明<br> function ( a ) { … }<br> 其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明.</p>\n<p> 由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效.<br> 所以上面的代码, 等价于<br> var func = function ( a ) {</p>\n<pre><code>console.log( a );            // =&gt; 100\na = 10;\nconsole.log( a );            // =&gt; 10\n</code></pre><p> }<br> func( 100 );</p>\n<p> // 变式</p>\n<p> (function ( a ) {</p>\n<pre><code>console.log( a );\nvar a = 10;\nconsole.log( a );\nfunction a () {\n    console.log( a );\n}\na();\n</code></pre><p> })( 100 );</p>\n<p> 1&gt; 直接调用<br> 2&gt; 进入到函数中, 已有声明 a 并且其值为 100<br> 3&gt; 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. </p>\n<pre><code>1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了\n2) 让 a 指向函数. 相当于\n    var a;\n    function a () {}\n    ...\n</code></pre><p> 4&gt; 开始逐步执行每一句代码</p>\n<pre><code>1) 打印 a. 所以打印函数体\n2) 赋值 a = 10\n3) 打印 a, 打印出 10\n4) 如果让 a 调用, 那么报错 error: a is not function\n</code></pre></li>\n<li><p>作用域链规则<br>-&gt; 什么是作用域链</p>\n<pre><code>链指的就是访问规则\nfunction foo() {\n    console.log( num );\n}\n\n--------------------\nfunction func () {\n    function foo() {\n        console.log( num );\n    }\n    foo();\n}\n\n--------------------\nfunction F () {\n    function func () {\n        function foo() {\n            console.log( num );\n        }\n        foo();\n    }\n    func();\n}\n... ...\n\n由于这种一环套一环的访问规则, 这样的作用域构成一个链式结构. 所以直接称其为作用域链.\n</code></pre><p>-&gt; 作用域链是用来做变量查找的. 因此变量可以存储什么东西. 链中就应该有什么东西. </p>\n<pre><code>换句话说就是, 链里面存储的是各种对象. 可以将其想象成对象的序列( 数组 )\n</code></pre></li>\n<li><p>绘制作用域链的规则<br>1&gt; 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.<br>2&gt; 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.<br>3&gt; 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.<br>4&gt; 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.<br>5&gt; 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推.</p>\n</li>\n<li><p>分析代码的执行<br>当作用域链绘制完成后. 代码的的分析也需要一步一步的完成.<br>1&gt; 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化<br>2&gt; 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.<br>3&gt; 如果找到变量, 直接使用. 如果没有找到变量在 上一级, n - 1 级中查找.<br>4&gt; 一直找下去, 知直到 0 级链. 如果 0 级链还没有就报错. xxx is not defined.</p>\n</li>\n<li><p>经典面试题</p>\n</li>\n<li><p>经典面试题的变式( 练习 )<br>写一段代码, 生成 5 个 a 标签. 要求在 a 标签中分别显示出 1, 2, 3, 4, 5<br>即最后得到 <a>1</a><a>2</a><a>3</a><a>4</a><a>5</a></p>\n</li>\n<li><p>闭包的概念<br>-&gt; 字面意义</p>\n<pre><code>闭: 关闭, 封闭\n包: 包裹, 打包\n闭包的含义就是一个被包裹的隔离的空间.\n</code></pre><p>-&gt; 在 js 中, 什么是闭包</p>\n<pre><code>在 js 中函数是一个具有变量作用域隔离特性的一个内存结构, 即为一个闭包.\n\nfunction foo () {\n\n}\n</code></pre></li>\n<li><p>学习闭包, 在 js 中到底要解决什么问题<br>在 js 中闭包要解决的问题就是间接的访问到这个被隔离的数据.</p>\n<p>function foo () {</p>\n<pre><code>var num = 123;\n</code></pre><p>}</p>\n<p>// 在外界访问到 num 中的数据. 怎么做?</p>\n</li>\n</ol>\n<ol>\n<li><p>函数, 在 js 中与普通的对象具有一样的意义<br>-&gt; 函数可以像变量一样使用</p>\n<pre><code>-&gt; 赋值\n-&gt; 传递\n</code></pre></li>\n<li><p>闭包的间接访问<br>-&gt; 使用 return 数据不能直接访问原来的数据, 那么可以考虑利用函数的返回访问原始数据</p>\n<p>function foo () {</p>\n<pre><code>var num = 123;   // 原始数据\n\nfunction func () {\n    return num; // 它就是原始数据 num\n}\n\nreturn func;\n</code></pre><p>}</p>\n</li>\n</ol>\n<p>19，当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式。<br>    1）引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数。<br>    2）函数表达式带有名字，该名字只允许在函数内部使用。属于局部作用域。<br>    3）带有名字的函数表达式，函数的name属性即为该名字。</p>\n"},{"title":"javascript 面向对象：1","_content":"### 一、 面向对象：是一个基于对象的多范式的编程语言\n\t多范式：编程风格\n\t\t面向过程的方法编程\n\t\t面向对象的方式编程\n\t\t函数式\n### 二、 面向对象的基本概念\n- JS 是不是一个面向对象的语言?\n\t不是: 与传统面向对象的理论有矛盾. C#, JAVA\n\t是: JS 里面到处都是对象. 数组, 时间, 正则 ... 和 DOM\n\t\t也可以像传统面向对象的语言那样用 NEW 的方式创建对象\n\n- JS 是一个基于对象的多范式的编程语言\n\n\t多范式: 编程风格\n\t\t面向过程的方式编程\n\t\t面向对象的方式编程\n\t\t函数式 ...\n- 函数式的一个特点: 递归与链式\n\tJQUERY 就是典型的链式编程风格\n\t比如: 给 DIV 标签添加样式\n\t\t$( 'DIV' ).CSS( 'BORDER', '1PX SOLID RED' )\n\t\t\t\t\t.CSS( 'WIDTH', '400PX' )\n\t\t\t\t\t.CSS( 'HEIGHT', '200PX' );\n- 面向对象的概念\n\t\t-> 面向: 将脸朝向 ... -> 关注, 用\n\t\t\t面向过程开发 -> 使用过程的方式开发\n\t\t\t面向对象开发 -> 使用对象开发\n\t\t-> 面向过程\n\t\t\t早上吃早饭: 吃面\n\t\t\t自己做: 和面 -> 压成细面 -> 烧水 -> 煮面 -> 盛面 -> 吃\n\t\t\t过程: 步骤, 细节, 顺序等\n\t\t-> 今天早上\n\t\t\t找到对象: 找到面馆 -> 要 -> 吃\n\t\t-> 面向对象: \n\t\t\t要做什么, 就找到对应的对象, 告诉它做, 等结果\n\t\t-> 生活\n\t\t\t买菜: 菜场\n\t\t\t公交\n\t\t\t电话\n\t\t\t...\n\t\t-> 是否说面向对象可以取代面向过程\n\t\t\t面向对象是面向过程的封装\n\t-> 万物皆对象\n\t\t在实际开发中, 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集.\n\t\t-> 数据集: 很多数据打包到一起. { NAME: '张三', AGE: 19, GENDER: '男' }\n\t\t\t\t假设展示 10 条商品数据. 每一个商品: 名字, 描述, 价格, 图片\n\t\t\t\t-> \n\t\t\t\t每一条数据可以变成对象: { NAME:'', DESC: '', PRICE: 0, IMG: '' }\n\t\t\t\t-> 引入数组, 将数据存储到数组中\n\t\t-> 功能集(函数集, 方法集)\n\t\t-> 在 JS 中, 所谓的对象就是 键值对的 集合\n\t\t-> 也可以混合使用\n\t\t\t例如 JQUERY:\n\t\t\t\t$( 'DIV' )\t这个是一个 JQ 对象, 但是实际上里面包含 DOM 对象\n\t\t\t\t$( 'DIV' ).CSS( ... )\n\t\t\t \t$( 'DIV' ).HTML( ... )\t是不是就说明 JQ 对象中包含方法\n\t-> 抽象性\n\t\t商品列表: 书店, 书的列表\n\t\t\t书名, 页数, 简介, 编号, 作者\t\t\t对象只包含最核心的主要信息\n\t\t游戏人物: 英雄\n\t\t\t名字, 血量, 防御, 攻击, 护甲, 武器\t\t只需要描述出需要的数据即可\n\t\n\t-> 名词提炼法找对象\n\t\t做一个表格排序\n\t\t\t-> 过程\n\t\t\t\t1) 创建表格\n\t\t\t\t2) 添加点击事件\n\t\t\t\t3) 排序, 更新数据\n\t\t\t-> 对象\n\t\t\t\t1) 创建表格对象\n\t\t\t\t2) 添加数据\n\t-> 实际开发的时候如果需要完成一个功能\n\t\t-> 首先考虑系统是否提供了对象\n\t\t\t例如创建图片: VAR IMG = NEW IMAGE(); IMG.SRC = '...JPG';\n\t\t\t例如获取页面元素: DOCUMENT, 标签对象\n\t\t\t例如获得导航栏里面的所有的 LI 标签\n\t\t\t\tVAR NAV = DOCUMENT.GETELEMENTSBYID( 'NAV' );    // NAVIGATION\n\t\t\t\tVAR LIS = NAV.GETELEMENTSBYTAGNAME( 'LI' );\n\t\t-> 如果系统没有可以考虑自定义, 或第三方\n\t\t\tVAR ITCAST = {\n\t\t\t\tTAG: FUNCTION ( TAGNAME ) {\n\t\t\t\t\tRETURN DOCUMENT.GETELEMENTSBYTAGNAME( TAGNAME );\n\t\t\t\t}, ADDCSS: FUNCTION ( ARRAY, STYLES ) {\n\t\t\t\t\tFOR ( VAR I = 0; I < ARRAY.LENGTH; I++ ) {\n\t\t\t\t\t\tFOR ( VAR K IN STYLES ) {\n\t\t\t\t\t\t\tARRAY[ I ].STYLE[ K ] = STYLES[ K ]; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, ID: FUNCTION () {},\n\t\t\t\tCNAME: FUNCTION () {},\n\t\t\t\tNAME: ...\n\t\t\t\tATTR: ...\n\t\t\t\tCLASS: ...\n\t\t\t\t...\n\t\t\t};\n\n3. 开发者工具的打开: F12\n\n\t火狐的 FIREBUG\n\n4. 调试按钮\n\t-> 逐语句: 单步运行. 就是一次只执行一句话. 如果遇到函数, 进入函数体内一步一步执行\n\t-> 逐过程: 一次执行一个过程. 如果是一条语句那么与逐语句是一样的. 但是如果是一个函\n\t\t\t\t数, 那么他就会将函数执行完, 然后在往下走, 停下来.\n\t-> 继续运行\n\n5. 条件断点\n\t就是只有在 条件满足的时候(表达式为真的时候) 才会停下来的断点 \n\n6. 利用调试工具实现列表播放\n\tH5 提供了 两个标签, 一个是 AUDIO, 一个是 VIDEO\n\tAUDIO 主要是用来播放音乐的\n\tVIDEO 用来播放视频\n\n\t如果标签设置了属性\n\t\tAUTOPLAY\n\t\tSRC\n\t我希望当一个音乐播放完成后, 自动播放下一首\n\n7. 数据在内存中的存储形式(识记)\n\t计算机只认识数字\n\t计算机根据是否有电信号表示1或0: 准确的说是高低电平\n\t有了二进制数据( 有兴趣的同学可以学习如何转换 )\n\n\t计算机只认识数组, 那么如何表示语言\n\tASCII 码\n\t\t0 ~ 127 数字 对应的 表示成 字母\n\t\t前 32 个 是控制字符\n\t\t从 32 开始 到 127 是可视化字符\n\t\t'0'\t\t\t48\n\t\t'A'\t\t\t97\n\t\t'A'\t\t\t65\n\t有了这样一个对应关系(映射 MAP), 那么一段文字就可以使用一串数字表示了\n\n\t表示中文的 GB2312 编码, 简体中文编码. 英文标点和数字等使用一个字节\n\t\t\t\t\t\t\t\t\t\t  中文使用两个字节.\n\tUNICODE 编码( 万国码 ). 所有的字符才偶用两个字节表示.\n\t\t\t\t\t\t\t例如表示字符 'A'\t2 个字节\n\t\t\t\t\t\t\t在页面中使用最多的是: 数字, 字母, 标点符号\n\tUTF-8 编码( 通用转换格式 ). 所有与 ASCII 编码相符的字符采用一个字节.\n\t\t\t\t\t\t\t\t而汉字采用 3 个字节.\n\n8. 在 JS 中允许使用 UNICODE 编码表示字符串\n\t语法: \\U + 4 位 16 进制数\n\n\t使用这种方式表示数据, 在表示 与 ASCII 码重合字符是没有意义的. 但是对于中文\n\t由于存在不同的编码, 而不同编码在不同平台上可以正常显示, 但是随着网络传播, \n\t不是在所有平台上可以通用. 因此数据传送中文一般采用 UNICODE 编码形式.\n\n9. 数字 + 上下文 = 信息\n\t97\t\t'A'    数字 97\n\n\t在此处不要深究, 只需要了解内存模型即可.\n\n\t内存就是一个可以存储数字( 数据 )的盒子.\n\n\n10. JS 的数据类型\n\t-> 基本类型( 值类型 ): 数字 NUMBER, 字符串 STRING, 布尔 BOOLEAN\n\t-> 复合类型( 引用类型 ): 对象( 数组, 时间类型, 函数类型, 正则表达式, ... )\n\t-> 空类型: NULL, UNDEFINED\n\n\n\t基本数据类型和空类型的存储模型就是一个方格里面放一个数据\n\t复合类型, 除了函数, 其他的数据类型无法使用 TYPEOF 获得数据类型名\n\t注意: 如果需要获得对象的数据类型, 需要使用 OBJECT.PROTOTYPE.TOSTRING.APPLY( 数据 )\n\n11. 复合类型的存储方式\n\tVAR P = { NAME: 'ITCAST' }\n\n\t复合类型的对象是一个单独的内存区域, 对象有什么属性, 那么内存区域中就有什么数据.\n\t变量 P 只存储该对象的 '地址'. 所以 P 不是真正存储数据的区域.\n\n\t绘制数据的内存逻辑图\n\n\tVAR ARR1 = [ 1, 2, 3, 4 ];\n\tVAR ARR2 = [\n\t\t{ NAME: '张三', AGE: 19, GENDER: '男' },\n\t\t{ NAME: '李四', AGE: 18, GENDER: '男' },\n\t\t{ NAME: '小李', AGE: 17, GENDER: '女' }\n\t];\n\n12. 值类型与引用类型的存储特征\n\t-> 值类型的数据, 只需要开辟一段内存存储数据即可\n\t\tVAR A = 123; \n\t\tVAR B = 'ABC';\n\t\tVAR C = TRUE;\n\t-> 对象类型( 引用类型 ). 对象才是真正的数据, 需要占据单独的内存.\n\t\t而变量名只是存储着对象的内存地址( 引用 ).\n\n\t\t即创建一个对象并赋值, 实际上需要两块内存空间. 一个存储数据( 对象 ),\n\t\t另一个存储变量以引用对象.\n\n\t\tVAR O = { NAME: '张三', AGE: 19, GENDER: '男' };\n\n\n13. 值类型与引用类型的赋值与传参的特性\n\t-> 赋值: 将原变量中的数据拷贝一份, 然后存储到给定变量中\n\t\t-> 值类型\n\t\t\tVAR A = 123;\t// 有一个盒子, 叫 A, 里面存储着数字 123\n\t\t\tVAR B;\t\t\t// 又有一个盒子, 叫 B, 里面什么都没存( UNDEFINED )\n\t\t\tB = A;\t\t\t// 将 A 中存储的东西复制一份, 然后赋值给 B. 即存储在 B 中\n\n\t\t\tB 和 A 是两个独立的变量, 两者之间不再有关系. 改变其中一个数据, 另一个不变\n\t\t-> 引用类型\n\t\t\tVAR O1 = { NUM: 123 };\n\t\t\tVAR O2;\n\t\t\t// 赋值\n\t\t\tO2 = O1; \t// 将 O1 中存储的内容 拷贝一份 存储到 O2 中\n\t\t\t\t\t\t// O1 中存储的是引用, 或 '地址'\n\n\t\t\tO1 和 O2 虽然是不相同的两个变量, 即两个独立的盒子. 但是由于存储的地址相同.\n\t\t\t在访问数据的时候, O1 与 O2 也是访问同一个数据, O1 将数据修改了, O2 再读取,\n\t\t\t读取的就是修改后的数据. \n\t-> 函数参数传递\n\t\t-> 什么是函数参数传递\n\t\t\t函数要调用, 一般会给函数传递参数\n\t\t\t\t在调用函数的时候, 回将参数中表示的数据拷贝一份, 然后给参数赋值\n\t\t\tFUNCTION FOO( NUM ) {}\n\n\t\t\t// 调用\n\t\t\tVAR A = 123;\n\t\t\tFOO( A );\t\t// 调用函数就是要执行函数\n\t\t\t\t\t\t\t// 将 A 中存储的数据 拷贝一份\n\t\t\t\t\t\t\t// 进入 函数 FOO\n\t\t\t\t\t\t\t// 给参数赋值, 相当于 NUM = A\n\t\t\t\t\t\t\t// 进入函数体, 开始执行函数\n\t\t\t此时的赋值特性与前面介绍的值类型引用类型的赋值是一个特点\n\n14. 深拷贝与浅拷贝\n\t-> 什么是拷贝: 就是创建一个与目标数据一模一样的数据\n\t-> 案例:\n\t\tVAR P = { NAME: '张三' };\n\t\tVAR P1 = P;   \t\t\t\t// 是否存在拷贝\n \t\t// 一般描述拷贝是指拷贝对象\n \t\tP1 = {};\n \t\tP1.NAME = P.NAME;\n \t\t// 才是拷贝\n \t-> 案例, 给 对象 P 提供一个 CLONE 方法, 完成拷贝\n \t-> 案例:\n \t\t有一辆汽车 CAR: NAME=保时捷\n \t\t有一个人 PERSON : NAME=张三\n \t-> 如果对象的属性也是一个引用类型, 拷贝的时候不重新创建一个新的对象来实现该属性的拷贝, 那么就是浅拷贝.\n \t\t即任何不完全的拷贝都是浅拷贝\n \t-> 将两个对象完全从内存中隔离开, 就是深拷贝. 即每一个引用属性, 以及引用属性的引用属性, ... 全部拷贝出来.\n\n15. 构造函数( 构造器 CONTROCTOR )的作用\n\t-> JS 中对象的动态特性\n\t\t即 想要什么属性就可以提供什么属性\n\t\t在 JS 中 对象如果没有指定的属性, 只需要利用赋值就可以给对象提供该属性.\n\t-> 点语法与关联数组语法\n\t\tO.NAME = 'JIM';\t\t\t\t// 点语法赋值（NAME是一个名字）\n\t\tCONSOLE.LOG( O.NAME );\t\t// 点语法取值\n\t\tO[ 'NAME' ] = 'TOM';\t\t// +关联数组语法赋值（NAME一定要是字符串）\n\t\tO[AGE];                 \t//会出错  AGE不存在\n\t\tO[ 'NAME' ] = 'TOM';\t\t//这里的NAME不能为对象\n\t\t\n\t\tCONSOLE.LOG( O[ 'NAME' ] ); // 关联数组语法取值\n\n\t\t问题:\n\t\t\t// 如果 NAME 是一个变量, 里面存储的是 字符串, 也是可以的\n\t\t\tO[ NAME ] = 'JACK';   // 对或不对?\n\t\tWINDOW.NAME 为空 \"\"    WINDOW里面有NAME\n\n\t-> 例创建一个 PERSON 对象\n\t\tVAR P = {};\t\t// 什么都没有的对象\n\t\t// 根据需要添加成员\n\t\tP.NAME = '张三';\n\t\tP.AGE = 30;\n\t\tP.GENDER = '男';\n\t-> 简化: 提供一个创建 PERSON 对象的函数\n\n\t\tFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n\t\t\tVAR P = {};\n\t\t\tP.NAME = NAME;\n\t\t\tP.AGE = AGE;\n\t\t\tP.GENDER = GENDER;\n\t\t\tRETURN P;\n\t\t}\n\n\t\tVAR P1 = CREATEPERSON( 'JIM', 19, '男' );\n\t\tVAR P2 = CREATEPERSON( 'LILY', 18, '女' );\n\n\t\t这个( 这种类型 )的函数就是用来创建对象的, 即生产对象. 常常将这类函数\n\t\t称为 '工厂函数'\n\n16. 构造方法创建对象\n\t-> 构造器中不需要 RETURN 语句. 一般也可以不写\n\t-> 调用构造器的时候, 使用 NEW 运算符引导\n\t-> 在构造器中 THIS 表示当前对象. 给对象提供成员使用 THIS.XXX 的 方式\n\n\t-> 将 CREATEPERSON 改造成构造器\n\t\t// 构造器的定义\n\t\tFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n\t\t\tTHIS.NAME = NAME;\n\t\t\tTHIS.AGE = AGE;\n\t\t\tTHIS.GENDER = GENDER;\n\t\t}\n\t\t// 调用构造器创建对象\n\t\tVAR P = NEW CREATEPERSON( '李磊', 19, '男' ); \n\t\t当构造函数，同时出现RETUR和NEW的时候，看RETURN后面的值，\n\t\t如果为数值则返回THIS ，如果是引用类型，就返回引用类型。\n\t-> 构造器创建对象的本质: 还是使用对象的动态特性\n\t\t-> 首先执行 NEW 运算符. 即创建对象. 可以简单看做为 {} 的简写\n\t\t\tVAR P = NEW ...   '相当于'   VAR P = {}\n\t\t-> 调用构造器. 并隐含一个参数, 即刚刚创建的对象. \n\t\t-> 在构造器中使用 THIS 引用刚刚创建出来的对象.\n\t\t-> 构造器结束是 默认返回 THIS\n\n\t\t本质还是利用对象的动态特性\n\n\t-> 补充说明\n\t\t-> 构造器的名字, 一般使用 PASCAL 命名规则( 首字母大写的 )\n\t\t-> 一般为了与其他面向对象的编程语言( C++, C#, JAVA )保持一致. 称构造函数名为类名\n\n\t\tFUNCTION PERSON( NAME, AGE, GENDER ) {\n\t\t\tTHIS.NAME = NAME;\n\t\t\tTHIS.AGE = AGE;\n\t\t\tTHIS.GENDER = GENDER;\n\t\t}\n\t\t// 调用构造器创建对象\n\t\tVAR P = NEW PERSON( '李磊', 19, '男' ); \n\n17. 异常与捕获\n\t-> 异常\n\t\t简单的说, 就是代码在执行过程中出现的错误. 并不是代码的语法错误.\n\t-> 一旦出现异常, 其后的代码, 不再执行\n\n\t-> TRY-CATCH 语法\n\t\t1) TRY-CATCH 形态\n\t\t\tTRY {\n\t\t\t\t代码\n\t\t\t} CATCH ( E ) {\n\t\t\t\t代码\n\t\t\t}\n\t\t2) TRY-CATCH-FINALLY 形态\n\t\t\tTRY {\n\t\t\t\t代码\n\t\t\t} CATCH ( E ) {\n\t\t\t\t代码\n\t\t\t} FINALLY {\n\t\t\t\t代码\n\t\t\t} （无论代码出错还是没有出错都要执行）\n\n\t-> 自定义抛出异常\n\t\t一般可以封装函数完成特定的功能. 例如 TAG 函数\n\t\tFUNCTION TAG ( TAGNAME ) {\n\t\t\tIF ( TAGNAME 不是字符串 ) 抛出异常. \n\t\t\tRETURN DOCUMENT.GETELEMENTSBYTAGNAME ( TAGNAME );\n\t\t}\n\t-> 抛出异常的语法\n\t\tTHROW 对象\n\n18. DOM 的核心内容\n\t-> 什么是 DOM, 为什么需要 DOM\n\t\t<DIV><DIV></DIV><DIV></DIV></DIV>\n\t-> DOM 操作操作的是什么?\n\t\t-> 访问各亲属节点\n\t\t-> 增删改查\n\t-> 学会分析 DOM 树\n\t\t<DIV>\n\t\t\t<P>你好, 我是一个 <SPAN STYLE=\"COLOR: RED\">DOM</SPAN> 树的练习</P>\n\t\t</DIV>\n\n\t\t在 HTML 文件结构中吗所有的内容都是节点(NODE)对象. 有的是文本节点.\n\t\t有的是标签( 元素 ELEMENT )对象. 还有的是属性节点( ATTRIBUTE NODE )对象.\n\n19. 访问各个亲属节点\n\t-> 节点对象的常用属性\n\t\t<NODE>.NODETYPE\n\t\t\t元素(标签): 1, \n\t\t\t属性: 2, \n\t\t\t文本: 3\n\t\t<NODE>.NODENAME\n\t\t\t元素(标签): 大写的标签名, \n\t\t\t属性: 属性名\n\t\t\t文本: #TEXT\n\t\t<NODE>.NODEVALUE\n\t\t\t元素(标签): NULL\n\t\t\t属性: 属性赋值等号后面的值\n\t\t\t文本: 文本字符串\n\n20. 操作 DOM 就是创建元素, 插入元素, 修改元素, 查询元素, 删除元素\n\t-> 增加\n\t\t// 创建\n\t\tDOCUMENT.CREATEELEMENT( '元素名' )\t\t\t创建元素标签\n\t\tDOCUMENT.CREATETEXTNODE( '文本内容' )\t\t创建文本节点\n\t\t// 插入\n\t\t<PARENT>.APPENDCHILD( 子元素 )\t\t\t\t追加到子元素的结尾\n\t\t<PARENT>.INSERTBEFORE( 新元素, 旧元素 )\t\t将新元素插入到旧元素的前面\n\n\t\t// 简单的办法\n\t\t<ELEMENT>.INNERHTML = ...\n\t\t<ELEMENT>.INNERTEXT = ...\n\n\t\t// 增加属性\n\t\t<ELEMENT>.属性名 = ...\n\t\t<ELEMENT>.SETATTRIBUTE( 属性名, 值 );\n\t\t<ELEMENT>.STYLE.XXXX = ...\n\t-> 删除\n\t\t<PARENT>.REMOVECHILD( 子元素 );\n\t\t<ELEMENT>.SETATTRIBUTE( 属性, '' )\n\t\t<ELEMENT>.XXXX = NULL\n\t-> 修改\n\t\t-> 修改属性\n\t\t\t<ELEMENT>.XXX = ...\n\t\t\t<ELEMENT>.SETATTRIBUTE( 属性名, ... )\n\t\t-> 修改节点\n\t-> 查询\n\n21. 手动创建一个 TABLE 表格, 并且在里面显示数据\n\tVAR ARR = [\n\t\t{ NAME: 'JIM1', AGE: 19, GENDER: '男' },\n\t\t{ NAME: 'JIM2', AGE: 18, GENDER: '男' },\n\t\t{ NAME: 'JIM3', AGE: 20, GENDER: '男' },\n\t\t{ NAME: 'JIM4', AGE: 18, GENDER: '男' }\n\t];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n #\n ##","source":"_posts/面向对象/面向对象第一天.md","raw":"---\ntitle: javascript 面向对象：1\ncategories: ['前端']\ntags: ['面向对象'] \n---\n### 一、 面向对象：是一个基于对象的多范式的编程语言\n\t多范式：编程风格\n\t\t面向过程的方法编程\n\t\t面向对象的方式编程\n\t\t函数式\n### 二、 面向对象的基本概念\n- JS 是不是一个面向对象的语言?\n\t不是: 与传统面向对象的理论有矛盾. C#, JAVA\n\t是: JS 里面到处都是对象. 数组, 时间, 正则 ... 和 DOM\n\t\t也可以像传统面向对象的语言那样用 NEW 的方式创建对象\n\n- JS 是一个基于对象的多范式的编程语言\n\n\t多范式: 编程风格\n\t\t面向过程的方式编程\n\t\t面向对象的方式编程\n\t\t函数式 ...\n- 函数式的一个特点: 递归与链式\n\tJQUERY 就是典型的链式编程风格\n\t比如: 给 DIV 标签添加样式\n\t\t$( 'DIV' ).CSS( 'BORDER', '1PX SOLID RED' )\n\t\t\t\t\t.CSS( 'WIDTH', '400PX' )\n\t\t\t\t\t.CSS( 'HEIGHT', '200PX' );\n- 面向对象的概念\n\t\t-> 面向: 将脸朝向 ... -> 关注, 用\n\t\t\t面向过程开发 -> 使用过程的方式开发\n\t\t\t面向对象开发 -> 使用对象开发\n\t\t-> 面向过程\n\t\t\t早上吃早饭: 吃面\n\t\t\t自己做: 和面 -> 压成细面 -> 烧水 -> 煮面 -> 盛面 -> 吃\n\t\t\t过程: 步骤, 细节, 顺序等\n\t\t-> 今天早上\n\t\t\t找到对象: 找到面馆 -> 要 -> 吃\n\t\t-> 面向对象: \n\t\t\t要做什么, 就找到对应的对象, 告诉它做, 等结果\n\t\t-> 生活\n\t\t\t买菜: 菜场\n\t\t\t公交\n\t\t\t电话\n\t\t\t...\n\t\t-> 是否说面向对象可以取代面向过程\n\t\t\t面向对象是面向过程的封装\n\t-> 万物皆对象\n\t\t在实际开发中, 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集.\n\t\t-> 数据集: 很多数据打包到一起. { NAME: '张三', AGE: 19, GENDER: '男' }\n\t\t\t\t假设展示 10 条商品数据. 每一个商品: 名字, 描述, 价格, 图片\n\t\t\t\t-> \n\t\t\t\t每一条数据可以变成对象: { NAME:'', DESC: '', PRICE: 0, IMG: '' }\n\t\t\t\t-> 引入数组, 将数据存储到数组中\n\t\t-> 功能集(函数集, 方法集)\n\t\t-> 在 JS 中, 所谓的对象就是 键值对的 集合\n\t\t-> 也可以混合使用\n\t\t\t例如 JQUERY:\n\t\t\t\t$( 'DIV' )\t这个是一个 JQ 对象, 但是实际上里面包含 DOM 对象\n\t\t\t\t$( 'DIV' ).CSS( ... )\n\t\t\t \t$( 'DIV' ).HTML( ... )\t是不是就说明 JQ 对象中包含方法\n\t-> 抽象性\n\t\t商品列表: 书店, 书的列表\n\t\t\t书名, 页数, 简介, 编号, 作者\t\t\t对象只包含最核心的主要信息\n\t\t游戏人物: 英雄\n\t\t\t名字, 血量, 防御, 攻击, 护甲, 武器\t\t只需要描述出需要的数据即可\n\t\n\t-> 名词提炼法找对象\n\t\t做一个表格排序\n\t\t\t-> 过程\n\t\t\t\t1) 创建表格\n\t\t\t\t2) 添加点击事件\n\t\t\t\t3) 排序, 更新数据\n\t\t\t-> 对象\n\t\t\t\t1) 创建表格对象\n\t\t\t\t2) 添加数据\n\t-> 实际开发的时候如果需要完成一个功能\n\t\t-> 首先考虑系统是否提供了对象\n\t\t\t例如创建图片: VAR IMG = NEW IMAGE(); IMG.SRC = '...JPG';\n\t\t\t例如获取页面元素: DOCUMENT, 标签对象\n\t\t\t例如获得导航栏里面的所有的 LI 标签\n\t\t\t\tVAR NAV = DOCUMENT.GETELEMENTSBYID( 'NAV' );    // NAVIGATION\n\t\t\t\tVAR LIS = NAV.GETELEMENTSBYTAGNAME( 'LI' );\n\t\t-> 如果系统没有可以考虑自定义, 或第三方\n\t\t\tVAR ITCAST = {\n\t\t\t\tTAG: FUNCTION ( TAGNAME ) {\n\t\t\t\t\tRETURN DOCUMENT.GETELEMENTSBYTAGNAME( TAGNAME );\n\t\t\t\t}, ADDCSS: FUNCTION ( ARRAY, STYLES ) {\n\t\t\t\t\tFOR ( VAR I = 0; I < ARRAY.LENGTH; I++ ) {\n\t\t\t\t\t\tFOR ( VAR K IN STYLES ) {\n\t\t\t\t\t\t\tARRAY[ I ].STYLE[ K ] = STYLES[ K ]; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, ID: FUNCTION () {},\n\t\t\t\tCNAME: FUNCTION () {},\n\t\t\t\tNAME: ...\n\t\t\t\tATTR: ...\n\t\t\t\tCLASS: ...\n\t\t\t\t...\n\t\t\t};\n\n3. 开发者工具的打开: F12\n\n\t火狐的 FIREBUG\n\n4. 调试按钮\n\t-> 逐语句: 单步运行. 就是一次只执行一句话. 如果遇到函数, 进入函数体内一步一步执行\n\t-> 逐过程: 一次执行一个过程. 如果是一条语句那么与逐语句是一样的. 但是如果是一个函\n\t\t\t\t数, 那么他就会将函数执行完, 然后在往下走, 停下来.\n\t-> 继续运行\n\n5. 条件断点\n\t就是只有在 条件满足的时候(表达式为真的时候) 才会停下来的断点 \n\n6. 利用调试工具实现列表播放\n\tH5 提供了 两个标签, 一个是 AUDIO, 一个是 VIDEO\n\tAUDIO 主要是用来播放音乐的\n\tVIDEO 用来播放视频\n\n\t如果标签设置了属性\n\t\tAUTOPLAY\n\t\tSRC\n\t我希望当一个音乐播放完成后, 自动播放下一首\n\n7. 数据在内存中的存储形式(识记)\n\t计算机只认识数字\n\t计算机根据是否有电信号表示1或0: 准确的说是高低电平\n\t有了二进制数据( 有兴趣的同学可以学习如何转换 )\n\n\t计算机只认识数组, 那么如何表示语言\n\tASCII 码\n\t\t0 ~ 127 数字 对应的 表示成 字母\n\t\t前 32 个 是控制字符\n\t\t从 32 开始 到 127 是可视化字符\n\t\t'0'\t\t\t48\n\t\t'A'\t\t\t97\n\t\t'A'\t\t\t65\n\t有了这样一个对应关系(映射 MAP), 那么一段文字就可以使用一串数字表示了\n\n\t表示中文的 GB2312 编码, 简体中文编码. 英文标点和数字等使用一个字节\n\t\t\t\t\t\t\t\t\t\t  中文使用两个字节.\n\tUNICODE 编码( 万国码 ). 所有的字符才偶用两个字节表示.\n\t\t\t\t\t\t\t例如表示字符 'A'\t2 个字节\n\t\t\t\t\t\t\t在页面中使用最多的是: 数字, 字母, 标点符号\n\tUTF-8 编码( 通用转换格式 ). 所有与 ASCII 编码相符的字符采用一个字节.\n\t\t\t\t\t\t\t\t而汉字采用 3 个字节.\n\n8. 在 JS 中允许使用 UNICODE 编码表示字符串\n\t语法: \\U + 4 位 16 进制数\n\n\t使用这种方式表示数据, 在表示 与 ASCII 码重合字符是没有意义的. 但是对于中文\n\t由于存在不同的编码, 而不同编码在不同平台上可以正常显示, 但是随着网络传播, \n\t不是在所有平台上可以通用. 因此数据传送中文一般采用 UNICODE 编码形式.\n\n9. 数字 + 上下文 = 信息\n\t97\t\t'A'    数字 97\n\n\t在此处不要深究, 只需要了解内存模型即可.\n\n\t内存就是一个可以存储数字( 数据 )的盒子.\n\n\n10. JS 的数据类型\n\t-> 基本类型( 值类型 ): 数字 NUMBER, 字符串 STRING, 布尔 BOOLEAN\n\t-> 复合类型( 引用类型 ): 对象( 数组, 时间类型, 函数类型, 正则表达式, ... )\n\t-> 空类型: NULL, UNDEFINED\n\n\n\t基本数据类型和空类型的存储模型就是一个方格里面放一个数据\n\t复合类型, 除了函数, 其他的数据类型无法使用 TYPEOF 获得数据类型名\n\t注意: 如果需要获得对象的数据类型, 需要使用 OBJECT.PROTOTYPE.TOSTRING.APPLY( 数据 )\n\n11. 复合类型的存储方式\n\tVAR P = { NAME: 'ITCAST' }\n\n\t复合类型的对象是一个单独的内存区域, 对象有什么属性, 那么内存区域中就有什么数据.\n\t变量 P 只存储该对象的 '地址'. 所以 P 不是真正存储数据的区域.\n\n\t绘制数据的内存逻辑图\n\n\tVAR ARR1 = [ 1, 2, 3, 4 ];\n\tVAR ARR2 = [\n\t\t{ NAME: '张三', AGE: 19, GENDER: '男' },\n\t\t{ NAME: '李四', AGE: 18, GENDER: '男' },\n\t\t{ NAME: '小李', AGE: 17, GENDER: '女' }\n\t];\n\n12. 值类型与引用类型的存储特征\n\t-> 值类型的数据, 只需要开辟一段内存存储数据即可\n\t\tVAR A = 123; \n\t\tVAR B = 'ABC';\n\t\tVAR C = TRUE;\n\t-> 对象类型( 引用类型 ). 对象才是真正的数据, 需要占据单独的内存.\n\t\t而变量名只是存储着对象的内存地址( 引用 ).\n\n\t\t即创建一个对象并赋值, 实际上需要两块内存空间. 一个存储数据( 对象 ),\n\t\t另一个存储变量以引用对象.\n\n\t\tVAR O = { NAME: '张三', AGE: 19, GENDER: '男' };\n\n\n13. 值类型与引用类型的赋值与传参的特性\n\t-> 赋值: 将原变量中的数据拷贝一份, 然后存储到给定变量中\n\t\t-> 值类型\n\t\t\tVAR A = 123;\t// 有一个盒子, 叫 A, 里面存储着数字 123\n\t\t\tVAR B;\t\t\t// 又有一个盒子, 叫 B, 里面什么都没存( UNDEFINED )\n\t\t\tB = A;\t\t\t// 将 A 中存储的东西复制一份, 然后赋值给 B. 即存储在 B 中\n\n\t\t\tB 和 A 是两个独立的变量, 两者之间不再有关系. 改变其中一个数据, 另一个不变\n\t\t-> 引用类型\n\t\t\tVAR O1 = { NUM: 123 };\n\t\t\tVAR O2;\n\t\t\t// 赋值\n\t\t\tO2 = O1; \t// 将 O1 中存储的内容 拷贝一份 存储到 O2 中\n\t\t\t\t\t\t// O1 中存储的是引用, 或 '地址'\n\n\t\t\tO1 和 O2 虽然是不相同的两个变量, 即两个独立的盒子. 但是由于存储的地址相同.\n\t\t\t在访问数据的时候, O1 与 O2 也是访问同一个数据, O1 将数据修改了, O2 再读取,\n\t\t\t读取的就是修改后的数据. \n\t-> 函数参数传递\n\t\t-> 什么是函数参数传递\n\t\t\t函数要调用, 一般会给函数传递参数\n\t\t\t\t在调用函数的时候, 回将参数中表示的数据拷贝一份, 然后给参数赋值\n\t\t\tFUNCTION FOO( NUM ) {}\n\n\t\t\t// 调用\n\t\t\tVAR A = 123;\n\t\t\tFOO( A );\t\t// 调用函数就是要执行函数\n\t\t\t\t\t\t\t// 将 A 中存储的数据 拷贝一份\n\t\t\t\t\t\t\t// 进入 函数 FOO\n\t\t\t\t\t\t\t// 给参数赋值, 相当于 NUM = A\n\t\t\t\t\t\t\t// 进入函数体, 开始执行函数\n\t\t\t此时的赋值特性与前面介绍的值类型引用类型的赋值是一个特点\n\n14. 深拷贝与浅拷贝\n\t-> 什么是拷贝: 就是创建一个与目标数据一模一样的数据\n\t-> 案例:\n\t\tVAR P = { NAME: '张三' };\n\t\tVAR P1 = P;   \t\t\t\t// 是否存在拷贝\n \t\t// 一般描述拷贝是指拷贝对象\n \t\tP1 = {};\n \t\tP1.NAME = P.NAME;\n \t\t// 才是拷贝\n \t-> 案例, 给 对象 P 提供一个 CLONE 方法, 完成拷贝\n \t-> 案例:\n \t\t有一辆汽车 CAR: NAME=保时捷\n \t\t有一个人 PERSON : NAME=张三\n \t-> 如果对象的属性也是一个引用类型, 拷贝的时候不重新创建一个新的对象来实现该属性的拷贝, 那么就是浅拷贝.\n \t\t即任何不完全的拷贝都是浅拷贝\n \t-> 将两个对象完全从内存中隔离开, 就是深拷贝. 即每一个引用属性, 以及引用属性的引用属性, ... 全部拷贝出来.\n\n15. 构造函数( 构造器 CONTROCTOR )的作用\n\t-> JS 中对象的动态特性\n\t\t即 想要什么属性就可以提供什么属性\n\t\t在 JS 中 对象如果没有指定的属性, 只需要利用赋值就可以给对象提供该属性.\n\t-> 点语法与关联数组语法\n\t\tO.NAME = 'JIM';\t\t\t\t// 点语法赋值（NAME是一个名字）\n\t\tCONSOLE.LOG( O.NAME );\t\t// 点语法取值\n\t\tO[ 'NAME' ] = 'TOM';\t\t// +关联数组语法赋值（NAME一定要是字符串）\n\t\tO[AGE];                 \t//会出错  AGE不存在\n\t\tO[ 'NAME' ] = 'TOM';\t\t//这里的NAME不能为对象\n\t\t\n\t\tCONSOLE.LOG( O[ 'NAME' ] ); // 关联数组语法取值\n\n\t\t问题:\n\t\t\t// 如果 NAME 是一个变量, 里面存储的是 字符串, 也是可以的\n\t\t\tO[ NAME ] = 'JACK';   // 对或不对?\n\t\tWINDOW.NAME 为空 \"\"    WINDOW里面有NAME\n\n\t-> 例创建一个 PERSON 对象\n\t\tVAR P = {};\t\t// 什么都没有的对象\n\t\t// 根据需要添加成员\n\t\tP.NAME = '张三';\n\t\tP.AGE = 30;\n\t\tP.GENDER = '男';\n\t-> 简化: 提供一个创建 PERSON 对象的函数\n\n\t\tFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n\t\t\tVAR P = {};\n\t\t\tP.NAME = NAME;\n\t\t\tP.AGE = AGE;\n\t\t\tP.GENDER = GENDER;\n\t\t\tRETURN P;\n\t\t}\n\n\t\tVAR P1 = CREATEPERSON( 'JIM', 19, '男' );\n\t\tVAR P2 = CREATEPERSON( 'LILY', 18, '女' );\n\n\t\t这个( 这种类型 )的函数就是用来创建对象的, 即生产对象. 常常将这类函数\n\t\t称为 '工厂函数'\n\n16. 构造方法创建对象\n\t-> 构造器中不需要 RETURN 语句. 一般也可以不写\n\t-> 调用构造器的时候, 使用 NEW 运算符引导\n\t-> 在构造器中 THIS 表示当前对象. 给对象提供成员使用 THIS.XXX 的 方式\n\n\t-> 将 CREATEPERSON 改造成构造器\n\t\t// 构造器的定义\n\t\tFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n\t\t\tTHIS.NAME = NAME;\n\t\t\tTHIS.AGE = AGE;\n\t\t\tTHIS.GENDER = GENDER;\n\t\t}\n\t\t// 调用构造器创建对象\n\t\tVAR P = NEW CREATEPERSON( '李磊', 19, '男' ); \n\t\t当构造函数，同时出现RETUR和NEW的时候，看RETURN后面的值，\n\t\t如果为数值则返回THIS ，如果是引用类型，就返回引用类型。\n\t-> 构造器创建对象的本质: 还是使用对象的动态特性\n\t\t-> 首先执行 NEW 运算符. 即创建对象. 可以简单看做为 {} 的简写\n\t\t\tVAR P = NEW ...   '相当于'   VAR P = {}\n\t\t-> 调用构造器. 并隐含一个参数, 即刚刚创建的对象. \n\t\t-> 在构造器中使用 THIS 引用刚刚创建出来的对象.\n\t\t-> 构造器结束是 默认返回 THIS\n\n\t\t本质还是利用对象的动态特性\n\n\t-> 补充说明\n\t\t-> 构造器的名字, 一般使用 PASCAL 命名规则( 首字母大写的 )\n\t\t-> 一般为了与其他面向对象的编程语言( C++, C#, JAVA )保持一致. 称构造函数名为类名\n\n\t\tFUNCTION PERSON( NAME, AGE, GENDER ) {\n\t\t\tTHIS.NAME = NAME;\n\t\t\tTHIS.AGE = AGE;\n\t\t\tTHIS.GENDER = GENDER;\n\t\t}\n\t\t// 调用构造器创建对象\n\t\tVAR P = NEW PERSON( '李磊', 19, '男' ); \n\n17. 异常与捕获\n\t-> 异常\n\t\t简单的说, 就是代码在执行过程中出现的错误. 并不是代码的语法错误.\n\t-> 一旦出现异常, 其后的代码, 不再执行\n\n\t-> TRY-CATCH 语法\n\t\t1) TRY-CATCH 形态\n\t\t\tTRY {\n\t\t\t\t代码\n\t\t\t} CATCH ( E ) {\n\t\t\t\t代码\n\t\t\t}\n\t\t2) TRY-CATCH-FINALLY 形态\n\t\t\tTRY {\n\t\t\t\t代码\n\t\t\t} CATCH ( E ) {\n\t\t\t\t代码\n\t\t\t} FINALLY {\n\t\t\t\t代码\n\t\t\t} （无论代码出错还是没有出错都要执行）\n\n\t-> 自定义抛出异常\n\t\t一般可以封装函数完成特定的功能. 例如 TAG 函数\n\t\tFUNCTION TAG ( TAGNAME ) {\n\t\t\tIF ( TAGNAME 不是字符串 ) 抛出异常. \n\t\t\tRETURN DOCUMENT.GETELEMENTSBYTAGNAME ( TAGNAME );\n\t\t}\n\t-> 抛出异常的语法\n\t\tTHROW 对象\n\n18. DOM 的核心内容\n\t-> 什么是 DOM, 为什么需要 DOM\n\t\t<DIV><DIV></DIV><DIV></DIV></DIV>\n\t-> DOM 操作操作的是什么?\n\t\t-> 访问各亲属节点\n\t\t-> 增删改查\n\t-> 学会分析 DOM 树\n\t\t<DIV>\n\t\t\t<P>你好, 我是一个 <SPAN STYLE=\"COLOR: RED\">DOM</SPAN> 树的练习</P>\n\t\t</DIV>\n\n\t\t在 HTML 文件结构中吗所有的内容都是节点(NODE)对象. 有的是文本节点.\n\t\t有的是标签( 元素 ELEMENT )对象. 还有的是属性节点( ATTRIBUTE NODE )对象.\n\n19. 访问各个亲属节点\n\t-> 节点对象的常用属性\n\t\t<NODE>.NODETYPE\n\t\t\t元素(标签): 1, \n\t\t\t属性: 2, \n\t\t\t文本: 3\n\t\t<NODE>.NODENAME\n\t\t\t元素(标签): 大写的标签名, \n\t\t\t属性: 属性名\n\t\t\t文本: #TEXT\n\t\t<NODE>.NODEVALUE\n\t\t\t元素(标签): NULL\n\t\t\t属性: 属性赋值等号后面的值\n\t\t\t文本: 文本字符串\n\n20. 操作 DOM 就是创建元素, 插入元素, 修改元素, 查询元素, 删除元素\n\t-> 增加\n\t\t// 创建\n\t\tDOCUMENT.CREATEELEMENT( '元素名' )\t\t\t创建元素标签\n\t\tDOCUMENT.CREATETEXTNODE( '文本内容' )\t\t创建文本节点\n\t\t// 插入\n\t\t<PARENT>.APPENDCHILD( 子元素 )\t\t\t\t追加到子元素的结尾\n\t\t<PARENT>.INSERTBEFORE( 新元素, 旧元素 )\t\t将新元素插入到旧元素的前面\n\n\t\t// 简单的办法\n\t\t<ELEMENT>.INNERHTML = ...\n\t\t<ELEMENT>.INNERTEXT = ...\n\n\t\t// 增加属性\n\t\t<ELEMENT>.属性名 = ...\n\t\t<ELEMENT>.SETATTRIBUTE( 属性名, 值 );\n\t\t<ELEMENT>.STYLE.XXXX = ...\n\t-> 删除\n\t\t<PARENT>.REMOVECHILD( 子元素 );\n\t\t<ELEMENT>.SETATTRIBUTE( 属性, '' )\n\t\t<ELEMENT>.XXXX = NULL\n\t-> 修改\n\t\t-> 修改属性\n\t\t\t<ELEMENT>.XXX = ...\n\t\t\t<ELEMENT>.SETATTRIBUTE( 属性名, ... )\n\t\t-> 修改节点\n\t-> 查询\n\n21. 手动创建一个 TABLE 表格, 并且在里面显示数据\n\tVAR ARR = [\n\t\t{ NAME: 'JIM1', AGE: 19, GENDER: '男' },\n\t\t{ NAME: 'JIM2', AGE: 18, GENDER: '男' },\n\t\t{ NAME: 'JIM3', AGE: 20, GENDER: '男' },\n\t\t{ NAME: 'JIM4', AGE: 18, GENDER: '男' }\n\t];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n #\n ##","slug":"面向对象/面向对象第一天","published":1,"date":"2019-04-25T14:58:51.000Z","updated":"2019-04-26T06:38:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0jl003e7xuq8vpfoids","content":"<h3 id=\"一、-面向对象：是一个基于对象的多范式的编程语言\"><a href=\"#一、-面向对象：是一个基于对象的多范式的编程语言\" class=\"headerlink\" title=\"一、 面向对象：是一个基于对象的多范式的编程语言\"></a>一、 面向对象：是一个基于对象的多范式的编程语言</h3><pre><code>多范式：编程风格\n    面向过程的方法编程\n    面向对象的方式编程\n    函数式\n</code></pre><h3 id=\"二、-面向对象的基本概念\"><a href=\"#二、-面向对象的基本概念\" class=\"headerlink\" title=\"二、 面向对象的基本概念\"></a>二、 面向对象的基本概念</h3><ul>\n<li><p>JS 是不是一个面向对象的语言?<br>  不是: 与传统面向对象的理论有矛盾. C#, JAVA<br>  是: JS 里面到处都是对象. 数组, 时间, 正则 … 和 DOM</p>\n<pre><code>也可以像传统面向对象的语言那样用 NEW 的方式创建对象\n</code></pre></li>\n<li><p>JS 是一个基于对象的多范式的编程语言</p>\n<p>  多范式: 编程风格</p>\n<pre><code>面向过程的方式编程\n面向对象的方式编程\n函数式 ...\n</code></pre></li>\n<li>函数式的一个特点: 递归与链式<br>  JQUERY 就是典型的链式编程风格<br>  比如: 给 DIV 标签添加样式<pre><code>$( &apos;DIV&apos; ).CSS( &apos;BORDER&apos;, &apos;1PX SOLID RED&apos; )\n            .CSS( &apos;WIDTH&apos;, &apos;400PX&apos; )\n            .CSS( &apos;HEIGHT&apos;, &apos;200PX&apos; );\n</code></pre></li>\n<li><p>面向对象的概念</p>\n<pre><code>-&gt; 面向: 将脸朝向 ... -&gt; 关注, 用\n    面向过程开发 -&gt; 使用过程的方式开发\n    面向对象开发 -&gt; 使用对象开发\n-&gt; 面向过程\n    早上吃早饭: 吃面\n    自己做: 和面 -&gt; 压成细面 -&gt; 烧水 -&gt; 煮面 -&gt; 盛面 -&gt; 吃\n    过程: 步骤, 细节, 顺序等\n-&gt; 今天早上\n    找到对象: 找到面馆 -&gt; 要 -&gt; 吃\n-&gt; 面向对象: \n    要做什么, 就找到对应的对象, 告诉它做, 等结果\n-&gt; 生活\n    买菜: 菜场\n    公交\n    电话\n    ...\n-&gt; 是否说面向对象可以取代面向过程\n    面向对象是面向过程的封装\n</code></pre><p>  -&gt; 万物皆对象</p>\n<pre><code>在实际开发中, 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集.\n-&gt; 数据集: 很多数据打包到一起. { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; }\n        假设展示 10 条商品数据. 每一个商品: 名字, 描述, 价格, 图片\n        -&gt; \n        每一条数据可以变成对象: { NAME:&apos;&apos;, DESC: &apos;&apos;, PRICE: 0, IMG: &apos;&apos; }\n        -&gt; 引入数组, 将数据存储到数组中\n-&gt; 功能集(函数集, 方法集)\n-&gt; 在 JS 中, 所谓的对象就是 键值对的 集合\n-&gt; 也可以混合使用\n    例如 JQUERY:\n        $( &apos;DIV&apos; )    这个是一个 JQ 对象, 但是实际上里面包含 DOM 对象\n        $( &apos;DIV&apos; ).CSS( ... )\n         $( &apos;DIV&apos; ).HTML( ... )    是不是就说明 JQ 对象中包含方法\n</code></pre><p>  -&gt; 抽象性</p>\n<pre><code>商品列表: 书店, 书的列表\n    书名, 页数, 简介, 编号, 作者            对象只包含最核心的主要信息\n游戏人物: 英雄\n    名字, 血量, 防御, 攻击, 护甲, 武器        只需要描述出需要的数据即可\n</code></pre><p>  -&gt; 名词提炼法找对象</p>\n<pre><code>做一个表格排序\n    -&gt; 过程\n        1) 创建表格\n        2) 添加点击事件\n        3) 排序, 更新数据\n    -&gt; 对象\n        1) 创建表格对象\n        2) 添加数据\n</code></pre><p>  -&gt; 实际开发的时候如果需要完成一个功能</p>\n<pre><code>-&gt; 首先考虑系统是否提供了对象\n    例如创建图片: VAR IMG = NEW IMAGE(); IMG.SRC = &apos;...JPG&apos;;\n    例如获取页面元素: DOCUMENT, 标签对象\n    例如获得导航栏里面的所有的 LI 标签\n        VAR NAV = DOCUMENT.GETELEMENTSBYID( &apos;NAV&apos; );    // NAVIGATION\n        VAR LIS = NAV.GETELEMENTSBYTAGNAME( &apos;LI&apos; );\n-&gt; 如果系统没有可以考虑自定义, 或第三方\n    VAR ITCAST = {\n        TAG: FUNCTION ( TAGNAME ) {\n            RETURN DOCUMENT.GETELEMENTSBYTAGNAME( TAGNAME );\n        }, ADDCSS: FUNCTION ( ARRAY, STYLES ) {\n            FOR ( VAR I = 0; I &lt; ARRAY.LENGTH; I++ ) {\n                FOR ( VAR K IN STYLES ) {\n                    ARRAY[ I ].STYLE[ K ] = STYLES[ K ]; \n                }\n            }\n        }, ID: FUNCTION () {},\n        CNAME: FUNCTION () {},\n        NAME: ...\n        ATTR: ...\n        CLASS: ...\n        ...\n    };\n</code></pre></li>\n</ul>\n<ol>\n<li><p>开发者工具的打开: F12</p>\n<p> 火狐的 FIREBUG</p>\n</li>\n<li><p>调试按钮<br> -&gt; 逐语句: 单步运行. 就是一次只执行一句话. 如果遇到函数, 进入函数体内一步一步执行<br> -&gt; 逐过程: 一次执行一个过程. 如果是一条语句那么与逐语句是一样的. 但是如果是一个函</p>\n<pre><code>数, 那么他就会将函数执行完, 然后在往下走, 停下来.\n</code></pre><p> -&gt; 继续运行</p>\n</li>\n<li><p>条件断点<br> 就是只有在 条件满足的时候(表达式为真的时候) 才会停下来的断点 </p>\n</li>\n<li><p>利用调试工具实现列表播放<br> H5 提供了 两个标签, 一个是 AUDIO, 一个是 VIDEO<br> AUDIO 主要是用来播放音乐的<br> VIDEO 用来播放视频</p>\n<p> 如果标签设置了属性</p>\n<pre><code>AUTOPLAY\nSRC\n</code></pre><p> 我希望当一个音乐播放完成后, 自动播放下一首</p>\n</li>\n<li><p>数据在内存中的存储形式(识记)<br> 计算机只认识数字<br> 计算机根据是否有电信号表示1或0: 准确的说是高低电平<br> 有了二进制数据( 有兴趣的同学可以学习如何转换 )</p>\n<p> 计算机只认识数组, 那么如何表示语言<br> ASCII 码</p>\n<pre><code>0 ~ 127 数字 对应的 表示成 字母\n前 32 个 是控制字符\n从 32 开始 到 127 是可视化字符\n&apos;0&apos;            48\n&apos;A&apos;            97\n&apos;A&apos;            65\n</code></pre><p> 有了这样一个对应关系(映射 MAP), 那么一段文字就可以使用一串数字表示了</p>\n<p> 表示中文的 GB2312 编码, 简体中文编码. 英文标点和数字等使用一个字节</p>\n<pre><code>中文使用两个字节.\n</code></pre><p> UNICODE 编码( 万国码 ). 所有的字符才偶用两个字节表示.</p>\n<pre><code>例如表示字符 &apos;A&apos;    2 个字节\n在页面中使用最多的是: 数字, 字母, 标点符号\n</code></pre><p> UTF-8 编码( 通用转换格式 ). 所有与 ASCII 编码相符的字符采用一个字节.</p>\n<pre><code>而汉字采用 3 个字节.\n</code></pre></li>\n<li><p>在 JS 中允许使用 UNICODE 编码表示字符串<br> 语法: \\U + 4 位 16 进制数</p>\n<p> 使用这种方式表示数据, 在表示 与 ASCII 码重合字符是没有意义的. 但是对于中文<br> 由于存在不同的编码, 而不同编码在不同平台上可以正常显示, 但是随着网络传播,<br> 不是在所有平台上可以通用. 因此数据传送中文一般采用 UNICODE 编码形式.</p>\n</li>\n<li><p>数字 + 上下文 = 信息<br> 97        ‘A’    数字 97</p>\n<p> 在此处不要深究, 只需要了解内存模型即可.</p>\n<p> 内存就是一个可以存储数字( 数据 )的盒子.</p>\n</li>\n</ol>\n<ol>\n<li>JS 的数据类型<br>-&gt; 基本类型( 值类型 ): 数字 NUMBER, 字符串 STRING, 布尔 BOOLEAN<br>-&gt; 复合类型( 引用类型 ): 对象( 数组, 时间类型, 函数类型, 正则表达式, … )<br>-&gt; 空类型: NULL, UNDEFINED</li>\n</ol>\n<pre><code>基本数据类型和空类型的存储模型就是一个方格里面放一个数据\n复合类型, 除了函数, 其他的数据类型无法使用 TYPEOF 获得数据类型名\n注意: 如果需要获得对象的数据类型, 需要使用 OBJECT.PROTOTYPE.TOSTRING.APPLY( 数据 )\n</code></pre><ol>\n<li><p>复合类型的存储方式<br>VAR P = { NAME: ‘ITCAST’ }</p>\n<p>复合类型的对象是一个单独的内存区域, 对象有什么属性, 那么内存区域中就有什么数据.<br>变量 P 只存储该对象的 ‘地址’. 所以 P 不是真正存储数据的区域.</p>\n<p>绘制数据的内存逻辑图</p>\n<p>VAR ARR1 = [ 1, 2, 3, 4 ];<br>VAR ARR2 = [</p>\n<pre><code>{ NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; },\n{ NAME: &apos;李四&apos;, AGE: 18, GENDER: &apos;男&apos; },\n{ NAME: &apos;小李&apos;, AGE: 17, GENDER: &apos;女&apos; }\n</code></pre><p>];</p>\n</li>\n<li><p>值类型与引用类型的存储特征<br>-&gt; 值类型的数据, 只需要开辟一段内存存储数据即可</p>\n<pre><code>VAR A = 123; \nVAR B = &apos;ABC&apos;;\nVAR C = TRUE;\n</code></pre><p>-&gt; 对象类型( 引用类型 ). 对象才是真正的数据, 需要占据单独的内存.</p>\n<pre><code>而变量名只是存储着对象的内存地址( 引用 ).\n\n即创建一个对象并赋值, 实际上需要两块内存空间. 一个存储数据( 对象 ),\n另一个存储变量以引用对象.\n\nVAR O = { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; };\n</code></pre></li>\n</ol>\n<ol>\n<li><p>值类型与引用类型的赋值与传参的特性<br>-&gt; 赋值: 将原变量中的数据拷贝一份, 然后存储到给定变量中</p>\n<pre><code>-&gt; 值类型\n    VAR A = 123;    // 有一个盒子, 叫 A, 里面存储着数字 123\n    VAR B;            // 又有一个盒子, 叫 B, 里面什么都没存( UNDEFINED )\n    B = A;            // 将 A 中存储的东西复制一份, 然后赋值给 B. 即存储在 B 中\n\n    B 和 A 是两个独立的变量, 两者之间不再有关系. 改变其中一个数据, 另一个不变\n-&gt; 引用类型\n    VAR O1 = { NUM: 123 };\n    VAR O2;\n    // 赋值\n    O2 = O1;     // 将 O1 中存储的内容 拷贝一份 存储到 O2 中\n                // O1 中存储的是引用, 或 &apos;地址&apos;\n\n    O1 和 O2 虽然是不相同的两个变量, 即两个独立的盒子. 但是由于存储的地址相同.\n    在访问数据的时候, O1 与 O2 也是访问同一个数据, O1 将数据修改了, O2 再读取,\n    读取的就是修改后的数据. \n</code></pre><p>-&gt; 函数参数传递</p>\n<pre><code>-&gt; 什么是函数参数传递\n    函数要调用, 一般会给函数传递参数\n        在调用函数的时候, 回将参数中表示的数据拷贝一份, 然后给参数赋值\n    FUNCTION FOO( NUM ) {}\n\n    // 调用\n    VAR A = 123;\n    FOO( A );        // 调用函数就是要执行函数\n                    // 将 A 中存储的数据 拷贝一份\n                    // 进入 函数 FOO\n                    // 给参数赋值, 相当于 NUM = A\n                    // 进入函数体, 开始执行函数\n    此时的赋值特性与前面介绍的值类型引用类型的赋值是一个特点\n</code></pre></li>\n<li><p>深拷贝与浅拷贝<br>-&gt; 什么是拷贝: 就是创建一个与目标数据一模一样的数据<br>-&gt; 案例:</p>\n<pre><code>VAR P = { NAME: &apos;张三&apos; };\nVAR P1 = P;                   // 是否存在拷贝\n // 一般描述拷贝是指拷贝对象\n P1 = {};\n P1.NAME = P.NAME;\n // 才是拷贝\n</code></pre><p> -&gt; 案例, 给 对象 P 提供一个 CLONE 方法, 完成拷贝<br> -&gt; 案例:</p>\n<pre><code>有一辆汽车 CAR: NAME=保时捷\n有一个人 PERSON : NAME=张三\n</code></pre><p> -&gt; 如果对象的属性也是一个引用类型, 拷贝的时候不重新创建一个新的对象来实现该属性的拷贝, 那么就是浅拷贝.</p>\n<pre><code>即任何不完全的拷贝都是浅拷贝\n</code></pre><p> -&gt; 将两个对象完全从内存中隔离开, 就是深拷贝. 即每一个引用属性, 以及引用属性的引用属性, … 全部拷贝出来.</p>\n</li>\n<li><p>构造函数( 构造器 CONTROCTOR )的作用<br>-&gt; JS 中对象的动态特性</p>\n<pre><code>即 想要什么属性就可以提供什么属性\n在 JS 中 对象如果没有指定的属性, 只需要利用赋值就可以给对象提供该属性.\n</code></pre><p>-&gt; 点语法与关联数组语法</p>\n<pre><code>O.NAME = &apos;JIM&apos;;                // 点语法赋值（NAME是一个名字）\nCONSOLE.LOG( O.NAME );        // 点语法取值\nO[ &apos;NAME&apos; ] = &apos;TOM&apos;;        // +关联数组语法赋值（NAME一定要是字符串）\nO[AGE];                     //会出错  AGE不存在\nO[ &apos;NAME&apos; ] = &apos;TOM&apos;;        //这里的NAME不能为对象\n\nCONSOLE.LOG( O[ &apos;NAME&apos; ] ); // 关联数组语法取值\n\n问题:\n    // 如果 NAME 是一个变量, 里面存储的是 字符串, 也是可以的\n    O[ NAME ] = &apos;JACK&apos;;   // 对或不对?\nWINDOW.NAME 为空 &quot;&quot;    WINDOW里面有NAME\n</code></pre><p>-&gt; 例创建一个 PERSON 对象</p>\n<pre><code>VAR P = {};        // 什么都没有的对象\n// 根据需要添加成员\nP.NAME = &apos;张三&apos;;\nP.AGE = 30;\nP.GENDER = &apos;男&apos;;\n</code></pre><p>-&gt; 简化: 提供一个创建 PERSON 对象的函数</p>\n<pre><code>FUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n    VAR P = {};\n    P.NAME = NAME;\n    P.AGE = AGE;\n    P.GENDER = GENDER;\n    RETURN P;\n}\n\nVAR P1 = CREATEPERSON( &apos;JIM&apos;, 19, &apos;男&apos; );\nVAR P2 = CREATEPERSON( &apos;LILY&apos;, 18, &apos;女&apos; );\n\n这个( 这种类型 )的函数就是用来创建对象的, 即生产对象. 常常将这类函数\n称为 &apos;工厂函数&apos;\n</code></pre></li>\n<li><p>构造方法创建对象<br>-&gt; 构造器中不需要 RETURN 语句. 一般也可以不写<br>-&gt; 调用构造器的时候, 使用 NEW 运算符引导<br>-&gt; 在构造器中 THIS 表示当前对象. 给对象提供成员使用 THIS.XXX 的 方式</p>\n<p>-&gt; 将 CREATEPERSON 改造成构造器</p>\n<pre><code>// 构造器的定义\nFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n    THIS.NAME = NAME;\n    THIS.AGE = AGE;\n    THIS.GENDER = GENDER;\n}\n// 调用构造器创建对象\nVAR P = NEW CREATEPERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); \n当构造函数，同时出现RETUR和NEW的时候，看RETURN后面的值，\n如果为数值则返回THIS ，如果是引用类型，就返回引用类型。\n</code></pre><p>-&gt; 构造器创建对象的本质: 还是使用对象的动态特性</p>\n<pre><code>-&gt; 首先执行 NEW 运算符. 即创建对象. 可以简单看做为 {} 的简写\n    VAR P = NEW ...   &apos;相当于&apos;   VAR P = {}\n-&gt; 调用构造器. 并隐含一个参数, 即刚刚创建的对象. \n-&gt; 在构造器中使用 THIS 引用刚刚创建出来的对象.\n-&gt; 构造器结束是 默认返回 THIS\n\n本质还是利用对象的动态特性\n</code></pre><p>-&gt; 补充说明</p>\n<pre><code>-&gt; 构造器的名字, 一般使用 PASCAL 命名规则( 首字母大写的 )\n-&gt; 一般为了与其他面向对象的编程语言( C++, C#, JAVA )保持一致. 称构造函数名为类名\n\nFUNCTION PERSON( NAME, AGE, GENDER ) {\n    THIS.NAME = NAME;\n    THIS.AGE = AGE;\n    THIS.GENDER = GENDER;\n}\n// 调用构造器创建对象\nVAR P = NEW PERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); \n</code></pre></li>\n<li><p>异常与捕获<br>-&gt; 异常</p>\n<pre><code>简单的说, 就是代码在执行过程中出现的错误. 并不是代码的语法错误.\n</code></pre><p>-&gt; 一旦出现异常, 其后的代码, 不再执行</p>\n<p>-&gt; TRY-CATCH 语法</p>\n<pre><code>1) TRY-CATCH 形态\n    TRY {\n        代码\n    } CATCH ( E ) {\n        代码\n    }\n2) TRY-CATCH-FINALLY 形态\n    TRY {\n        代码\n    } CATCH ( E ) {\n        代码\n    } FINALLY {\n        代码\n    } （无论代码出错还是没有出错都要执行）\n</code></pre><p>-&gt; 自定义抛出异常</p>\n<pre><code>一般可以封装函数完成特定的功能. 例如 TAG 函数\nFUNCTION TAG ( TAGNAME ) {\n    IF ( TAGNAME 不是字符串 ) 抛出异常. \n    RETURN DOCUMENT.GETELEMENTSBYTAGNAME ( TAGNAME );\n}\n</code></pre><p>-&gt; 抛出异常的语法</p>\n<pre><code>THROW 对象\n</code></pre></li>\n<li><p>DOM 的核心内容<br>-&gt; 什么是 DOM, 为什么需要 DOM</p>\n<pre><code>&lt;DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;/DIV&gt;\n</code></pre><p>-&gt; DOM 操作操作的是什么?</p>\n<pre><code>-&gt; 访问各亲属节点\n-&gt; 增删改查\n</code></pre><p>-&gt; 学会分析 DOM 树</p>\n<pre><code>&lt;DIV&gt;\n    &lt;P&gt;你好, 我是一个 &lt;SPAN STYLE=&quot;COLOR: RED&quot;&gt;DOM&lt;/SPAN&gt; 树的练习&lt;/P&gt;\n&lt;/DIV&gt;\n\n在 HTML 文件结构中吗所有的内容都是节点(NODE)对象. 有的是文本节点.\n有的是标签( 元素 ELEMENT )对象. 还有的是属性节点( ATTRIBUTE NODE )对象.\n</code></pre></li>\n<li><p>访问各个亲属节点<br>-&gt; 节点对象的常用属性</p>\n<pre><code>&lt;NODE&gt;.NODETYPE\n    元素(标签): 1, \n    属性: 2, \n    文本: 3\n&lt;NODE&gt;.NODENAME\n    元素(标签): 大写的标签名, \n    属性: 属性名\n    文本: #TEXT\n&lt;NODE&gt;.NODEVALUE\n    元素(标签): NULL\n    属性: 属性赋值等号后面的值\n    文本: 文本字符串\n</code></pre></li>\n<li><p>操作 DOM 就是创建元素, 插入元素, 修改元素, 查询元素, 删除元素<br>-&gt; 增加</p>\n<pre><code>// 创建\nDOCUMENT.CREATEELEMENT( &apos;元素名&apos; )            创建元素标签\nDOCUMENT.CREATETEXTNODE( &apos;文本内容&apos; )        创建文本节点\n// 插入\n&lt;PARENT&gt;.APPENDCHILD( 子元素 )                追加到子元素的结尾\n&lt;PARENT&gt;.INSERTBEFORE( 新元素, 旧元素 )        将新元素插入到旧元素的前面\n\n// 简单的办法\n&lt;ELEMENT&gt;.INNERHTML = ...\n&lt;ELEMENT&gt;.INNERTEXT = ...\n\n// 增加属性\n&lt;ELEMENT&gt;.属性名 = ...\n&lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, 值 );\n&lt;ELEMENT&gt;.STYLE.XXXX = ...\n</code></pre><p>-&gt; 删除</p>\n<pre><code>&lt;PARENT&gt;.REMOVECHILD( 子元素 );\n&lt;ELEMENT&gt;.SETATTRIBUTE( 属性, &apos;&apos; )\n&lt;ELEMENT&gt;.XXXX = NULL\n</code></pre><p>-&gt; 修改</p>\n<pre><code>-&gt; 修改属性\n    &lt;ELEMENT&gt;.XXX = ...\n    &lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, ... )\n-&gt; 修改节点\n</code></pre><p>-&gt; 查询</p>\n</li>\n<li><p>手动创建一个 TABLE 表格, 并且在里面显示数据<br>VAR ARR = [</p>\n<pre><code>{ NAME: &apos;JIM1&apos;, AGE: 19, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM2&apos;, AGE: 18, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM3&apos;, AGE: 20, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM4&apos;, AGE: 18, GENDER: &apos;男&apos; }\n</code></pre><p>];</p>\n</li>\n</ol>\n<p> #</p>\n<p> ##</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、-面向对象：是一个基于对象的多范式的编程语言\"><a href=\"#一、-面向对象：是一个基于对象的多范式的编程语言\" class=\"headerlink\" title=\"一、 面向对象：是一个基于对象的多范式的编程语言\"></a>一、 面向对象：是一个基于对象的多范式的编程语言</h3><pre><code>多范式：编程风格\n    面向过程的方法编程\n    面向对象的方式编程\n    函数式\n</code></pre><h3 id=\"二、-面向对象的基本概念\"><a href=\"#二、-面向对象的基本概念\" class=\"headerlink\" title=\"二、 面向对象的基本概念\"></a>二、 面向对象的基本概念</h3><ul>\n<li><p>JS 是不是一个面向对象的语言?<br>  不是: 与传统面向对象的理论有矛盾. C#, JAVA<br>  是: JS 里面到处都是对象. 数组, 时间, 正则 … 和 DOM</p>\n<pre><code>也可以像传统面向对象的语言那样用 NEW 的方式创建对象\n</code></pre></li>\n<li><p>JS 是一个基于对象的多范式的编程语言</p>\n<p>  多范式: 编程风格</p>\n<pre><code>面向过程的方式编程\n面向对象的方式编程\n函数式 ...\n</code></pre></li>\n<li>函数式的一个特点: 递归与链式<br>  JQUERY 就是典型的链式编程风格<br>  比如: 给 DIV 标签添加样式<pre><code>$( &apos;DIV&apos; ).CSS( &apos;BORDER&apos;, &apos;1PX SOLID RED&apos; )\n            .CSS( &apos;WIDTH&apos;, &apos;400PX&apos; )\n            .CSS( &apos;HEIGHT&apos;, &apos;200PX&apos; );\n</code></pre></li>\n<li><p>面向对象的概念</p>\n<pre><code>-&gt; 面向: 将脸朝向 ... -&gt; 关注, 用\n    面向过程开发 -&gt; 使用过程的方式开发\n    面向对象开发 -&gt; 使用对象开发\n-&gt; 面向过程\n    早上吃早饭: 吃面\n    自己做: 和面 -&gt; 压成细面 -&gt; 烧水 -&gt; 煮面 -&gt; 盛面 -&gt; 吃\n    过程: 步骤, 细节, 顺序等\n-&gt; 今天早上\n    找到对象: 找到面馆 -&gt; 要 -&gt; 吃\n-&gt; 面向对象: \n    要做什么, 就找到对应的对象, 告诉它做, 等结果\n-&gt; 生活\n    买菜: 菜场\n    公交\n    电话\n    ...\n-&gt; 是否说面向对象可以取代面向过程\n    面向对象是面向过程的封装\n</code></pre><p>  -&gt; 万物皆对象</p>\n<pre><code>在实际开发中, 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集.\n-&gt; 数据集: 很多数据打包到一起. { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; }\n        假设展示 10 条商品数据. 每一个商品: 名字, 描述, 价格, 图片\n        -&gt; \n        每一条数据可以变成对象: { NAME:&apos;&apos;, DESC: &apos;&apos;, PRICE: 0, IMG: &apos;&apos; }\n        -&gt; 引入数组, 将数据存储到数组中\n-&gt; 功能集(函数集, 方法集)\n-&gt; 在 JS 中, 所谓的对象就是 键值对的 集合\n-&gt; 也可以混合使用\n    例如 JQUERY:\n        $( &apos;DIV&apos; )    这个是一个 JQ 对象, 但是实际上里面包含 DOM 对象\n        $( &apos;DIV&apos; ).CSS( ... )\n         $( &apos;DIV&apos; ).HTML( ... )    是不是就说明 JQ 对象中包含方法\n</code></pre><p>  -&gt; 抽象性</p>\n<pre><code>商品列表: 书店, 书的列表\n    书名, 页数, 简介, 编号, 作者            对象只包含最核心的主要信息\n游戏人物: 英雄\n    名字, 血量, 防御, 攻击, 护甲, 武器        只需要描述出需要的数据即可\n</code></pre><p>  -&gt; 名词提炼法找对象</p>\n<pre><code>做一个表格排序\n    -&gt; 过程\n        1) 创建表格\n        2) 添加点击事件\n        3) 排序, 更新数据\n    -&gt; 对象\n        1) 创建表格对象\n        2) 添加数据\n</code></pre><p>  -&gt; 实际开发的时候如果需要完成一个功能</p>\n<pre><code>-&gt; 首先考虑系统是否提供了对象\n    例如创建图片: VAR IMG = NEW IMAGE(); IMG.SRC = &apos;...JPG&apos;;\n    例如获取页面元素: DOCUMENT, 标签对象\n    例如获得导航栏里面的所有的 LI 标签\n        VAR NAV = DOCUMENT.GETELEMENTSBYID( &apos;NAV&apos; );    // NAVIGATION\n        VAR LIS = NAV.GETELEMENTSBYTAGNAME( &apos;LI&apos; );\n-&gt; 如果系统没有可以考虑自定义, 或第三方\n    VAR ITCAST = {\n        TAG: FUNCTION ( TAGNAME ) {\n            RETURN DOCUMENT.GETELEMENTSBYTAGNAME( TAGNAME );\n        }, ADDCSS: FUNCTION ( ARRAY, STYLES ) {\n            FOR ( VAR I = 0; I &lt; ARRAY.LENGTH; I++ ) {\n                FOR ( VAR K IN STYLES ) {\n                    ARRAY[ I ].STYLE[ K ] = STYLES[ K ]; \n                }\n            }\n        }, ID: FUNCTION () {},\n        CNAME: FUNCTION () {},\n        NAME: ...\n        ATTR: ...\n        CLASS: ...\n        ...\n    };\n</code></pre></li>\n</ul>\n<ol>\n<li><p>开发者工具的打开: F12</p>\n<p> 火狐的 FIREBUG</p>\n</li>\n<li><p>调试按钮<br> -&gt; 逐语句: 单步运行. 就是一次只执行一句话. 如果遇到函数, 进入函数体内一步一步执行<br> -&gt; 逐过程: 一次执行一个过程. 如果是一条语句那么与逐语句是一样的. 但是如果是一个函</p>\n<pre><code>数, 那么他就会将函数执行完, 然后在往下走, 停下来.\n</code></pre><p> -&gt; 继续运行</p>\n</li>\n<li><p>条件断点<br> 就是只有在 条件满足的时候(表达式为真的时候) 才会停下来的断点 </p>\n</li>\n<li><p>利用调试工具实现列表播放<br> H5 提供了 两个标签, 一个是 AUDIO, 一个是 VIDEO<br> AUDIO 主要是用来播放音乐的<br> VIDEO 用来播放视频</p>\n<p> 如果标签设置了属性</p>\n<pre><code>AUTOPLAY\nSRC\n</code></pre><p> 我希望当一个音乐播放完成后, 自动播放下一首</p>\n</li>\n<li><p>数据在内存中的存储形式(识记)<br> 计算机只认识数字<br> 计算机根据是否有电信号表示1或0: 准确的说是高低电平<br> 有了二进制数据( 有兴趣的同学可以学习如何转换 )</p>\n<p> 计算机只认识数组, 那么如何表示语言<br> ASCII 码</p>\n<pre><code>0 ~ 127 数字 对应的 表示成 字母\n前 32 个 是控制字符\n从 32 开始 到 127 是可视化字符\n&apos;0&apos;            48\n&apos;A&apos;            97\n&apos;A&apos;            65\n</code></pre><p> 有了这样一个对应关系(映射 MAP), 那么一段文字就可以使用一串数字表示了</p>\n<p> 表示中文的 GB2312 编码, 简体中文编码. 英文标点和数字等使用一个字节</p>\n<pre><code>中文使用两个字节.\n</code></pre><p> UNICODE 编码( 万国码 ). 所有的字符才偶用两个字节表示.</p>\n<pre><code>例如表示字符 &apos;A&apos;    2 个字节\n在页面中使用最多的是: 数字, 字母, 标点符号\n</code></pre><p> UTF-8 编码( 通用转换格式 ). 所有与 ASCII 编码相符的字符采用一个字节.</p>\n<pre><code>而汉字采用 3 个字节.\n</code></pre></li>\n<li><p>在 JS 中允许使用 UNICODE 编码表示字符串<br> 语法: \\U + 4 位 16 进制数</p>\n<p> 使用这种方式表示数据, 在表示 与 ASCII 码重合字符是没有意义的. 但是对于中文<br> 由于存在不同的编码, 而不同编码在不同平台上可以正常显示, 但是随着网络传播,<br> 不是在所有平台上可以通用. 因此数据传送中文一般采用 UNICODE 编码形式.</p>\n</li>\n<li><p>数字 + 上下文 = 信息<br> 97        ‘A’    数字 97</p>\n<p> 在此处不要深究, 只需要了解内存模型即可.</p>\n<p> 内存就是一个可以存储数字( 数据 )的盒子.</p>\n</li>\n</ol>\n<ol>\n<li>JS 的数据类型<br>-&gt; 基本类型( 值类型 ): 数字 NUMBER, 字符串 STRING, 布尔 BOOLEAN<br>-&gt; 复合类型( 引用类型 ): 对象( 数组, 时间类型, 函数类型, 正则表达式, … )<br>-&gt; 空类型: NULL, UNDEFINED</li>\n</ol>\n<pre><code>基本数据类型和空类型的存储模型就是一个方格里面放一个数据\n复合类型, 除了函数, 其他的数据类型无法使用 TYPEOF 获得数据类型名\n注意: 如果需要获得对象的数据类型, 需要使用 OBJECT.PROTOTYPE.TOSTRING.APPLY( 数据 )\n</code></pre><ol>\n<li><p>复合类型的存储方式<br>VAR P = { NAME: ‘ITCAST’ }</p>\n<p>复合类型的对象是一个单独的内存区域, 对象有什么属性, 那么内存区域中就有什么数据.<br>变量 P 只存储该对象的 ‘地址’. 所以 P 不是真正存储数据的区域.</p>\n<p>绘制数据的内存逻辑图</p>\n<p>VAR ARR1 = [ 1, 2, 3, 4 ];<br>VAR ARR2 = [</p>\n<pre><code>{ NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; },\n{ NAME: &apos;李四&apos;, AGE: 18, GENDER: &apos;男&apos; },\n{ NAME: &apos;小李&apos;, AGE: 17, GENDER: &apos;女&apos; }\n</code></pre><p>];</p>\n</li>\n<li><p>值类型与引用类型的存储特征<br>-&gt; 值类型的数据, 只需要开辟一段内存存储数据即可</p>\n<pre><code>VAR A = 123; \nVAR B = &apos;ABC&apos;;\nVAR C = TRUE;\n</code></pre><p>-&gt; 对象类型( 引用类型 ). 对象才是真正的数据, 需要占据单独的内存.</p>\n<pre><code>而变量名只是存储着对象的内存地址( 引用 ).\n\n即创建一个对象并赋值, 实际上需要两块内存空间. 一个存储数据( 对象 ),\n另一个存储变量以引用对象.\n\nVAR O = { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; };\n</code></pre></li>\n</ol>\n<ol>\n<li><p>值类型与引用类型的赋值与传参的特性<br>-&gt; 赋值: 将原变量中的数据拷贝一份, 然后存储到给定变量中</p>\n<pre><code>-&gt; 值类型\n    VAR A = 123;    // 有一个盒子, 叫 A, 里面存储着数字 123\n    VAR B;            // 又有一个盒子, 叫 B, 里面什么都没存( UNDEFINED )\n    B = A;            // 将 A 中存储的东西复制一份, 然后赋值给 B. 即存储在 B 中\n\n    B 和 A 是两个独立的变量, 两者之间不再有关系. 改变其中一个数据, 另一个不变\n-&gt; 引用类型\n    VAR O1 = { NUM: 123 };\n    VAR O2;\n    // 赋值\n    O2 = O1;     // 将 O1 中存储的内容 拷贝一份 存储到 O2 中\n                // O1 中存储的是引用, 或 &apos;地址&apos;\n\n    O1 和 O2 虽然是不相同的两个变量, 即两个独立的盒子. 但是由于存储的地址相同.\n    在访问数据的时候, O1 与 O2 也是访问同一个数据, O1 将数据修改了, O2 再读取,\n    读取的就是修改后的数据. \n</code></pre><p>-&gt; 函数参数传递</p>\n<pre><code>-&gt; 什么是函数参数传递\n    函数要调用, 一般会给函数传递参数\n        在调用函数的时候, 回将参数中表示的数据拷贝一份, 然后给参数赋值\n    FUNCTION FOO( NUM ) {}\n\n    // 调用\n    VAR A = 123;\n    FOO( A );        // 调用函数就是要执行函数\n                    // 将 A 中存储的数据 拷贝一份\n                    // 进入 函数 FOO\n                    // 给参数赋值, 相当于 NUM = A\n                    // 进入函数体, 开始执行函数\n    此时的赋值特性与前面介绍的值类型引用类型的赋值是一个特点\n</code></pre></li>\n<li><p>深拷贝与浅拷贝<br>-&gt; 什么是拷贝: 就是创建一个与目标数据一模一样的数据<br>-&gt; 案例:</p>\n<pre><code>VAR P = { NAME: &apos;张三&apos; };\nVAR P1 = P;                   // 是否存在拷贝\n // 一般描述拷贝是指拷贝对象\n P1 = {};\n P1.NAME = P.NAME;\n // 才是拷贝\n</code></pre><p> -&gt; 案例, 给 对象 P 提供一个 CLONE 方法, 完成拷贝<br> -&gt; 案例:</p>\n<pre><code>有一辆汽车 CAR: NAME=保时捷\n有一个人 PERSON : NAME=张三\n</code></pre><p> -&gt; 如果对象的属性也是一个引用类型, 拷贝的时候不重新创建一个新的对象来实现该属性的拷贝, 那么就是浅拷贝.</p>\n<pre><code>即任何不完全的拷贝都是浅拷贝\n</code></pre><p> -&gt; 将两个对象完全从内存中隔离开, 就是深拷贝. 即每一个引用属性, 以及引用属性的引用属性, … 全部拷贝出来.</p>\n</li>\n<li><p>构造函数( 构造器 CONTROCTOR )的作用<br>-&gt; JS 中对象的动态特性</p>\n<pre><code>即 想要什么属性就可以提供什么属性\n在 JS 中 对象如果没有指定的属性, 只需要利用赋值就可以给对象提供该属性.\n</code></pre><p>-&gt; 点语法与关联数组语法</p>\n<pre><code>O.NAME = &apos;JIM&apos;;                // 点语法赋值（NAME是一个名字）\nCONSOLE.LOG( O.NAME );        // 点语法取值\nO[ &apos;NAME&apos; ] = &apos;TOM&apos;;        // +关联数组语法赋值（NAME一定要是字符串）\nO[AGE];                     //会出错  AGE不存在\nO[ &apos;NAME&apos; ] = &apos;TOM&apos;;        //这里的NAME不能为对象\n\nCONSOLE.LOG( O[ &apos;NAME&apos; ] ); // 关联数组语法取值\n\n问题:\n    // 如果 NAME 是一个变量, 里面存储的是 字符串, 也是可以的\n    O[ NAME ] = &apos;JACK&apos;;   // 对或不对?\nWINDOW.NAME 为空 &quot;&quot;    WINDOW里面有NAME\n</code></pre><p>-&gt; 例创建一个 PERSON 对象</p>\n<pre><code>VAR P = {};        // 什么都没有的对象\n// 根据需要添加成员\nP.NAME = &apos;张三&apos;;\nP.AGE = 30;\nP.GENDER = &apos;男&apos;;\n</code></pre><p>-&gt; 简化: 提供一个创建 PERSON 对象的函数</p>\n<pre><code>FUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n    VAR P = {};\n    P.NAME = NAME;\n    P.AGE = AGE;\n    P.GENDER = GENDER;\n    RETURN P;\n}\n\nVAR P1 = CREATEPERSON( &apos;JIM&apos;, 19, &apos;男&apos; );\nVAR P2 = CREATEPERSON( &apos;LILY&apos;, 18, &apos;女&apos; );\n\n这个( 这种类型 )的函数就是用来创建对象的, 即生产对象. 常常将这类函数\n称为 &apos;工厂函数&apos;\n</code></pre></li>\n<li><p>构造方法创建对象<br>-&gt; 构造器中不需要 RETURN 语句. 一般也可以不写<br>-&gt; 调用构造器的时候, 使用 NEW 运算符引导<br>-&gt; 在构造器中 THIS 表示当前对象. 给对象提供成员使用 THIS.XXX 的 方式</p>\n<p>-&gt; 将 CREATEPERSON 改造成构造器</p>\n<pre><code>// 构造器的定义\nFUNCTION CREATEPERSON( NAME, AGE, GENDER ) {\n    THIS.NAME = NAME;\n    THIS.AGE = AGE;\n    THIS.GENDER = GENDER;\n}\n// 调用构造器创建对象\nVAR P = NEW CREATEPERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); \n当构造函数，同时出现RETUR和NEW的时候，看RETURN后面的值，\n如果为数值则返回THIS ，如果是引用类型，就返回引用类型。\n</code></pre><p>-&gt; 构造器创建对象的本质: 还是使用对象的动态特性</p>\n<pre><code>-&gt; 首先执行 NEW 运算符. 即创建对象. 可以简单看做为 {} 的简写\n    VAR P = NEW ...   &apos;相当于&apos;   VAR P = {}\n-&gt; 调用构造器. 并隐含一个参数, 即刚刚创建的对象. \n-&gt; 在构造器中使用 THIS 引用刚刚创建出来的对象.\n-&gt; 构造器结束是 默认返回 THIS\n\n本质还是利用对象的动态特性\n</code></pre><p>-&gt; 补充说明</p>\n<pre><code>-&gt; 构造器的名字, 一般使用 PASCAL 命名规则( 首字母大写的 )\n-&gt; 一般为了与其他面向对象的编程语言( C++, C#, JAVA )保持一致. 称构造函数名为类名\n\nFUNCTION PERSON( NAME, AGE, GENDER ) {\n    THIS.NAME = NAME;\n    THIS.AGE = AGE;\n    THIS.GENDER = GENDER;\n}\n// 调用构造器创建对象\nVAR P = NEW PERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); \n</code></pre></li>\n<li><p>异常与捕获<br>-&gt; 异常</p>\n<pre><code>简单的说, 就是代码在执行过程中出现的错误. 并不是代码的语法错误.\n</code></pre><p>-&gt; 一旦出现异常, 其后的代码, 不再执行</p>\n<p>-&gt; TRY-CATCH 语法</p>\n<pre><code>1) TRY-CATCH 形态\n    TRY {\n        代码\n    } CATCH ( E ) {\n        代码\n    }\n2) TRY-CATCH-FINALLY 形态\n    TRY {\n        代码\n    } CATCH ( E ) {\n        代码\n    } FINALLY {\n        代码\n    } （无论代码出错还是没有出错都要执行）\n</code></pre><p>-&gt; 自定义抛出异常</p>\n<pre><code>一般可以封装函数完成特定的功能. 例如 TAG 函数\nFUNCTION TAG ( TAGNAME ) {\n    IF ( TAGNAME 不是字符串 ) 抛出异常. \n    RETURN DOCUMENT.GETELEMENTSBYTAGNAME ( TAGNAME );\n}\n</code></pre><p>-&gt; 抛出异常的语法</p>\n<pre><code>THROW 对象\n</code></pre></li>\n<li><p>DOM 的核心内容<br>-&gt; 什么是 DOM, 为什么需要 DOM</p>\n<pre><code>&lt;DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;/DIV&gt;\n</code></pre><p>-&gt; DOM 操作操作的是什么?</p>\n<pre><code>-&gt; 访问各亲属节点\n-&gt; 增删改查\n</code></pre><p>-&gt; 学会分析 DOM 树</p>\n<pre><code>&lt;DIV&gt;\n    &lt;P&gt;你好, 我是一个 &lt;SPAN STYLE=&quot;COLOR: RED&quot;&gt;DOM&lt;/SPAN&gt; 树的练习&lt;/P&gt;\n&lt;/DIV&gt;\n\n在 HTML 文件结构中吗所有的内容都是节点(NODE)对象. 有的是文本节点.\n有的是标签( 元素 ELEMENT )对象. 还有的是属性节点( ATTRIBUTE NODE )对象.\n</code></pre></li>\n<li><p>访问各个亲属节点<br>-&gt; 节点对象的常用属性</p>\n<pre><code>&lt;NODE&gt;.NODETYPE\n    元素(标签): 1, \n    属性: 2, \n    文本: 3\n&lt;NODE&gt;.NODENAME\n    元素(标签): 大写的标签名, \n    属性: 属性名\n    文本: #TEXT\n&lt;NODE&gt;.NODEVALUE\n    元素(标签): NULL\n    属性: 属性赋值等号后面的值\n    文本: 文本字符串\n</code></pre></li>\n<li><p>操作 DOM 就是创建元素, 插入元素, 修改元素, 查询元素, 删除元素<br>-&gt; 增加</p>\n<pre><code>// 创建\nDOCUMENT.CREATEELEMENT( &apos;元素名&apos; )            创建元素标签\nDOCUMENT.CREATETEXTNODE( &apos;文本内容&apos; )        创建文本节点\n// 插入\n&lt;PARENT&gt;.APPENDCHILD( 子元素 )                追加到子元素的结尾\n&lt;PARENT&gt;.INSERTBEFORE( 新元素, 旧元素 )        将新元素插入到旧元素的前面\n\n// 简单的办法\n&lt;ELEMENT&gt;.INNERHTML = ...\n&lt;ELEMENT&gt;.INNERTEXT = ...\n\n// 增加属性\n&lt;ELEMENT&gt;.属性名 = ...\n&lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, 值 );\n&lt;ELEMENT&gt;.STYLE.XXXX = ...\n</code></pre><p>-&gt; 删除</p>\n<pre><code>&lt;PARENT&gt;.REMOVECHILD( 子元素 );\n&lt;ELEMENT&gt;.SETATTRIBUTE( 属性, &apos;&apos; )\n&lt;ELEMENT&gt;.XXXX = NULL\n</code></pre><p>-&gt; 修改</p>\n<pre><code>-&gt; 修改属性\n    &lt;ELEMENT&gt;.XXX = ...\n    &lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, ... )\n-&gt; 修改节点\n</code></pre><p>-&gt; 查询</p>\n</li>\n<li><p>手动创建一个 TABLE 表格, 并且在里面显示数据<br>VAR ARR = [</p>\n<pre><code>{ NAME: &apos;JIM1&apos;, AGE: 19, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM2&apos;, AGE: 18, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM3&apos;, AGE: 20, GENDER: &apos;男&apos; },\n{ NAME: &apos;JIM4&apos;, AGE: 18, GENDER: &apos;男&apos; }\n</code></pre><p>];</p>\n</li>\n</ol>\n<p> #</p>\n<p> ##</p>\n"},{"title":"TypeScript","_content":"## 一、准备\n---\n### 1. 安装\n`npm install -g typescript`\n### 2. vscode自动编译\n- 项目目录终端执行 `tsc --init`\n- 更改tsconfig.json \"outDir\": \"./js\"\n\n## 二、基础语法\n---\n### 1.数据类型\n- 布尔值\n- 数字\n- 字符串\n- 数组\n- 元组 Tuple\n- 枚举\n- Any\n- Void （函数没有返回值使用。）\n- Null 和 Undefined （默认情况下null和undefined是所有类型的子类型。）\n- Never （never类型是任何类型的子类型）\n- Object\n\n### 2.函数\n\n```\n声明函数\nfunction run():string {\n    return 'typescript';\n}\n匿名函数\nvar fun = function():string {\n    return 'typescript';\n}\n定义方法传参\nfunction user(name:string,age:number):string {\n    return `${name}----${age}`;\n}\nvar user = function(name:string,age:number):string {\n    return `${name}----${age}`;\n}\n没有返回值\nfunction run():void {\n    console.log('typescript'  );\n}\n方法可选参数\nfunction user(name: string,age?:number):string {\n    return `${name}----${age}`;\n}\n方法参数默认值\nfunction user(name: string,age:number=20):string {\n    return `${name}----${age}`;\n}\n方法剩余参数\nfunction user(...result:number[]):string {\n    \n}\nfunction user(name: string,...result:number[]):string {\n    \n}\n重载\nfunction user(name: string):string;\nfunction user(age: number):number;\nfunction user(str:any):any {\n    if(typeof str==='string) {\n        return str\n    } else {\n        return str\n    }\n}\n```\n\n### 3.类\n```\n基本模型\nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    run():void {\n        alert(this.name);\n    }\n}\n\nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    setName():void {\n        this.name = name;\n    }\n    getName():string {\n        alert(this.name);\n    }\n}\nvar person1 = new Person('张三');\nalert(person1.getName());\nperson1.setName('李四')；\nalert(person1.getName());\n```\n\n### 4.继承\n``` \nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    run():string {\n        return `${this.name}`\n    }\n}\n\n子类可以使用父类的属性和方法  如果子类的方法或者属性和父类相同  则以子类为主\nclass Web extends Person {\n    constructor(name:string) {\n        super(name); //初始化父类的构造函数\n    }\n    work():string {\n        return `${this.name}在运动`\n    }\n    run():string {\n        return `${this.name}` \n    }\n}\nvar w = new Web('李四');\nalert(w.run());\n\n```\n\n### 5.类里面的修饰符\n- public\n\n> 共有类型 在类里面、子类、类外面都可以访问(默认，不写默认就是)。\n\n- protected \n\n> 保护类型 在类里面、子类可以访问，类外面都不可以访问。\n\n- private\n\n> 私有类型 在类里面可以访问，子类和类外面都不可以访问。\n\n### 6.类的静态属性和静态方法 \n\n- static （静态方法里面不能直接调用类里面的属性，能调用静态属性）\n\n```\nclass Person {\n    public name:string;\n    static age:number=20;\n    constructor(name) {\n        this.name = name;\n    }\n    run() {\n        alert(`${this.name}在运动`);\n    }\n    static print() {\n        alert(`print`+Person.age); \n    }\n}\n```\n\n### 7.多态\n- 父类定义一个方法不去实现，让继承它的子类去实现，让每一个子类有不同的表现\n\n```\nclass Animal {\n    name:string;\n    constructor(name:string){\n        this.name = name;\n    }\n    eat() {\n        console.log('吃的方法');\n    }\n}\nclass Dog extends Animal {\n    constructor(name:string) {\n        super(name)\n    }\n    eat() {\n        return this.name + '骨头'\n    }\n}\nclass Cat extends Animal {\n    constructor(name:string) {\n        super(name)\n    }\n    eat() {\n        return this.name + '鱼'\n    }\n}\n```\n\n### 8.抽象类\n- 提供标准 \n- abstract 抽象类不能实例化 为子类提供基类\n- 子类必须实现父类的抽象方法\n- abstract必须放在抽象类里面\n\n```\nabstract class Animal {\n    name:string;\n    constructor(name:string){\n        this.name = name;\n    }\n    abstract eat():any;\n}\nclass Dog extends Animal {\n    constructor(name:any) {\n        super(name);\n    }\n    eat() {\n        console.log(this.name);\n    }\n}\n\n```\n\n### 8.接口\n- 定义规范 定义行为和动作的规范 （接口不关心类内部的数据状态和方法实现的细节）\n\n```\ninterface FullName {\n    firstName: string;\n    secondName: string;\n}\nfunction printName(name: FullName) {\n    console.log(name.firstName+ '--' +name.secondName)\n}\nvar obj = {\n    firstName: 'sun',\n    secondName: 'yu'\n}\nprintName(obj) // ok\n\n\n接口的可选属性\ninterface FullName {\n    firstName: string;\n    secondName?: string;\n}\nfunction printName(name: FullName) {\n    console.log(name.firstName+ '--' +name.secondName)\n}\nvar obj = {\n    firstName: 'sun',\n    secondName: 'yu'\n}\nprintName(obj) // ok\nvar obj = {\n    firstName: 'sun'\n}\nprintName(obj) // ok\n\n函数类型的接口\ninterface encrypt {\n    (key:string,value:string):string;\n}\nvar md5:encrypt = function(key:string,value:string):string {\n    return key+value;\n}\nmd5('key','value');\n\n可索引接口 数组和对象的约束(不常用)\ninterface userArr {\n    [index:number]:string\n}\nvar arr:userArr = ['string','string']; //ok\n\ninterface userObj {\n    [index:string]:string\n}\nvar arr:userObj = ['string','string']; //ok\n\n类类型接口 对类的约束\ninterface Animal {\n    name:string;\n    eat(str:string):void;\n}\nclass Dog implements Animal {\n    name: string;\n    constructor(name:string) {\n        this.name = name;\n    }\n    eat() {\n        return `吃骨头`;\n    }\n}\nvar dog = new Dog('小黑');\ndog.eat();\n\n\n接口扩展  接口扩展接口\ninterface Animal {\n    eat():void;\n}\ninterface Person extends Animal {\n    work():void;\n}\nclass Web implements Person {\n    public name:string;\n    constructor(name:string){\n        this.name= name;\n    }\n    eat() {\n        console.log(this.name+'喜欢吃馒头');\n    }\n    work() {\n        console.log(this.name+'爱工作');\n    }\n}\n\n---------------------------\n\ninterface Animal {\n    eat():void;\n}\ninterface Person extends Animal {\n    work():void;\n}\nclass programmer {\n    public: name:string;\n    constructor(name:string) {\n        this.name = name;\n    }\n    coding(code:string){\n        console.log(this.name+code);\n    }\n}\nclass Web extends programmer implements Person {\n    constructor(name:string){\n        super(name)\n    }\n    eat() {\n        console.log(this.name+'喜欢吃馒头');\n    }\n    work() {\n        console.log(this.name+'爱工作');\n    }\n}\n\n```\n\n### 9.泛型\n```\nfunction getData<T>(value:T):T {\n    return value;\n}\ngetData<number>(123);\n\nfunction getData<T>(value:T):any {\n    return value;\n}\ngetData<number>(123);\ngetData<string>('123');\n\n泛型类\nclass MinClass<T> {\n    public list:T[]=[];\n    add(value:T):void {\n        this.list.push(value);\n    }\n    min():T{\n        var minNum = this.list[0];\n        for(var i=0;i<this.list.length;i++) {\n            if(minNum>this.list[i]) {\n                minNum = this.list[i];\n            }\n        }\n        return minNum;\n    }\n}\n\nvar m1 = new MinClass<number>();  // 实例化类 并且制定类的T代表类型是number\nm1.add(123);\nvar m2 = new MinClass<string>();  // 实例化类 并且制定类的T代表类型是string\nm2.add('123');\n\n泛型接口\ninterface ConfigFn {\n    <T>(value:T):T;\n}\nvar getData:ConfigFn = function<T>(value: T):T {\n    return value;\n}\ngetData<string>('张三');\ngetData<number>(123);\n\ninterface ConfigFn<T> {\n    <T>(value:T):T;\n}\nfunction getData<T>(value: T):T {\n    return value;\n}\n\nvar myGetData:ConfigFn<string>=getData;\nmyGetData('张三');\nvar myGetDataw:ConfigFn<number>=getData;\nmyGetData(123);\n\n\n把类作为参数来约束数据传入类型\nclass User {\n    userName: string | undefined;\n    password: string | undefined;\n}\nclass MysqlDb {\n    add(User:User):boolean {\n        console.log(User);\n        return true;\n    }\n}\nvar user = new User();\nuser.userName = '张三';\nuser.password = '123456';\nvar db = new MysqlDb();\ndb.add(user);\n \n泛型类\nclass User {\n    userName: string | undefined;\n    password: string | undefined;\n}\nclass MysqlDb {\n    add(User:T):boolean {\n        console.log(User);\n        return true;\n    }\n}\nvar user = new User();\nuser.userName = '张三';\nuser.password = '123456';\nvar db = new MysqlDb<User>();\ndb.add(user);\n\n\n约束规范使用接口，代码重用使用泛型。\n\ninterface DBI<T> {\n    add(info:T):boolean;\n    update(info:T,id:number):boolean;\n    delete(id:number):boolean;\n    get(id:number):any[];\n}\nclass MysqlDb<T> implements DBI<T> {\n    add(info:T):boolean {\n        console.log(info);\n        return true;\n    }\n    update(info:T,id:number):boolean {\n        console.log(info,id);\n        return true;\n    }\n    delete(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n    get(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n}\nclass Mongodb<T> implements DBI<T> {\n    add(info:T):boolean {\n        console.log(info);\n        return true;\n    }\n    update(info:T,id:number):boolean {\n        console.log(info,id);\n        return true;\n    }\n    delete(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n    get(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n}\n\n```\n\n### 10.模块\n- 模块的概念(官方): ”内部模块“=》”命名空间“，”外部模块“=》”模块“ 模块在其自身的作用域里面执行，而不是在全局作用域执行。这就意味着定义一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确的使用export形式之一导出他们。相反，如果想使用其他模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import形式之一。\n- 模块的概念(自己理解): 我们可以把一些公共的功能单独抽离成一个文件作为一个模块。模块里面的变量，函数，类等都是私有的，如果我们要在外部访问模块里面的数据（变量，函数，类），我们需要通过export暴露模块里面的数据（变量、函数、类、、、）暴露后我们通过im\bport引用模块里面的数据（变量，函数，类）。\n\n```\n定义 db.ts\nvar a:string = \"string\";\nfunction getData(value:string):string {\n    return value\n}\nexport {\n    a,\n    getData\n}\n使用\nimport { a,getDate } form './db'\ngetData();\nimport { a,getData as get} form './db'\nget();\n\n定义 db.ts\nexprot default function getData(value:string):string {\n    return value\n}\n使用\nimport getData form './db'\ngetData();\n\n```\n\n### 11.命名空间\n- 命名空间和模块的区别： 命名空间，内部模块，主要用于组织代码，避免命名冲突。  模块，ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。\n\n```\nnamespace A {\n    interface Animal {\n        name:string;\n        eat(str:string):void;\n    }\n    export class Dog implements Animal {\n        name: string;\n        constructor(name:string) {\n            this.name = name;\n        }\n        eat() {\n            return `吃骨头`;\n        }\n    }\n}\nvar dog = A.Dog(\"小黑\");\ndog.eat();\n\n命名空间封装成模块\na.ts文件名\n定义\nexport namespace A {\n    interface Animal {\n        name:string;\n        eat(str:string):void;\n    }\n    export class Dog implements Animal {\n        name: string;\n        constructor(name:string) {\n            this.name = name;\n        }\n        eat() {\n            return `吃骨头`;\n        }\n    }\n}\n使用\nimport { a } from './a'\nvar dog = new a.Dog();\ndog.eat();\n\n```\n\n### 12.装饰器\n- 装饰器： 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。\n- 通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。\n- 常见的装饰器有： 类装饰器、属性装饰器、方法装饰器、参数装饰器。\n- 装饰器写法： 普通装饰器（无法传参）、装饰器工厂（可传参）。\n- 装饰器是过去几年中js最大的成就之一，已经是Es7的标准特性之一。\n\n```\n1.类装饰器(普通装饰器，无法传参)\nfunction logClass(params:any){\n    console.log(params);\n    params.prototype.apiUrl=\"动态扩展的属性\";\n    params.prototype.run = function() {\n        console.log(\"我是run方法\");\n    }\n}\n@logClass\nhttpClient {\n    constructor() {\n\n    }\n    getData() {\n\n    }\n}\nvar H = new httpClient();\nconsole.log(H.apiUrl);\nH.run();\n\n2.类装饰器(装饰器工厂，可传参)\nfunction logClass(params:string){\n    return function(target:any) {\n        target.prototype.apiUrl=\"动态扩展的属性\";\n        target.prototype.run = function() {\n            console.log(\"我是run方法\");\n        }\n    }\n}\n@logClass('hello')\nhttpClient {\n    constructor() {\n\n    }\n    getData() {\n\n    }\n}\n\n把类赋值给target\n把参数赋值给params\n\nvar H:any = new httpClient();\nconsole.log(H.apiUrl);\nH.run();\n\n类装饰器重载以前类的构造函数\nfunction logClass(target: any) {\n    console.log(target);\n    return class extends target{\n        apiUrl:any = \"我是修改后的url\";\n        getData() {\n            console.log(this.apiUrl);\n        }\n    }\n}\n@logClass\nhttpClient {\n\n    public apiUrl: string | undefined;\n    constructor() {\n        this.apiUrl = 'url';\n    }\n    getData() {\n        console.log(this.apiUrl);\n    }\n}\nvar http = new httpClient();\n\n------------------------------\n3.属性装饰器(属性装饰器表达式会在运行时当作函数调用，传入下列两个参数，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象)\nfunction logClass(params:any){\n    console.log(params);\n    params.prototype.apiUrl=\"动态扩展的属性\";\n    params.prototype.run = function() {\n        console.log(\"我是run方法\");\n    }\n}\nfunction logProperty(params:string){\n    return function(target: any,attr:any) {\n        console.log(target);\n        console.log(target[attr]);\n        target[attr] = params;\n    }\n}\n@logClass('xxx')\nhttpClient {\n    @logProperty(\"http://baidu.com\");\n    public url: string | undefined;\n    constructor() {\n        \n    }\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http = new httpClient();\nhttp.getData();\n\n4.方法装饰器\n它会被应用到的方法的属性描述符上，可以用来监视，修改或者替换方法定义\n方法装饰器会在运行是传入下列3个参数\n（1）对于静态成员来说类的构造函数，对于实例成员来说是类的原型对象。\n（2）成员的名字。\n（3）成员的属性描述符。\n\nfunction logMethod(params: any) {\n    return function(target:any,methodName:any,desc:any) {\n        console.log(target);\n        console.log(methodName);\n        console.log(desc);\n        target.apiUrl=\"动态扩展的属性\";\n        target.run = function() {\n            console.log(\"我是run方法\");\n        }\n    }\n}\n\nhttpClient {\n    constructor() {\n        \n    }\n    @logMethod(\"http://baidu.com\")\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http:any = new httpClient();\nhttp.run();\n\n------------------------------------------\n\nfunction logMethod(params: any) {\n    return function(target:any,methodName:any,desc:any) {\n        console.log(target);\n        console.log(methodName);\n        console.log(desc);\n        //修改装饰器的方法 把装饰器方法传入所以参数改为string类型\n        //保存当前的方法\n        var oMethod = desc.value;\n        desc.value = function(...args:any[]) {\n            args = args.map((value)=>{\n                return String(value)\n            });\n            console.log(args);\n        }\n    }\n}\n\nhttpClient {\n    public url:any | undefined;\n    constructor() {\n        \n    }\n    @logMethod(\"http://baidu.com\")\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http:any = new httpClient();\nhttp.getData(123,'xxx');\n\n```","source":"_posts/TypeScript/TypeScript.md","raw":"---\ntitle: TypeScript\ncategories: ['前端']\ntags: ['TypeScript'] \n---\n## 一、准备\n---\n### 1. 安装\n`npm install -g typescript`\n### 2. vscode自动编译\n- 项目目录终端执行 `tsc --init`\n- 更改tsconfig.json \"outDir\": \"./js\"\n\n## 二、基础语法\n---\n### 1.数据类型\n- 布尔值\n- 数字\n- 字符串\n- 数组\n- 元组 Tuple\n- 枚举\n- Any\n- Void （函数没有返回值使用。）\n- Null 和 Undefined （默认情况下null和undefined是所有类型的子类型。）\n- Never （never类型是任何类型的子类型）\n- Object\n\n### 2.函数\n\n```\n声明函数\nfunction run():string {\n    return 'typescript';\n}\n匿名函数\nvar fun = function():string {\n    return 'typescript';\n}\n定义方法传参\nfunction user(name:string,age:number):string {\n    return `${name}----${age}`;\n}\nvar user = function(name:string,age:number):string {\n    return `${name}----${age}`;\n}\n没有返回值\nfunction run():void {\n    console.log('typescript'  );\n}\n方法可选参数\nfunction user(name: string,age?:number):string {\n    return `${name}----${age}`;\n}\n方法参数默认值\nfunction user(name: string,age:number=20):string {\n    return `${name}----${age}`;\n}\n方法剩余参数\nfunction user(...result:number[]):string {\n    \n}\nfunction user(name: string,...result:number[]):string {\n    \n}\n重载\nfunction user(name: string):string;\nfunction user(age: number):number;\nfunction user(str:any):any {\n    if(typeof str==='string) {\n        return str\n    } else {\n        return str\n    }\n}\n```\n\n### 3.类\n```\n基本模型\nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    run():void {\n        alert(this.name);\n    }\n}\n\nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    setName():void {\n        this.name = name;\n    }\n    getName():string {\n        alert(this.name);\n    }\n}\nvar person1 = new Person('张三');\nalert(person1.getName());\nperson1.setName('李四')；\nalert(person1.getName());\n```\n\n### 4.继承\n``` \nclass Person {\n    name: string; //属性 省略publick 关键词\n    constructor(name:string) {  //构造函数 实例化的时候调用的方法(初始化对象)\n        this.name = name;\n    }\n    run():string {\n        return `${this.name}`\n    }\n}\n\n子类可以使用父类的属性和方法  如果子类的方法或者属性和父类相同  则以子类为主\nclass Web extends Person {\n    constructor(name:string) {\n        super(name); //初始化父类的构造函数\n    }\n    work():string {\n        return `${this.name}在运动`\n    }\n    run():string {\n        return `${this.name}` \n    }\n}\nvar w = new Web('李四');\nalert(w.run());\n\n```\n\n### 5.类里面的修饰符\n- public\n\n> 共有类型 在类里面、子类、类外面都可以访问(默认，不写默认就是)。\n\n- protected \n\n> 保护类型 在类里面、子类可以访问，类外面都不可以访问。\n\n- private\n\n> 私有类型 在类里面可以访问，子类和类外面都不可以访问。\n\n### 6.类的静态属性和静态方法 \n\n- static （静态方法里面不能直接调用类里面的属性，能调用静态属性）\n\n```\nclass Person {\n    public name:string;\n    static age:number=20;\n    constructor(name) {\n        this.name = name;\n    }\n    run() {\n        alert(`${this.name}在运动`);\n    }\n    static print() {\n        alert(`print`+Person.age); \n    }\n}\n```\n\n### 7.多态\n- 父类定义一个方法不去实现，让继承它的子类去实现，让每一个子类有不同的表现\n\n```\nclass Animal {\n    name:string;\n    constructor(name:string){\n        this.name = name;\n    }\n    eat() {\n        console.log('吃的方法');\n    }\n}\nclass Dog extends Animal {\n    constructor(name:string) {\n        super(name)\n    }\n    eat() {\n        return this.name + '骨头'\n    }\n}\nclass Cat extends Animal {\n    constructor(name:string) {\n        super(name)\n    }\n    eat() {\n        return this.name + '鱼'\n    }\n}\n```\n\n### 8.抽象类\n- 提供标准 \n- abstract 抽象类不能实例化 为子类提供基类\n- 子类必须实现父类的抽象方法\n- abstract必须放在抽象类里面\n\n```\nabstract class Animal {\n    name:string;\n    constructor(name:string){\n        this.name = name;\n    }\n    abstract eat():any;\n}\nclass Dog extends Animal {\n    constructor(name:any) {\n        super(name);\n    }\n    eat() {\n        console.log(this.name);\n    }\n}\n\n```\n\n### 8.接口\n- 定义规范 定义行为和动作的规范 （接口不关心类内部的数据状态和方法实现的细节）\n\n```\ninterface FullName {\n    firstName: string;\n    secondName: string;\n}\nfunction printName(name: FullName) {\n    console.log(name.firstName+ '--' +name.secondName)\n}\nvar obj = {\n    firstName: 'sun',\n    secondName: 'yu'\n}\nprintName(obj) // ok\n\n\n接口的可选属性\ninterface FullName {\n    firstName: string;\n    secondName?: string;\n}\nfunction printName(name: FullName) {\n    console.log(name.firstName+ '--' +name.secondName)\n}\nvar obj = {\n    firstName: 'sun',\n    secondName: 'yu'\n}\nprintName(obj) // ok\nvar obj = {\n    firstName: 'sun'\n}\nprintName(obj) // ok\n\n函数类型的接口\ninterface encrypt {\n    (key:string,value:string):string;\n}\nvar md5:encrypt = function(key:string,value:string):string {\n    return key+value;\n}\nmd5('key','value');\n\n可索引接口 数组和对象的约束(不常用)\ninterface userArr {\n    [index:number]:string\n}\nvar arr:userArr = ['string','string']; //ok\n\ninterface userObj {\n    [index:string]:string\n}\nvar arr:userObj = ['string','string']; //ok\n\n类类型接口 对类的约束\ninterface Animal {\n    name:string;\n    eat(str:string):void;\n}\nclass Dog implements Animal {\n    name: string;\n    constructor(name:string) {\n        this.name = name;\n    }\n    eat() {\n        return `吃骨头`;\n    }\n}\nvar dog = new Dog('小黑');\ndog.eat();\n\n\n接口扩展  接口扩展接口\ninterface Animal {\n    eat():void;\n}\ninterface Person extends Animal {\n    work():void;\n}\nclass Web implements Person {\n    public name:string;\n    constructor(name:string){\n        this.name= name;\n    }\n    eat() {\n        console.log(this.name+'喜欢吃馒头');\n    }\n    work() {\n        console.log(this.name+'爱工作');\n    }\n}\n\n---------------------------\n\ninterface Animal {\n    eat():void;\n}\ninterface Person extends Animal {\n    work():void;\n}\nclass programmer {\n    public: name:string;\n    constructor(name:string) {\n        this.name = name;\n    }\n    coding(code:string){\n        console.log(this.name+code);\n    }\n}\nclass Web extends programmer implements Person {\n    constructor(name:string){\n        super(name)\n    }\n    eat() {\n        console.log(this.name+'喜欢吃馒头');\n    }\n    work() {\n        console.log(this.name+'爱工作');\n    }\n}\n\n```\n\n### 9.泛型\n```\nfunction getData<T>(value:T):T {\n    return value;\n}\ngetData<number>(123);\n\nfunction getData<T>(value:T):any {\n    return value;\n}\ngetData<number>(123);\ngetData<string>('123');\n\n泛型类\nclass MinClass<T> {\n    public list:T[]=[];\n    add(value:T):void {\n        this.list.push(value);\n    }\n    min():T{\n        var minNum = this.list[0];\n        for(var i=0;i<this.list.length;i++) {\n            if(minNum>this.list[i]) {\n                minNum = this.list[i];\n            }\n        }\n        return minNum;\n    }\n}\n\nvar m1 = new MinClass<number>();  // 实例化类 并且制定类的T代表类型是number\nm1.add(123);\nvar m2 = new MinClass<string>();  // 实例化类 并且制定类的T代表类型是string\nm2.add('123');\n\n泛型接口\ninterface ConfigFn {\n    <T>(value:T):T;\n}\nvar getData:ConfigFn = function<T>(value: T):T {\n    return value;\n}\ngetData<string>('张三');\ngetData<number>(123);\n\ninterface ConfigFn<T> {\n    <T>(value:T):T;\n}\nfunction getData<T>(value: T):T {\n    return value;\n}\n\nvar myGetData:ConfigFn<string>=getData;\nmyGetData('张三');\nvar myGetDataw:ConfigFn<number>=getData;\nmyGetData(123);\n\n\n把类作为参数来约束数据传入类型\nclass User {\n    userName: string | undefined;\n    password: string | undefined;\n}\nclass MysqlDb {\n    add(User:User):boolean {\n        console.log(User);\n        return true;\n    }\n}\nvar user = new User();\nuser.userName = '张三';\nuser.password = '123456';\nvar db = new MysqlDb();\ndb.add(user);\n \n泛型类\nclass User {\n    userName: string | undefined;\n    password: string | undefined;\n}\nclass MysqlDb {\n    add(User:T):boolean {\n        console.log(User);\n        return true;\n    }\n}\nvar user = new User();\nuser.userName = '张三';\nuser.password = '123456';\nvar db = new MysqlDb<User>();\ndb.add(user);\n\n\n约束规范使用接口，代码重用使用泛型。\n\ninterface DBI<T> {\n    add(info:T):boolean;\n    update(info:T,id:number):boolean;\n    delete(id:number):boolean;\n    get(id:number):any[];\n}\nclass MysqlDb<T> implements DBI<T> {\n    add(info:T):boolean {\n        console.log(info);\n        return true;\n    }\n    update(info:T,id:number):boolean {\n        console.log(info,id);\n        return true;\n    }\n    delete(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n    get(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n}\nclass Mongodb<T> implements DBI<T> {\n    add(info:T):boolean {\n        console.log(info);\n        return true;\n    }\n    update(info:T,id:number):boolean {\n        console.log(info,id);\n        return true;\n    }\n    delete(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n    get(id:number):boolean {\n        console.log(id);\n        return true;\n    }\n}\n\n```\n\n### 10.模块\n- 模块的概念(官方): ”内部模块“=》”命名空间“，”外部模块“=》”模块“ 模块在其自身的作用域里面执行，而不是在全局作用域执行。这就意味着定义一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确的使用export形式之一导出他们。相反，如果想使用其他模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import形式之一。\n- 模块的概念(自己理解): 我们可以把一些公共的功能单独抽离成一个文件作为一个模块。模块里面的变量，函数，类等都是私有的，如果我们要在外部访问模块里面的数据（变量，函数，类），我们需要通过export暴露模块里面的数据（变量、函数、类、、、）暴露后我们通过im\bport引用模块里面的数据（变量，函数，类）。\n\n```\n定义 db.ts\nvar a:string = \"string\";\nfunction getData(value:string):string {\n    return value\n}\nexport {\n    a,\n    getData\n}\n使用\nimport { a,getDate } form './db'\ngetData();\nimport { a,getData as get} form './db'\nget();\n\n定义 db.ts\nexprot default function getData(value:string):string {\n    return value\n}\n使用\nimport getData form './db'\ngetData();\n\n```\n\n### 11.命名空间\n- 命名空间和模块的区别： 命名空间，内部模块，主要用于组织代码，避免命名冲突。  模块，ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。\n\n```\nnamespace A {\n    interface Animal {\n        name:string;\n        eat(str:string):void;\n    }\n    export class Dog implements Animal {\n        name: string;\n        constructor(name:string) {\n            this.name = name;\n        }\n        eat() {\n            return `吃骨头`;\n        }\n    }\n}\nvar dog = A.Dog(\"小黑\");\ndog.eat();\n\n命名空间封装成模块\na.ts文件名\n定义\nexport namespace A {\n    interface Animal {\n        name:string;\n        eat(str:string):void;\n    }\n    export class Dog implements Animal {\n        name: string;\n        constructor(name:string) {\n            this.name = name;\n        }\n        eat() {\n            return `吃骨头`;\n        }\n    }\n}\n使用\nimport { a } from './a'\nvar dog = new a.Dog();\ndog.eat();\n\n```\n\n### 12.装饰器\n- 装饰器： 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。\n- 通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。\n- 常见的装饰器有： 类装饰器、属性装饰器、方法装饰器、参数装饰器。\n- 装饰器写法： 普通装饰器（无法传参）、装饰器工厂（可传参）。\n- 装饰器是过去几年中js最大的成就之一，已经是Es7的标准特性之一。\n\n```\n1.类装饰器(普通装饰器，无法传参)\nfunction logClass(params:any){\n    console.log(params);\n    params.prototype.apiUrl=\"动态扩展的属性\";\n    params.prototype.run = function() {\n        console.log(\"我是run方法\");\n    }\n}\n@logClass\nhttpClient {\n    constructor() {\n\n    }\n    getData() {\n\n    }\n}\nvar H = new httpClient();\nconsole.log(H.apiUrl);\nH.run();\n\n2.类装饰器(装饰器工厂，可传参)\nfunction logClass(params:string){\n    return function(target:any) {\n        target.prototype.apiUrl=\"动态扩展的属性\";\n        target.prototype.run = function() {\n            console.log(\"我是run方法\");\n        }\n    }\n}\n@logClass('hello')\nhttpClient {\n    constructor() {\n\n    }\n    getData() {\n\n    }\n}\n\n把类赋值给target\n把参数赋值给params\n\nvar H:any = new httpClient();\nconsole.log(H.apiUrl);\nH.run();\n\n类装饰器重载以前类的构造函数\nfunction logClass(target: any) {\n    console.log(target);\n    return class extends target{\n        apiUrl:any = \"我是修改后的url\";\n        getData() {\n            console.log(this.apiUrl);\n        }\n    }\n}\n@logClass\nhttpClient {\n\n    public apiUrl: string | undefined;\n    constructor() {\n        this.apiUrl = 'url';\n    }\n    getData() {\n        console.log(this.apiUrl);\n    }\n}\nvar http = new httpClient();\n\n------------------------------\n3.属性装饰器(属性装饰器表达式会在运行时当作函数调用，传入下列两个参数，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象)\nfunction logClass(params:any){\n    console.log(params);\n    params.prototype.apiUrl=\"动态扩展的属性\";\n    params.prototype.run = function() {\n        console.log(\"我是run方法\");\n    }\n}\nfunction logProperty(params:string){\n    return function(target: any,attr:any) {\n        console.log(target);\n        console.log(target[attr]);\n        target[attr] = params;\n    }\n}\n@logClass('xxx')\nhttpClient {\n    @logProperty(\"http://baidu.com\");\n    public url: string | undefined;\n    constructor() {\n        \n    }\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http = new httpClient();\nhttp.getData();\n\n4.方法装饰器\n它会被应用到的方法的属性描述符上，可以用来监视，修改或者替换方法定义\n方法装饰器会在运行是传入下列3个参数\n（1）对于静态成员来说类的构造函数，对于实例成员来说是类的原型对象。\n（2）成员的名字。\n（3）成员的属性描述符。\n\nfunction logMethod(params: any) {\n    return function(target:any,methodName:any,desc:any) {\n        console.log(target);\n        console.log(methodName);\n        console.log(desc);\n        target.apiUrl=\"动态扩展的属性\";\n        target.run = function() {\n            console.log(\"我是run方法\");\n        }\n    }\n}\n\nhttpClient {\n    constructor() {\n        \n    }\n    @logMethod(\"http://baidu.com\")\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http:any = new httpClient();\nhttp.run();\n\n------------------------------------------\n\nfunction logMethod(params: any) {\n    return function(target:any,methodName:any,desc:any) {\n        console.log(target);\n        console.log(methodName);\n        console.log(desc);\n        //修改装饰器的方法 把装饰器方法传入所以参数改为string类型\n        //保存当前的方法\n        var oMethod = desc.value;\n        desc.value = function(...args:any[]) {\n            args = args.map((value)=>{\n                return String(value)\n            });\n            console.log(args);\n        }\n    }\n}\n\nhttpClient {\n    public url:any | undefined;\n    constructor() {\n        \n    }\n    @logMethod(\"http://baidu.com\")\n    getData() {\n        console.log(this.url);\n    }\n}\nvar http:any = new httpClient();\nhttp.getData(123,'xxx');\n\n```","slug":"TypeScript/TypeScript","published":1,"date":"2019-04-29T07:22:37.000Z","updated":"2019-06-12T06:09:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxe9u0jt003m7xuqd1rc2w5s","content":"<h2 id=\"一、准备\"><a href=\"#一、准备\" class=\"headerlink\" title=\"一、准备\"></a>一、准备</h2><hr>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p><code>npm install -g typescript</code></p>\n<h3 id=\"2-vscode自动编译\"><a href=\"#2-vscode自动编译\" class=\"headerlink\" title=\"2. vscode自动编译\"></a>2. vscode自动编译</h3><ul>\n<li>项目目录终端执行 <code>tsc --init</code></li>\n<li>更改tsconfig.json “outDir”: “./js”</li>\n</ul>\n<h2 id=\"二、基础语法\"><a href=\"#二、基础语法\" class=\"headerlink\" title=\"二、基础语法\"></a>二、基础语法</h2><hr>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1.数据类型\"></a>1.数据类型</h3><ul>\n<li>布尔值</li>\n<li>数字</li>\n<li>字符串</li>\n<li>数组</li>\n<li>元组 Tuple</li>\n<li>枚举</li>\n<li>Any</li>\n<li>Void （函数没有返回值使用。）</li>\n<li>Null 和 Undefined （默认情况下null和undefined是所有类型的子类型。）</li>\n<li>Never （never类型是任何类型的子类型）</li>\n<li>Object</li>\n</ul>\n<h3 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2.函数\"></a>2.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">声明函数</span><br><span class=\"line\">function run():string &#123;</span><br><span class=\"line\">    return &apos;typescript&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">匿名函数</span><br><span class=\"line\">var fun = function():string &#123;</span><br><span class=\"line\">    return &apos;typescript&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">定义方法传参</span><br><span class=\"line\">function user(name:string,age:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = function(name:string,age:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没有返回值</span><br><span class=\"line\">function run():void &#123;</span><br><span class=\"line\">    console.log(&apos;typescript&apos;  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法可选参数</span><br><span class=\"line\">function user(name: string,age?:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法参数默认值</span><br><span class=\"line\">function user(name: string,age:number=20):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法剩余参数</span><br><span class=\"line\">function user(...result:number[]):string &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function user(name: string,...result:number[]):string &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">重载</span><br><span class=\"line\">function user(name: string):string;</span><br><span class=\"line\">function user(age: number):number;</span><br><span class=\"line\">function user(str:any):any &#123;</span><br><span class=\"line\">    if(typeof str===&apos;string) &#123;</span><br><span class=\"line\">        return str</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return str</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"3.类\"></a>3.类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本模型</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():void &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName():void &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1 = new Person(&apos;张三&apos;);</span><br><span class=\"line\">alert(person1.getName());</span><br><span class=\"line\">person1.setName(&apos;李四&apos;)；</span><br><span class=\"line\">alert(person1.getName());</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-继承\"><a href=\"#4-继承\" class=\"headerlink\" title=\"4.继承\"></a>4.继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">子类可以使用父类的属性和方法  如果子类的方法或者属性和父类相同  则以子类为主</span><br><span class=\"line\">class Web extends Person &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name); //初始化父类的构造函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;在运动`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;` </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var w = new Web(&apos;李四&apos;);</span><br><span class=\"line\">alert(w.run());</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-类里面的修饰符\"><a href=\"#5-类里面的修饰符\" class=\"headerlink\" title=\"5.类里面的修饰符\"></a>5.类里面的修饰符</h3><ul>\n<li>public</li>\n</ul>\n<blockquote>\n<p>共有类型 在类里面、子类、类外面都可以访问(默认，不写默认就是)。</p>\n</blockquote>\n<ul>\n<li>protected </li>\n</ul>\n<blockquote>\n<p>保护类型 在类里面、子类可以访问，类外面都不可以访问。</p>\n</blockquote>\n<ul>\n<li>private</li>\n</ul>\n<blockquote>\n<p>私有类型 在类里面可以访问，子类和类外面都不可以访问。</p>\n</blockquote>\n<h3 id=\"6-类的静态属性和静态方法\"><a href=\"#6-类的静态属性和静态方法\" class=\"headerlink\" title=\"6.类的静态属性和静态方法\"></a>6.类的静态属性和静态方法</h3><ul>\n<li>static （静态方法里面不能直接调用类里面的属性，能调用静态属性）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    public name:string;</span><br><span class=\"line\">    static age:number=20;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">        alert(`$&#123;this.name&#125;在运动`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static print() &#123;</span><br><span class=\"line\">        alert(`print`+Person.age); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-多态\"><a href=\"#7-多态\" class=\"headerlink\" title=\"7.多态\"></a>7.多态</h3><ul>\n<li>父类定义一个方法不去实现，让继承它的子类去实现，让每一个子类有不同的表现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(&apos;吃的方法&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog extends Animal &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return this.name + &apos;骨头&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Cat extends Animal &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return this.name + &apos;鱼&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-抽象类\"><a href=\"#8-抽象类\" class=\"headerlink\" title=\"8.抽象类\"></a>8.抽象类</h3><ul>\n<li>提供标准 </li>\n<li>abstract 抽象类不能实例化 为子类提供基类</li>\n<li>子类必须实现父类的抽象方法</li>\n<li>abstract必须放在抽象类里面</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    abstract eat():any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog extends Animal &#123;</span><br><span class=\"line\">    constructor(name:any) &#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-接口\"><a href=\"#8-接口\" class=\"headerlink\" title=\"8.接口\"></a>8.接口</h3><ul>\n<li>定义规范 定义行为和动作的规范 （接口不关心类内部的数据状态和方法实现的细节）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface FullName &#123;</span><br><span class=\"line\">    firstName: string;</span><br><span class=\"line\">    secondName: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function printName(name: FullName) &#123;</span><br><span class=\"line\">    console.log(name.firstName+ &apos;--&apos; +name.secondName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;,</span><br><span class=\"line\">    secondName: &apos;yu&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口的可选属性</span><br><span class=\"line\">interface FullName &#123;</span><br><span class=\"line\">    firstName: string;</span><br><span class=\"line\">    secondName?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function printName(name: FullName) &#123;</span><br><span class=\"line\">    console.log(name.firstName+ &apos;--&apos; +name.secondName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;,</span><br><span class=\"line\">    secondName: &apos;yu&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\"></span><br><span class=\"line\">函数类型的接口</span><br><span class=\"line\">interface encrypt &#123;</span><br><span class=\"line\">    (key:string,value:string):string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var md5:encrypt = function(key:string,value:string):string &#123;</span><br><span class=\"line\">    return key+value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">md5(&apos;key&apos;,&apos;value&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">可索引接口 数组和对象的约束(不常用)</span><br><span class=\"line\">interface userArr &#123;</span><br><span class=\"line\">    [index:number]:string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr:userArr = [&apos;string&apos;,&apos;string&apos;]; //ok</span><br><span class=\"line\"></span><br><span class=\"line\">interface userObj &#123;</span><br><span class=\"line\">    [index:string]:string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr:userObj = [&apos;string&apos;,&apos;string&apos;]; //ok</span><br><span class=\"line\"></span><br><span class=\"line\">类类型接口 对类的约束</span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    eat(str:string):void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog implements Animal &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return `吃骨头`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var dog = new Dog(&apos;小黑&apos;);</span><br><span class=\"line\">dog.eat();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口扩展  接口扩展接口</span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    eat():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Person extends Animal &#123;</span><br><span class=\"line\">    work():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Web implements Person &#123;</span><br><span class=\"line\">    public name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name= name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;喜欢吃馒头&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;爱工作&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    eat():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Person extends Animal &#123;</span><br><span class=\"line\">    work():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class programmer &#123;</span><br><span class=\"line\">    public: name:string;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    coding(code:string)&#123;</span><br><span class=\"line\">        console.log(this.name+code);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Web extends programmer implements Person &#123;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;喜欢吃馒头&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;爱工作&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-泛型\"><a href=\"#9-泛型\" class=\"headerlink\" title=\"9.泛型\"></a>9.泛型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getData&lt;T&gt;(value:T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\"></span><br><span class=\"line\">function getData&lt;T&gt;(value:T):any &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\">getData&lt;string&gt;(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">泛型类</span><br><span class=\"line\">class MinClass&lt;T&gt; &#123;</span><br><span class=\"line\">    public list:T[]=[];</span><br><span class=\"line\">    add(value:T):void &#123;</span><br><span class=\"line\">        this.list.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    min():T&#123;</span><br><span class=\"line\">        var minNum = this.list[0];</span><br><span class=\"line\">        for(var i=0;i&lt;this.list.length;i++) &#123;</span><br><span class=\"line\">            if(minNum&gt;this.list[i]) &#123;</span><br><span class=\"line\">                minNum = this.list[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return minNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var m1 = new MinClass&lt;number&gt;();  // 实例化类 并且制定类的T代表类型是number</span><br><span class=\"line\">m1.add(123);</span><br><span class=\"line\">var m2 = new MinClass&lt;string&gt;();  // 实例化类 并且制定类的T代表类型是string</span><br><span class=\"line\">m2.add(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">泛型接口</span><br><span class=\"line\">interface ConfigFn &#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var getData:ConfigFn = function&lt;T&gt;(value: T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;string&gt;(&apos;张三&apos;);</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\"></span><br><span class=\"line\">interface ConfigFn&lt;T&gt; &#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getData&lt;T&gt;(value: T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myGetData:ConfigFn&lt;string&gt;=getData;</span><br><span class=\"line\">myGetData(&apos;张三&apos;);</span><br><span class=\"line\">var myGetDataw:ConfigFn&lt;number&gt;=getData;</span><br><span class=\"line\">myGetData(123);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">把类作为参数来约束数据传入类型</span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    userName: string | undefined;</span><br><span class=\"line\">    password: string | undefined;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb &#123;</span><br><span class=\"line\">    add(User:User):boolean &#123;</span><br><span class=\"line\">        console.log(User);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = new User();</span><br><span class=\"line\">user.userName = &apos;张三&apos;;</span><br><span class=\"line\">user.password = &apos;123456&apos;;</span><br><span class=\"line\">var db = new MysqlDb();</span><br><span class=\"line\">db.add(user);</span><br><span class=\"line\"> </span><br><span class=\"line\">泛型类</span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    userName: string | undefined;</span><br><span class=\"line\">    password: string | undefined;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb &#123;</span><br><span class=\"line\">    add(User:T):boolean &#123;</span><br><span class=\"line\">        console.log(User);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = new User();</span><br><span class=\"line\">user.userName = &apos;张三&apos;;</span><br><span class=\"line\">user.password = &apos;123456&apos;;</span><br><span class=\"line\">var db = new MysqlDb&lt;User&gt;();</span><br><span class=\"line\">db.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">约束规范使用接口，代码重用使用泛型。</span><br><span class=\"line\"></span><br><span class=\"line\">interface DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean;</span><br><span class=\"line\">    update(info:T,id:number):boolean;</span><br><span class=\"line\">    delete(id:number):boolean;</span><br><span class=\"line\">    get(id:number):any[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb&lt;T&gt; implements DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean &#123;</span><br><span class=\"line\">        console.log(info);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(info:T,id:number):boolean &#123;</span><br><span class=\"line\">        console.log(info,id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Mongodb&lt;T&gt; implements DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean &#123;</span><br><span class=\"line\">        console.log(info);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(info:T,id:number):boolean &#123;</span><br><span class=\"line\">        console.log(info,id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-模块\"><a href=\"#10-模块\" class=\"headerlink\" title=\"10.模块\"></a>10.模块</h3><ul>\n<li>模块的概念(官方): ”内部模块“=》”命名空间“，”外部模块“=》”模块“ 模块在其自身的作用域里面执行，而不是在全局作用域执行。这就意味着定义一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确的使用export形式之一导出他们。相反，如果想使用其他模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import形式之一。</li>\n<li>模块的概念(自己理解): 我们可以把一些公共的功能单独抽离成一个文件作为一个模块。模块里面的变量，函数，类等都是私有的，如果我们要在外部访问模块里面的数据（变量，函数，类），我们需要通过export暴露模块里面的数据（变量、函数、类、、、）暴露后我们通过im\bport引用模块里面的数据（变量，函数，类）。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义 db.ts</span><br><span class=\"line\">var a:string = &quot;string&quot;;</span><br><span class=\"line\">function getData(value:string):string &#123;</span><br><span class=\"line\">    return value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">    a,</span><br><span class=\"line\">    getData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import &#123; a,getDate &#125; form &apos;./db&apos;</span><br><span class=\"line\">getData();</span><br><span class=\"line\">import &#123; a,getData as get&#125; form &apos;./db&apos;</span><br><span class=\"line\">get();</span><br><span class=\"line\"></span><br><span class=\"line\">定义 db.ts</span><br><span class=\"line\">exprot default function getData(value:string):string &#123;</span><br><span class=\"line\">    return value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import getData form &apos;./db&apos;</span><br><span class=\"line\">getData();</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-命名空间\"><a href=\"#11-命名空间\" class=\"headerlink\" title=\"11.命名空间\"></a>11.命名空间</h3><ul>\n<li>命名空间和模块的区别： 命名空间，内部模块，主要用于组织代码，避免命名冲突。  模块，ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace A &#123;</span><br><span class=\"line\">    interface Animal &#123;</span><br><span class=\"line\">        name:string;</span><br><span class=\"line\">        eat(str:string):void;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    export class Dog implements Animal &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        constructor(name:string) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        eat() &#123;</span><br><span class=\"line\">            return `吃骨头`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var dog = A.Dog(&quot;小黑&quot;);</span><br><span class=\"line\">dog.eat();</span><br><span class=\"line\"></span><br><span class=\"line\">命名空间封装成模块</span><br><span class=\"line\">a.ts文件名</span><br><span class=\"line\">定义</span><br><span class=\"line\">export namespace A &#123;</span><br><span class=\"line\">    interface Animal &#123;</span><br><span class=\"line\">        name:string;</span><br><span class=\"line\">        eat(str:string):void;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    export class Dog implements Animal &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        constructor(name:string) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        eat() &#123;</span><br><span class=\"line\">            return `吃骨头`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import &#123; a &#125; from &apos;./a&apos;</span><br><span class=\"line\">var dog = new a.Dog();</span><br><span class=\"line\">dog.eat();</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-装饰器\"><a href=\"#12-装饰器\" class=\"headerlink\" title=\"12.装饰器\"></a>12.装饰器</h3><ul>\n<li>装饰器： 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。</li>\n<li>通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。</li>\n<li>常见的装饰器有： 类装饰器、属性装饰器、方法装饰器、参数装饰器。</li>\n<li>装饰器写法： 普通装饰器（无法传参）、装饰器工厂（可传参）。</li>\n<li>装饰器是过去几年中js最大的成就之一，已经是Es7的标准特性之一。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.类装饰器(普通装饰器，无法传参)</span><br><span class=\"line\">function logClass(params:any)&#123;</span><br><span class=\"line\">    console.log(params);</span><br><span class=\"line\">    params.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">    params.prototype.run = function() &#123;</span><br><span class=\"line\">        console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var H = new httpClient();</span><br><span class=\"line\">console.log(H.apiUrl);</span><br><span class=\"line\">H.run();</span><br><span class=\"line\"></span><br><span class=\"line\">2.类装饰器(装饰器工厂，可传参)</span><br><span class=\"line\">function logClass(params:string)&#123;</span><br><span class=\"line\">    return function(target:any) &#123;</span><br><span class=\"line\">        target.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">        target.prototype.run = function() &#123;</span><br><span class=\"line\">            console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass(&apos;hello&apos;)</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">把类赋值给target</span><br><span class=\"line\">把参数赋值给params</span><br><span class=\"line\"></span><br><span class=\"line\">var H:any = new httpClient();</span><br><span class=\"line\">console.log(H.apiUrl);</span><br><span class=\"line\">H.run();</span><br><span class=\"line\"></span><br><span class=\"line\">类装饰器重载以前类的构造函数</span><br><span class=\"line\">function logClass(target: any) &#123;</span><br><span class=\"line\">    console.log(target);</span><br><span class=\"line\">    return class extends target&#123;</span><br><span class=\"line\">        apiUrl:any = &quot;我是修改后的url&quot;;</span><br><span class=\"line\">        getData() &#123;</span><br><span class=\"line\">            console.log(this.apiUrl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public apiUrl: string | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        this.apiUrl = &apos;url&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.apiUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http = new httpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\">3.属性装饰器(属性装饰器表达式会在运行时当作函数调用，传入下列两个参数，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象)</span><br><span class=\"line\">function logClass(params:any)&#123;</span><br><span class=\"line\">    console.log(params);</span><br><span class=\"line\">    params.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">    params.prototype.run = function() &#123;</span><br><span class=\"line\">        console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function logProperty(params:string)&#123;</span><br><span class=\"line\">    return function(target: any,attr:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(target[attr]);</span><br><span class=\"line\">        target[attr] = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass(&apos;xxx&apos;)</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    @logProperty(&quot;http://baidu.com&quot;);</span><br><span class=\"line\">    public url: string | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http = new httpClient();</span><br><span class=\"line\">http.getData();</span><br><span class=\"line\"></span><br><span class=\"line\">4.方法装饰器</span><br><span class=\"line\">它会被应用到的方法的属性描述符上，可以用来监视，修改或者替换方法定义</span><br><span class=\"line\">方法装饰器会在运行是传入下列3个参数</span><br><span class=\"line\">（1）对于静态成员来说类的构造函数，对于实例成员来说是类的原型对象。</span><br><span class=\"line\">（2）成员的名字。</span><br><span class=\"line\">（3）成员的属性描述符。</span><br><span class=\"line\"></span><br><span class=\"line\">function logMethod(params: any) &#123;</span><br><span class=\"line\">    return function(target:any,methodName:any,desc:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(methodName);</span><br><span class=\"line\">        console.log(desc);</span><br><span class=\"line\">        target.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">        target.run = function() &#123;</span><br><span class=\"line\">            console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @logMethod(&quot;http://baidu.com&quot;)</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http:any = new httpClient();</span><br><span class=\"line\">http.run();</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">function logMethod(params: any) &#123;</span><br><span class=\"line\">    return function(target:any,methodName:any,desc:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(methodName);</span><br><span class=\"line\">        console.log(desc);</span><br><span class=\"line\">        //修改装饰器的方法 把装饰器方法传入所以参数改为string类型</span><br><span class=\"line\">        //保存当前的方法</span><br><span class=\"line\">        var oMethod = desc.value;</span><br><span class=\"line\">        desc.value = function(...args:any[]) &#123;</span><br><span class=\"line\">            args = args.map((value)=&gt;&#123;</span><br><span class=\"line\">                return String(value)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    public url:any | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @logMethod(&quot;http://baidu.com&quot;)</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http:any = new httpClient();</span><br><span class=\"line\">http.getData(123,&apos;xxx&apos;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、准备\"><a href=\"#一、准备\" class=\"headerlink\" title=\"一、准备\"></a>一、准备</h2><hr>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p><code>npm install -g typescript</code></p>\n<h3 id=\"2-vscode自动编译\"><a href=\"#2-vscode自动编译\" class=\"headerlink\" title=\"2. vscode自动编译\"></a>2. vscode自动编译</h3><ul>\n<li>项目目录终端执行 <code>tsc --init</code></li>\n<li>更改tsconfig.json “outDir”: “./js”</li>\n</ul>\n<h2 id=\"二、基础语法\"><a href=\"#二、基础语法\" class=\"headerlink\" title=\"二、基础语法\"></a>二、基础语法</h2><hr>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1.数据类型\"></a>1.数据类型</h3><ul>\n<li>布尔值</li>\n<li>数字</li>\n<li>字符串</li>\n<li>数组</li>\n<li>元组 Tuple</li>\n<li>枚举</li>\n<li>Any</li>\n<li>Void （函数没有返回值使用。）</li>\n<li>Null 和 Undefined （默认情况下null和undefined是所有类型的子类型。）</li>\n<li>Never （never类型是任何类型的子类型）</li>\n<li>Object</li>\n</ul>\n<h3 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2.函数\"></a>2.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">声明函数</span><br><span class=\"line\">function run():string &#123;</span><br><span class=\"line\">    return &apos;typescript&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">匿名函数</span><br><span class=\"line\">var fun = function():string &#123;</span><br><span class=\"line\">    return &apos;typescript&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">定义方法传参</span><br><span class=\"line\">function user(name:string,age:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = function(name:string,age:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没有返回值</span><br><span class=\"line\">function run():void &#123;</span><br><span class=\"line\">    console.log(&apos;typescript&apos;  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法可选参数</span><br><span class=\"line\">function user(name: string,age?:number):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法参数默认值</span><br><span class=\"line\">function user(name: string,age:number=20):string &#123;</span><br><span class=\"line\">    return `$&#123;name&#125;----$&#123;age&#125;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法剩余参数</span><br><span class=\"line\">function user(...result:number[]):string &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function user(name: string,...result:number[]):string &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">重载</span><br><span class=\"line\">function user(name: string):string;</span><br><span class=\"line\">function user(age: number):number;</span><br><span class=\"line\">function user(str:any):any &#123;</span><br><span class=\"line\">    if(typeof str===&apos;string) &#123;</span><br><span class=\"line\">        return str</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return str</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"3.类\"></a>3.类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本模型</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():void &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName():void &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person1 = new Person(&apos;张三&apos;);</span><br><span class=\"line\">alert(person1.getName());</span><br><span class=\"line\">person1.setName(&apos;李四&apos;)；</span><br><span class=\"line\">alert(person1.getName());</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-继承\"><a href=\"#4-继承\" class=\"headerlink\" title=\"4.继承\"></a>4.继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    name: string; //属性 省略publick 关键词</span><br><span class=\"line\">    constructor(name:string) &#123;  //构造函数 实例化的时候调用的方法(初始化对象)</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">子类可以使用父类的属性和方法  如果子类的方法或者属性和父类相同  则以子类为主</span><br><span class=\"line\">class Web extends Person &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name); //初始化父类的构造函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;在运动`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run():string &#123;</span><br><span class=\"line\">        return `$&#123;this.name&#125;` </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var w = new Web(&apos;李四&apos;);</span><br><span class=\"line\">alert(w.run());</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-类里面的修饰符\"><a href=\"#5-类里面的修饰符\" class=\"headerlink\" title=\"5.类里面的修饰符\"></a>5.类里面的修饰符</h3><ul>\n<li>public</li>\n</ul>\n<blockquote>\n<p>共有类型 在类里面、子类、类外面都可以访问(默认，不写默认就是)。</p>\n</blockquote>\n<ul>\n<li>protected </li>\n</ul>\n<blockquote>\n<p>保护类型 在类里面、子类可以访问，类外面都不可以访问。</p>\n</blockquote>\n<ul>\n<li>private</li>\n</ul>\n<blockquote>\n<p>私有类型 在类里面可以访问，子类和类外面都不可以访问。</p>\n</blockquote>\n<h3 id=\"6-类的静态属性和静态方法\"><a href=\"#6-类的静态属性和静态方法\" class=\"headerlink\" title=\"6.类的静态属性和静态方法\"></a>6.类的静态属性和静态方法</h3><ul>\n<li>static （静态方法里面不能直接调用类里面的属性，能调用静态属性）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    public name:string;</span><br><span class=\"line\">    static age:number=20;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">        alert(`$&#123;this.name&#125;在运动`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static print() &#123;</span><br><span class=\"line\">        alert(`print`+Person.age); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-多态\"><a href=\"#7-多态\" class=\"headerlink\" title=\"7.多态\"></a>7.多态</h3><ul>\n<li>父类定义一个方法不去实现，让继承它的子类去实现，让每一个子类有不同的表现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(&apos;吃的方法&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog extends Animal &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return this.name + &apos;骨头&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Cat extends Animal &#123;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return this.name + &apos;鱼&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-抽象类\"><a href=\"#8-抽象类\" class=\"headerlink\" title=\"8.抽象类\"></a>8.抽象类</h3><ul>\n<li>提供标准 </li>\n<li>abstract 抽象类不能实例化 为子类提供基类</li>\n<li>子类必须实现父类的抽象方法</li>\n<li>abstract必须放在抽象类里面</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    abstract eat():any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog extends Animal &#123;</span><br><span class=\"line\">    constructor(name:any) &#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-接口\"><a href=\"#8-接口\" class=\"headerlink\" title=\"8.接口\"></a>8.接口</h3><ul>\n<li>定义规范 定义行为和动作的规范 （接口不关心类内部的数据状态和方法实现的细节）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface FullName &#123;</span><br><span class=\"line\">    firstName: string;</span><br><span class=\"line\">    secondName: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function printName(name: FullName) &#123;</span><br><span class=\"line\">    console.log(name.firstName+ &apos;--&apos; +name.secondName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;,</span><br><span class=\"line\">    secondName: &apos;yu&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口的可选属性</span><br><span class=\"line\">interface FullName &#123;</span><br><span class=\"line\">    firstName: string;</span><br><span class=\"line\">    secondName?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function printName(name: FullName) &#123;</span><br><span class=\"line\">    console.log(name.firstName+ &apos;--&apos; +name.secondName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;,</span><br><span class=\"line\">    secondName: &apos;yu&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    firstName: &apos;sun&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(obj) // ok</span><br><span class=\"line\"></span><br><span class=\"line\">函数类型的接口</span><br><span class=\"line\">interface encrypt &#123;</span><br><span class=\"line\">    (key:string,value:string):string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var md5:encrypt = function(key:string,value:string):string &#123;</span><br><span class=\"line\">    return key+value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">md5(&apos;key&apos;,&apos;value&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">可索引接口 数组和对象的约束(不常用)</span><br><span class=\"line\">interface userArr &#123;</span><br><span class=\"line\">    [index:number]:string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr:userArr = [&apos;string&apos;,&apos;string&apos;]; //ok</span><br><span class=\"line\"></span><br><span class=\"line\">interface userObj &#123;</span><br><span class=\"line\">    [index:string]:string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr:userObj = [&apos;string&apos;,&apos;string&apos;]; //ok</span><br><span class=\"line\"></span><br><span class=\"line\">类类型接口 对类的约束</span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    eat(str:string):void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Dog implements Animal &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        return `吃骨头`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var dog = new Dog(&apos;小黑&apos;);</span><br><span class=\"line\">dog.eat();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口扩展  接口扩展接口</span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    eat():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Person extends Animal &#123;</span><br><span class=\"line\">    work():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Web implements Person &#123;</span><br><span class=\"line\">    public name:string;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        this.name= name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;喜欢吃馒头&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;爱工作&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">interface Animal &#123;</span><br><span class=\"line\">    eat():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Person extends Animal &#123;</span><br><span class=\"line\">    work():void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class programmer &#123;</span><br><span class=\"line\">    public: name:string;</span><br><span class=\"line\">    constructor(name:string) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    coding(code:string)&#123;</span><br><span class=\"line\">        console.log(this.name+code);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Web extends programmer implements Person &#123;</span><br><span class=\"line\">    constructor(name:string)&#123;</span><br><span class=\"line\">        super(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;喜欢吃馒头&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    work() &#123;</span><br><span class=\"line\">        console.log(this.name+&apos;爱工作&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-泛型\"><a href=\"#9-泛型\" class=\"headerlink\" title=\"9.泛型\"></a>9.泛型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getData&lt;T&gt;(value:T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\"></span><br><span class=\"line\">function getData&lt;T&gt;(value:T):any &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\">getData&lt;string&gt;(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">泛型类</span><br><span class=\"line\">class MinClass&lt;T&gt; &#123;</span><br><span class=\"line\">    public list:T[]=[];</span><br><span class=\"line\">    add(value:T):void &#123;</span><br><span class=\"line\">        this.list.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    min():T&#123;</span><br><span class=\"line\">        var minNum = this.list[0];</span><br><span class=\"line\">        for(var i=0;i&lt;this.list.length;i++) &#123;</span><br><span class=\"line\">            if(minNum&gt;this.list[i]) &#123;</span><br><span class=\"line\">                minNum = this.list[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return minNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var m1 = new MinClass&lt;number&gt;();  // 实例化类 并且制定类的T代表类型是number</span><br><span class=\"line\">m1.add(123);</span><br><span class=\"line\">var m2 = new MinClass&lt;string&gt;();  // 实例化类 并且制定类的T代表类型是string</span><br><span class=\"line\">m2.add(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">泛型接口</span><br><span class=\"line\">interface ConfigFn &#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var getData:ConfigFn = function&lt;T&gt;(value: T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;string&gt;(&apos;张三&apos;);</span><br><span class=\"line\">getData&lt;number&gt;(123);</span><br><span class=\"line\"></span><br><span class=\"line\">interface ConfigFn&lt;T&gt; &#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function getData&lt;T&gt;(value: T):T &#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myGetData:ConfigFn&lt;string&gt;=getData;</span><br><span class=\"line\">myGetData(&apos;张三&apos;);</span><br><span class=\"line\">var myGetDataw:ConfigFn&lt;number&gt;=getData;</span><br><span class=\"line\">myGetData(123);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">把类作为参数来约束数据传入类型</span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    userName: string | undefined;</span><br><span class=\"line\">    password: string | undefined;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb &#123;</span><br><span class=\"line\">    add(User:User):boolean &#123;</span><br><span class=\"line\">        console.log(User);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = new User();</span><br><span class=\"line\">user.userName = &apos;张三&apos;;</span><br><span class=\"line\">user.password = &apos;123456&apos;;</span><br><span class=\"line\">var db = new MysqlDb();</span><br><span class=\"line\">db.add(user);</span><br><span class=\"line\"> </span><br><span class=\"line\">泛型类</span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    userName: string | undefined;</span><br><span class=\"line\">    password: string | undefined;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb &#123;</span><br><span class=\"line\">    add(User:T):boolean &#123;</span><br><span class=\"line\">        console.log(User);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = new User();</span><br><span class=\"line\">user.userName = &apos;张三&apos;;</span><br><span class=\"line\">user.password = &apos;123456&apos;;</span><br><span class=\"line\">var db = new MysqlDb&lt;User&gt;();</span><br><span class=\"line\">db.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">约束规范使用接口，代码重用使用泛型。</span><br><span class=\"line\"></span><br><span class=\"line\">interface DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean;</span><br><span class=\"line\">    update(info:T,id:number):boolean;</span><br><span class=\"line\">    delete(id:number):boolean;</span><br><span class=\"line\">    get(id:number):any[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MysqlDb&lt;T&gt; implements DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean &#123;</span><br><span class=\"line\">        console.log(info);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(info:T,id:number):boolean &#123;</span><br><span class=\"line\">        console.log(info,id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Mongodb&lt;T&gt; implements DBI&lt;T&gt; &#123;</span><br><span class=\"line\">    add(info:T):boolean &#123;</span><br><span class=\"line\">        console.log(info);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(info:T,id:number):boolean &#123;</span><br><span class=\"line\">        console.log(info,id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get(id:number):boolean &#123;</span><br><span class=\"line\">        console.log(id);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-模块\"><a href=\"#10-模块\" class=\"headerlink\" title=\"10.模块\"></a>10.模块</h3><ul>\n<li>模块的概念(官方): ”内部模块“=》”命名空间“，”外部模块“=》”模块“ 模块在其自身的作用域里面执行，而不是在全局作用域执行。这就意味着定义一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确的使用export形式之一导出他们。相反，如果想使用其他模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import形式之一。</li>\n<li>模块的概念(自己理解): 我们可以把一些公共的功能单独抽离成一个文件作为一个模块。模块里面的变量，函数，类等都是私有的，如果我们要在外部访问模块里面的数据（变量，函数，类），我们需要通过export暴露模块里面的数据（变量、函数、类、、、）暴露后我们通过im\bport引用模块里面的数据（变量，函数，类）。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义 db.ts</span><br><span class=\"line\">var a:string = &quot;string&quot;;</span><br><span class=\"line\">function getData(value:string):string &#123;</span><br><span class=\"line\">    return value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">    a,</span><br><span class=\"line\">    getData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import &#123; a,getDate &#125; form &apos;./db&apos;</span><br><span class=\"line\">getData();</span><br><span class=\"line\">import &#123; a,getData as get&#125; form &apos;./db&apos;</span><br><span class=\"line\">get();</span><br><span class=\"line\"></span><br><span class=\"line\">定义 db.ts</span><br><span class=\"line\">exprot default function getData(value:string):string &#123;</span><br><span class=\"line\">    return value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import getData form &apos;./db&apos;</span><br><span class=\"line\">getData();</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-命名空间\"><a href=\"#11-命名空间\" class=\"headerlink\" title=\"11.命名空间\"></a>11.命名空间</h3><ul>\n<li>命名空间和模块的区别： 命名空间，内部模块，主要用于组织代码，避免命名冲突。  模块，ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace A &#123;</span><br><span class=\"line\">    interface Animal &#123;</span><br><span class=\"line\">        name:string;</span><br><span class=\"line\">        eat(str:string):void;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    export class Dog implements Animal &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        constructor(name:string) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        eat() &#123;</span><br><span class=\"line\">            return `吃骨头`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var dog = A.Dog(&quot;小黑&quot;);</span><br><span class=\"line\">dog.eat();</span><br><span class=\"line\"></span><br><span class=\"line\">命名空间封装成模块</span><br><span class=\"line\">a.ts文件名</span><br><span class=\"line\">定义</span><br><span class=\"line\">export namespace A &#123;</span><br><span class=\"line\">    interface Animal &#123;</span><br><span class=\"line\">        name:string;</span><br><span class=\"line\">        eat(str:string):void;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    export class Dog implements Animal &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        constructor(name:string) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        eat() &#123;</span><br><span class=\"line\">            return `吃骨头`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">使用</span><br><span class=\"line\">import &#123; a &#125; from &apos;./a&apos;</span><br><span class=\"line\">var dog = new a.Dog();</span><br><span class=\"line\">dog.eat();</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-装饰器\"><a href=\"#12-装饰器\" class=\"headerlink\" title=\"12.装饰器\"></a>12.装饰器</h3><ul>\n<li>装饰器： 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。</li>\n<li>通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。</li>\n<li>常见的装饰器有： 类装饰器、属性装饰器、方法装饰器、参数装饰器。</li>\n<li>装饰器写法： 普通装饰器（无法传参）、装饰器工厂（可传参）。</li>\n<li>装饰器是过去几年中js最大的成就之一，已经是Es7的标准特性之一。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.类装饰器(普通装饰器，无法传参)</span><br><span class=\"line\">function logClass(params:any)&#123;</span><br><span class=\"line\">    console.log(params);</span><br><span class=\"line\">    params.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">    params.prototype.run = function() &#123;</span><br><span class=\"line\">        console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var H = new httpClient();</span><br><span class=\"line\">console.log(H.apiUrl);</span><br><span class=\"line\">H.run();</span><br><span class=\"line\"></span><br><span class=\"line\">2.类装饰器(装饰器工厂，可传参)</span><br><span class=\"line\">function logClass(params:string)&#123;</span><br><span class=\"line\">    return function(target:any) &#123;</span><br><span class=\"line\">        target.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">        target.prototype.run = function() &#123;</span><br><span class=\"line\">            console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass(&apos;hello&apos;)</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">把类赋值给target</span><br><span class=\"line\">把参数赋值给params</span><br><span class=\"line\"></span><br><span class=\"line\">var H:any = new httpClient();</span><br><span class=\"line\">console.log(H.apiUrl);</span><br><span class=\"line\">H.run();</span><br><span class=\"line\"></span><br><span class=\"line\">类装饰器重载以前类的构造函数</span><br><span class=\"line\">function logClass(target: any) &#123;</span><br><span class=\"line\">    console.log(target);</span><br><span class=\"line\">    return class extends target&#123;</span><br><span class=\"line\">        apiUrl:any = &quot;我是修改后的url&quot;;</span><br><span class=\"line\">        getData() &#123;</span><br><span class=\"line\">            console.log(this.apiUrl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public apiUrl: string | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        this.apiUrl = &apos;url&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.apiUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http = new httpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\">3.属性装饰器(属性装饰器表达式会在运行时当作函数调用，传入下列两个参数，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象)</span><br><span class=\"line\">function logClass(params:any)&#123;</span><br><span class=\"line\">    console.log(params);</span><br><span class=\"line\">    params.prototype.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">    params.prototype.run = function() &#123;</span><br><span class=\"line\">        console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function logProperty(params:string)&#123;</span><br><span class=\"line\">    return function(target: any,attr:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(target[attr]);</span><br><span class=\"line\">        target[attr] = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@logClass(&apos;xxx&apos;)</span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    @logProperty(&quot;http://baidu.com&quot;);</span><br><span class=\"line\">    public url: string | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http = new httpClient();</span><br><span class=\"line\">http.getData();</span><br><span class=\"line\"></span><br><span class=\"line\">4.方法装饰器</span><br><span class=\"line\">它会被应用到的方法的属性描述符上，可以用来监视，修改或者替换方法定义</span><br><span class=\"line\">方法装饰器会在运行是传入下列3个参数</span><br><span class=\"line\">（1）对于静态成员来说类的构造函数，对于实例成员来说是类的原型对象。</span><br><span class=\"line\">（2）成员的名字。</span><br><span class=\"line\">（3）成员的属性描述符。</span><br><span class=\"line\"></span><br><span class=\"line\">function logMethod(params: any) &#123;</span><br><span class=\"line\">    return function(target:any,methodName:any,desc:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(methodName);</span><br><span class=\"line\">        console.log(desc);</span><br><span class=\"line\">        target.apiUrl=&quot;动态扩展的属性&quot;;</span><br><span class=\"line\">        target.run = function() &#123;</span><br><span class=\"line\">            console.log(&quot;我是run方法&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @logMethod(&quot;http://baidu.com&quot;)</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http:any = new httpClient();</span><br><span class=\"line\">http.run();</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">function logMethod(params: any) &#123;</span><br><span class=\"line\">    return function(target:any,methodName:any,desc:any) &#123;</span><br><span class=\"line\">        console.log(target);</span><br><span class=\"line\">        console.log(methodName);</span><br><span class=\"line\">        console.log(desc);</span><br><span class=\"line\">        //修改装饰器的方法 把装饰器方法传入所以参数改为string类型</span><br><span class=\"line\">        //保存当前的方法</span><br><span class=\"line\">        var oMethod = desc.value;</span><br><span class=\"line\">        desc.value = function(...args:any[]) &#123;</span><br><span class=\"line\">            args = args.map((value)=&gt;&#123;</span><br><span class=\"line\">                return String(value)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">httpClient &#123;</span><br><span class=\"line\">    public url:any | undefined;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @logMethod(&quot;http://baidu.com&quot;)</span><br><span class=\"line\">    getData() &#123;</span><br><span class=\"line\">        console.log(this.url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var http:any = new httpClient();</span><br><span class=\"line\">http.getData(123,&apos;xxx&apos;);</span><br></pre></td></tr></table></figure>"},{"title":"React-router-dom","_content":"\n","source":"_posts/React/React-router-dom.md","raw":"---\ntitle: React-router-dom\ncategories: ['React']\ntags: ['React路由'] \n---\n\n","slug":"React/React-router-dom","published":1,"date":"2019-06-27T06:15:21.000Z","updated":"2019-06-27T07:10:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxfi9j9z0000ugs6gn370rd1","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cjxe9u0go00067xuqwuurefq6","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0gu000d7xuqzsalyoj4"},{"post_id":"cjxe9u0gi00017xuq9yl0jern","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0gw000h7xuqw4a20lps"},{"post_id":"cjxe9u0gq00077xuq2crpcbz1","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0gy000k7xuq73bnmii9"},{"post_id":"cjxe9u0gs000b7xuq9tkgdez6","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h0000o7xuqyv2jbqwl"},{"post_id":"cjxe9u0gk00027xuqraa9utmj","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h1000r7xuqenlzmsu3"},{"post_id":"cjxe9u0gt000c7xuqyn2ykt0w","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h2000u7xuq7wkq8hmj"},{"post_id":"cjxe9u0gv000g7xuqa4jnkqag","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h4000x7xuqhmdywh15"},{"post_id":"cjxe9u0gn00057xuqwro5ary2","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h500107xuq6qtht6kf"},{"post_id":"cjxe9u0gx000j7xuqngf4zxa5","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h600137xuqio3xw27i"},{"post_id":"cjxe9u0gz000n7xuq6u9glw5z","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h600157xuqhcwgg9k5"},{"post_id":"cjxe9u0h0000q7xuq2weeschb","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h600177xuq55om6xj5"},{"post_id":"cjxe9u0h2000t7xuq8hbg061j","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h700187xuqq309nkij"},{"post_id":"cjxe9u0h3000w7xuq1dy021so","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h7001b7xuq3uvh4fvm"},{"post_id":"cjxe9u0h4000z7xuq7gq2wpia","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h7001c7xuqajtbfs59"},{"post_id":"cjxe9u0h500127xuqkdbuc20g","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0h8001e7xuqqliphsg2"},{"post_id":"cjxe9u0i5001r7xuqtc52xwy4","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0i8001t7xuq7oxqm9ia"},{"post_id":"cjxe9u0ig001z7xuq9x12s5og","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0il00277xuqtulwhga1"},{"post_id":"cjxe9u0ie001u7xuqk1cj7dnf","category_id":"cjxe9u0if001w7xuqecrtjjuz","_id":"cjxe9u0in002c7xuqnxqom5tc"},{"post_id":"cjxe9u0ih00207xuqq5wgh6s8","category_id":"cjxe9u0if001w7xuqecrtjjuz","_id":"cjxe9u0io002f7xuqq0koki5y"},{"post_id":"cjxe9u0ie001v7xuqqguw857i","category_id":"cjxe9u0if001w7xuqecrtjjuz","_id":"cjxe9u0iq002j7xuqz82t2qhw"},{"post_id":"cjxe9u0ik00267xuqbbpt01r5","category_id":"cjxe9u0if001w7xuqecrtjjuz","_id":"cjxe9u0ir002m7xuqddqifrg9"},{"post_id":"cjxe9u0im002b7xuq4wevfoso","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0is002o7xuq88e4zmjs"},{"post_id":"cjxe9u0ig001y7xuqh7bnopa2","category_id":"cjxe9u0il00287xuqd11aclmo","_id":"cjxe9u0is002q7xuqu7i8zbdz"},{"post_id":"cjxe9u0io002e7xuqknjqy56n","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0it002s7xuq1ds8a4fw"},{"post_id":"cjxe9u0ip002i7xuq8xizslvl","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0it002u7xuqbrjdo47d"},{"post_id":"cjxe9u0ij00247xuqbxxl3uyd","category_id":"cjxe9u0ip002g7xuqhsp68z5d","_id":"cjxe9u0iu002v7xuqlwe48s9e"},{"post_id":"cjxe9u0iq002l7xuqm8x5kpk6","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0iu002y7xuqtrmh795t"},{"post_id":"cjxe9u0j600347xuq3u2x2ghf","category_id":"cjxe9u0if001w7xuqecrtjjuz","_id":"cjxe9u0j800367xuqvpzn8i6g"},{"post_id":"cjxe9u0jg00387xuql1z2zg98","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0jn003f7xuq4vibe5x6"},{"post_id":"cjxe9u0jh003a7xuqr36yebyn","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0jo003h7xuqdgesxtmh"},{"post_id":"cjxe9u0ji003c7xuq61u00gwo","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0jp003j7xuqy3b1y9f2"},{"post_id":"cjxe9u0jf00377xuqr4rro48i","category_id":"cjxe9u0jh00397xuq0wxyg4dr","_id":"cjxe9u0jp003k7xuqtxyhxfuj"},{"post_id":"cjxe9u0jl003e7xuq8vpfoids","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0jp003l7xuq5illhu35"},{"post_id":"cjxe9u0jt003m7xuqd1rc2w5s","category_id":"cjxe9u0gl00037xuqo950mday","_id":"cjxe9u0jv003o7xuqbhjenhvl"},{"post_id":"cjxfi9j9z0000ugs6gn370rd1","category_id":"cjxfi9ja40001ugs67xm3t8cm","_id":"cjxfi9jab0004ugs6hat0x8dr"}],"PostTag":[{"post_id":"cjxe9u0gi00017xuq9yl0jern","tag_id":"cjxe9u0gn00047xuq8tu5yoe7","_id":"cjxe9u0gs000a7xuq6h3m9nlv"},{"post_id":"cjxe9u0gk00027xuqraa9utmj","tag_id":"cjxe9u0gq00097xuqlo3eqjmg","_id":"cjxe9u0gx000i7xuqpx8coy2n"},{"post_id":"cjxe9u0gv000g7xuqa4jnkqag","tag_id":"cjxe9u0gq00097xuqlo3eqjmg","_id":"cjxe9u0gz000m7xuqdiszjhn0"},{"post_id":"cjxe9u0gn00057xuqwro5ary2","tag_id":"cjxe9u0gv000f7xuqn84f1njb","_id":"cjxe9u0h0000p7xuqz7izcwmd"},{"post_id":"cjxe9u0go00067xuqwuurefq6","tag_id":"cjxe9u0gv000f7xuqn84f1njb","_id":"cjxe9u0h3000v7xuqr39o2278"},{"post_id":"cjxe9u0gq00077xuq2crpcbz1","tag_id":"cjxe9u0gv000f7xuqn84f1njb","_id":"cjxe9u0h500117xuqedewa1fw"},{"post_id":"cjxe9u0gs000b7xuq9tkgdez6","tag_id":"cjxe9u0h4000y7xuqrj0i1qid","_id":"cjxe9u0h600167xuq0sydfizv"},{"post_id":"cjxe9u0gt000c7xuqyn2ykt0w","tag_id":"cjxe9u0h600147xuqevvtlzxt","_id":"cjxe9u0h7001a7xuq43as1dk9"},{"post_id":"cjxe9u0gx000j7xuqngf4zxa5","tag_id":"cjxe9u0h700197xuqifvb1gw9","_id":"cjxe9u0h8001f7xuqicm9pqbg"},{"post_id":"cjxe9u0gz000n7xuq6u9glw5z","tag_id":"cjxe9u0h7001d7xuq6yh1twya","_id":"cjxe9u0h8001h7xuqod58usg0"},{"post_id":"cjxe9u0h0000q7xuq2weeschb","tag_id":"cjxe9u0h4000y7xuqrj0i1qid","_id":"cjxe9u0h8001j7xuq6iswvmc9"},{"post_id":"cjxe9u0h2000t7xuq8hbg061j","tag_id":"cjxe9u0h8001i7xuqhmnwc2pa","_id":"cjxe9u0h9001l7xuqse510cxr"},{"post_id":"cjxe9u0h3000w7xuq1dy021so","tag_id":"cjxe9u0h9001k7xuqanlh5sk0","_id":"cjxe9u0h9001n7xuqtqvelzrw"},{"post_id":"cjxe9u0h4000z7xuq7gq2wpia","tag_id":"cjxe9u0h9001k7xuqanlh5sk0","_id":"cjxe9u0ha001p7xuqr2jwyw6e"},{"post_id":"cjxe9u0h500127xuqkdbuc20g","tag_id":"cjxe9u0h9001k7xuqanlh5sk0","_id":"cjxe9u0ha001q7xuq7v067k50"},{"post_id":"cjxe9u0i5001r7xuqtc52xwy4","tag_id":"cjxe9u0gq00097xuqlo3eqjmg","_id":"cjxe9u0i7001s7xuqqi6sctu4"},{"post_id":"cjxe9u0ie001u7xuqk1cj7dnf","tag_id":"cjxe9u0if001x7xuq4m5ihfmq","_id":"cjxe9u0ij00237xuqiy8zayj8"},{"post_id":"cjxe9u0ih00207xuqq5wgh6s8","tag_id":"cjxe9u0if001x7xuq4m5ihfmq","_id":"cjxe9u0ik00257xuqtqtxyqe4"},{"post_id":"cjxe9u0ie001v7xuqqguw857i","tag_id":"cjxe9u0if001x7xuq4m5ihfmq","_id":"cjxe9u0im002a7xuq7j2mjy70"},{"post_id":"cjxe9u0ik00267xuqbbpt01r5","tag_id":"cjxe9u0if001x7xuq4m5ihfmq","_id":"cjxe9u0io002d7xuql32w42ze"},{"post_id":"cjxe9u0ig001y7xuqh7bnopa2","tag_id":"cjxe9u0il00297xuqf6jkr9hx","_id":"cjxe9u0iq002k7xuqgr3k2392"},{"post_id":"cjxe9u0ig001z7xuq9x12s5og","tag_id":"cjxe9u0ip002h7xuqitqs84qh","_id":"cjxe9u0is002p7xuq72gkawzj"},{"post_id":"cjxe9u0ij00247xuqbxxl3uyd","tag_id":"cjxe9u0ir002n7xuqxkxih4qn","_id":"cjxe9u0it002t7xuqu68lqu2a"},{"post_id":"cjxe9u0im002b7xuq4wevfoso","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0iu002x7xuqli6wvdqv"},{"post_id":"cjxe9u0io002e7xuqknjqy56n","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0iv00307xuqu72bwuty"},{"post_id":"cjxe9u0ip002i7xuq8xizslvl","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0iv00327xuqxxlfeap6"},{"post_id":"cjxe9u0iq002l7xuqm8x5kpk6","tag_id":"cjxe9u0iv00317xuq0iuu0wy2","_id":"cjxe9u0iw00337xuqbb41ruqd"},{"post_id":"cjxe9u0j600347xuq3u2x2ghf","tag_id":"cjxe9u0if001x7xuq4m5ihfmq","_id":"cjxe9u0j800357xuq80xxb3vh"},{"post_id":"cjxe9u0jg00387xuql1z2zg98","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0ji003b7xuqpt56p26w"},{"post_id":"cjxe9u0jh003a7xuqr36yebyn","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0jl003d7xuqlxzcdtkr"},{"post_id":"cjxe9u0ji003c7xuq61u00gwo","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0jo003g7xuqo31b7sis"},{"post_id":"cjxe9u0jl003e7xuq8vpfoids","tag_id":"cjxe9u0it002r7xuqs1thwnvu","_id":"cjxe9u0jp003i7xuqw9cn56nn"},{"post_id":"cjxe9u0jt003m7xuqd1rc2w5s","tag_id":"cjxe9u0ju003n7xuqomsluh82","_id":"cjxe9u0jv003p7xuq2fkw6hfx"},{"post_id":"cjxfi9j9z0000ugs6gn370rd1","tag_id":"cjxfi9jaa0002ugs60puyat1x","_id":"cjxfi9jab0003ugs65v8mfk5i"}],"Tag":[{"name":"模板引擎","_id":"cjxe9u0gn00047xuq8tu5yoe7"},{"name":"html5","_id":"cjxe9u0gq00097xuqlo3eqjmg"},{"name":"canvas","_id":"cjxe9u0gv000f7xuqn84f1njb"},{"name":"工具","_id":"cjxe9u0h4000y7xuqrj0i1qid"},{"name":"兼容性","_id":"cjxe9u0h600147xuqevvtlzxt"},{"name":"html","_id":"cjxe9u0h700197xuqifvb1gw9"},{"name":"css预处理器","_id":"cjxe9u0h7001d7xuq6yh1twya"},{"name":"模块化开发","_id":"cjxe9u0h8001i7xuqhmnwc2pa"},{"name":"javaScript","_id":"cjxe9u0h9001k7xuqanlh5sk0"},{"name":"JavaScript","_id":"cjxe9u0if001x7xuq4m5ihfmq"},{"name":"Mongodb","_id":"cjxe9u0il00297xuqf6jkr9hx"},{"name":"Vuex","_id":"cjxe9u0ip002h7xuqitqs84qh"},{"name":"排序算法","_id":"cjxe9u0ir002n7xuqxkxih4qn"},{"name":"面向对象","_id":"cjxe9u0it002r7xuqs1thwnvu"},{"name":"css","_id":"cjxe9u0iv00317xuq0iuu0wy2"},{"name":"TypeScript","_id":"cjxe9u0ju003n7xuqomsluh82"},{"name":"React路由","_id":"cjxfi9jaa0002ugs60puyat1x"}]}}